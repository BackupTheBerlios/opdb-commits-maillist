From meni at berlios.de  Sun Apr  9 13:27:12 2006
From: meni at berlios.de (meni at berlios.de)
Date: Sun, 9 Apr 2006 13:27:12 +0200
Subject: [opdb-commits] r1 - /
Message-ID: <200604091127.k39BRCcS014822@sheep.berlios.de>

Author: meni
Date: 2006-04-09 13:27:02 +0200 (Sun, 09 Apr 2006)
New Revision: 1

Added:
   branches/
   tags/
   trunk/
Log:
Added basic structure.




From livne at kde.org  Mon Apr 10 21:27:59 2006
From: livne at kde.org (Meni Livne)
Date: Mon, 10 Apr 2006 21:27:59 +0200
Subject: [opdb-commits] r2 - in trunk: . client client/firephish client/firephish/firephish client/firephish/firephish/components client/firephish/firephish/content client/firephish/firephish/content/images client/firephish/firephish/locale client/firephish/firephish/locale/en-US client/firephish/firephish/platform client/firephish/firephish/platform/Linux_x86-gcc3 client/firephish/firephish/platform/Linux_x86-gcc3/components client/firephish/firephish/platform/WINNT_x86-msvc client/firephish/firephish/platform/WINNT_x86-msvc/components client/firephish/firephish/skin client/firephish/xpcom client/karpion client/karpion/doc client/karpion/doc/en client/karpion/po client/karpion/src client/libphish client/libphish/doc client/libphish/src
Message-ID: <200604101927.k3AJRwN2021566@sheep.berlios.de>

SVN commit 2 by meni:

Importing initial versions.


 A             client (directory)  
 A             client/firephish (directory)  
 A             client/firephish/README  
 A             client/firephish/TODO  
 A             client/firephish/firephish (directory)  
 AM            client/firephish/firephish.xpi  
 A             client/firephish/firephish/chrome.manifest  
 A             client/firephish/firephish/components (directory)  
 AM            client/firephish/firephish/components/IFirePhish.xpt  
 A             client/firephish/firephish/content (directory)  
 A             client/firephish/firephish/content/about.xul  
 A             client/firephish/firephish/content/firephish.js  
 A             client/firephish/firephish/content/images (directory)  
 AM            client/firephish/firephish/content/images/phish.png  
 A             client/firephish/firephish/content/overlay.xul  
 A             client/firephish/firephish/content/safelist.xul  
 A             client/firephish/firephish/install.rdf  
 A             client/firephish/firephish/locale (directory)  
 A             client/firephish/firephish/locale/en-US (directory)  
 A             client/firephish/firephish/locale/en-US/overlay.dtd  
 A             client/firephish/firephish/locale/en-US/phish.dtd  
 A             client/firephish/firephish/platform (directory)  
 A             client/firephish/firephish/platform/Linux_x86-gcc3 (directory)  
 A             client/firephish/firephish/platform/Linux_x86-gcc3/components (directory)  
 AM            client/firephish/firephish/platform/Linux_x86-gcc3/components/FirePhish.so  
 A             client/firephish/firephish/platform/WINNT_x86-msvc (directory)  
 A             client/firephish/firephish/platform/WINNT_x86-msvc/components (directory)  
 AM            client/firephish/firephish/platform/WINNT_x86-msvc/components/FirePhish.dll  
 A             client/firephish/firephish/skin (directory)  
 A             client/firephish/firephish/skin/overlay.css  
 AM            client/firephish/firephish/skin/phishicon.png  
 A             client/firephish/update.rdf  
 A             client/firephish/xpcom (directory)  
 A             client/firephish/xpcom/FirePhish.cpp  
 A             client/firephish/xpcom/FirePhish.h  
 A             client/firephish/xpcom/FirePhishModule.cpp  
 A             client/firephish/xpcom/IFirePhish.h  
 A             client/firephish/xpcom/IFirePhish.idl  
 A             client/firephish/xpcom/Makefile  
 A             client/karpion (directory)  
 A             client/karpion/AUTHORS  
 A             client/karpion/COPYING  
 A             client/karpion/ChangeLog  
 A             client/karpion/INSTALL  
 A             client/karpion/Makefile.am  
 A             client/karpion/Makefile.cvs  
 A             client/karpion/NEWS  
 A             client/karpion/README  
 A             client/karpion/TODO  
 A             client/karpion/config.h.in  
 A             client/karpion/configure.in  
 A             client/karpion/configure.in.in  
 A             client/karpion/doc (directory)  
 A             client/karpion/doc/Makefile.am  
 A             client/karpion/doc/en (directory)  
 A             client/karpion/doc/en/Makefile.am  
 A             client/karpion/doc/en/index.docbook  
 A             client/karpion/karpion.kdevelop  
 A             client/karpion/po (directory)  
 A             client/karpion/po/Makefile.am  
 A             client/karpion/src (directory)  
 A             client/karpion/src/Makefile.am  
 AM            client/karpion/src/cr16-action-karpion.png  
 AM            client/karpion/src/cr22-action-karpion.png  
 A             client/karpion/src/karpion.lsm  
 A             client/karpion/src/karpionconfigdlg.ui  
 A             client/karpion/src/karpionconfigdlgimpl.cpp  
 A             client/karpion/src/karpionconfigdlgimpl.h  
 A             client/karpion/src/plugin_karpion.cpp  
 A             client/karpion/src/plugin_karpion.desktop  
 A             client/karpion/src/plugin_karpion.h  
 A             client/karpion/src/plugin_karpion.rc  
 A             client/libphish (directory)  
 A             client/libphish/AUTHORS  
 A             client/libphish/COPYING  
 A             client/libphish/ChangeLog  
 A             client/libphish/INSTALL  
 A             client/libphish/Makefile.am  
 A             client/libphish/Makefile.cvs  
 A             client/libphish/NEWS  
 A             client/libphish/README  
 A             client/libphish/TODO  
 A             client/libphish/configure.in  
 A             client/libphish/doc (directory)  
 A             client/libphish/doc/Doxyfile  
 A             client/libphish/doc/annotated.html  
 A             client/libphish/doc/doxygen.css  
 AM            client/libphish/doc/doxygen.png  
 A             client/libphish/doc/files.html  
 AM            client/libphish/doc/ftv2blank.png  
 AM            client/libphish/doc/ftv2doc.png  
 AM            client/libphish/doc/ftv2folderclosed.png  
 AM            client/libphish/doc/ftv2folderopen.png  
 AM            client/libphish/doc/ftv2lastnode.png  
 AM            client/libphish/doc/ftv2link.png  
 AM            client/libphish/doc/ftv2mlastnode.png  
 AM            client/libphish/doc/ftv2mnode.png  
 AM            client/libphish/doc/ftv2node.png  
 AM            client/libphish/doc/ftv2plastnode.png  
 AM            client/libphish/doc/ftv2pnode.png  
 AM            client/libphish/doc/ftv2vertline.png  
 A             client/libphish/doc/functions.html  
 A             client/libphish/doc/functions_vars.html  
 A             client/libphish/doc/globals.html  
 A             client/libphish/doc/globals_enum.html  
 A             client/libphish/doc/globals_eval.html  
 A             client/libphish/doc/globals_func.html  
 A             client/libphish/doc/globals_type.html  
 A             client/libphish/doc/index.html  
 A             client/libphish/doc/main.html  
 A             client/libphish/doc/phish_8h-source.html  
 A             client/libphish/doc/phish_8h.html  
 A             client/libphish/doc/structphish__url__data__t.html  
 A             client/libphish/doc/tree.html  
 A             client/libphish/libphish-config.in  
 A             client/libphish/libphish.kdevelop  
 A             client/libphish/src (directory)  
 A             client/libphish/src/Makefile.am  
 A             client/libphish/src/phish.c  
 A             client/libphish/src/phish.h  
 A             client/libphish/src/phish_local_xml.c  
 A             client/libphish/src/phish_local_xml.h  
 A             client/libphish/src/phish_opdb_server.c  
 A             client/libphish/src/phish_opdb_server.h  
 A             client/libphish/src/phish_safelist.c  
 A             client/libphish/src/phish_safelist.h  
 A             client/libphish/src/phish_settings.c  
 A             client/libphish/src/phish_settings.h  
 A             client/libphish/src/phish_util_ll.c  
 A             client/libphish/src/phish_util_ll.h  
 A             client/libphish/src/phish_util_net.c  
 A             client/libphish/src/phish_util_net.h  
 A             client/libphish/src/phish_util_url.c  
 A             client/libphish/src/phish_util_url.h  


--- trunk/client/firephish/README #1:2

ABOUT FIREPHISH

FirePhish is an extension for the Firefox browser that helps protect against
phishing attacks.
See http://opdb.berlios.de/doc/firephish-manual.html for a short guide to
FirePhish.


ABOUT OPDB

FirePhish is part of the Open Phishing Database project, an effort to create
maintain and open database of phishing sites in order to protect users,
in addition to providing extensions to browsers that utilise the database.


THE ICON

The anti-phishing icon is based on the babelfish icon from Everaldo's crystal
icon set for KDE: http://www.kde-look.org/content/show.php?content=8341


MORE INFORMATION

See the OPDB website at http://opdb.berlios.de/ for general information about
the Open Phishing Database, browser extensions, and contact information and
mailing lists.


** trunk/client/firephish/firephish.xpi #property svn:mime-type
   + application/octet-stream
--- trunk/client/firephish/firephish/chrome.manifest #1:2

content	firephish	content/
overlay	chrome://browser/content/browser.xul	chrome://firephish/content/overlay.xul

locale	firephish	en-US	locale/en-US/

skin	firephish	classic/1.0	skin/
style	chrome://global/content/customizeToolbar.xul	chrome://firephish/skin/overlay.css
** trunk/client/firephish/firephish/components/IFirePhish.xpt #property svn:mime-type
   + application/octet-stream
--- trunk/client/firephish/firephish/content/about.xul #1:2

<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<!DOCTYPE window SYSTEM "chrome://firephish/locale/phish.dtd">

<window 
  id="firephish-about-window" 
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" 
  title="FirePhish Toolbar 0.1">
  
  <html>
  
  <html:p>
  <html:img src="chrome://firephish/content/images/phish.png" width="32" height="32" allign="center" />
  </html:p>
  

  <html:p>
    <html:br/>
    <html:br/>
    FirePhish Anti-Phishing Toolbar 0.1
    <html:br/>
    Boaz Anin, Shahar Karin
    <html:br/>
    TAU 2006    
    <html:br/>
    <html:a href="mailto:opdb-core-devel at opdb.berlios.de"> opdb-core-devel at opdb.berlios.de </html:a>
    <html:br/>
    Thanks to:
    <html:br/>
    Meni Livne
  </html:p>
  
  </html>


</window>
--- trunk/client/firephish/firephish/content/firephish.js #1:2

var FirePhish =
{

  changeRiskLabel:function(text, color)
  {
   	document.getElementById("FirePhish-RiskLevelValuelabel").value = text;
	  setStyle("FirePhish-RiskLevelValuelabel", "color", color);
  },
  

  checkURL:function(wf_url)
  {
	try  {
    FirePhish.obj.ResetResults(); //Reset previous results.
	  var res = 0
	  res = FirePhish.obj.CheckSafeList(wf_url);
	  
	  if (res) //it's in the safe list.
	  {
	    setStyle("urlbar-container", "backgroundColor", "green");
		  FirePhish.changeRiskLabel("Safe", "green");
      
      //Check country (if online mode)
      if (FirePhish.getRunningMode())
      {
        FirePhish.obj.CheckCountry(wf_url);
      }
      
      document.getElementById("fp-siteinfo").setAttribute("disabled", "false");
      
      //Set the country name label  
      FirePhish.setCountryLabel();
	    return;
	  }
	  
	  urlstr = new String(wf_url);
    if (urlstr.substring(0,6) == "chrome") //don't check "chrome" prefix in the DB.
    { 
      res = 0;
    }
    else   
      res = FirePhish.obj.CheckURL(wf_url);
    
    document.getElementById("fp-siteinfo").setAttribute("disabled", "false");
    if (res == 3)
    {
      FirePhish.flck = setInterval('FirePhish.riskFlicker()', 600);
		  
		  FirePhish.changeRiskLabel("High", "red");
		}
	  else if (res == 2)
		  FirePhish.changeRiskLabel("Medium", "orange");
	  else if (res == 1)
		  FirePhish.changeRiskLabel("Low", "green");
    else if (res == 0)
    {
      FirePhish.changeRiskLabel("Unknown", "grey");
      document.getElementById("fp-siteinfo").setAttribute("disabled", "true");
    }
      
    //Set the country name label  
    FirePhish.setCountryLabel();
    } 
    catch (err)
	  {
      alert('Error' + err);
    }

    return res;
  },
  
  setCountryLabel:function()
  {
    cntry = new String(FirePhish.obj.GetCountry());
    document.getElementById("FirePhish-CountryValuelabel").value = "";
     
    if (cntry != "")
    {
      document.getElementById("fp-countrylabel").setAttribute("value", "Country:");
      document.getElementById("FirePhish-CountryValuelabel").value = cntry;
    }
    else if (cntry == "" && FirePhish.getRunningMode())
    {
      document.getElementById("fp-countrylabel").setAttribute("value", "Country:");
      document.getElementById("FirePhish-CountryValuelabel").value = "Unknown";
    }
      
  },
  
  riskFlicker:function()
  {
   try
   {
    if (document.getElementById("urlbar-container").style["backgroundColor"] == "red")
      setStyle("urlbar-container", "backgroundColor", null);
    else
      setStyle("urlbar-container", "backgroundColor", "red");
   }
   catch (err)
	 {
     alert('Error' + err);
   }     
   
  },
  
  setRunningMode:function(mode)
  {
    try
    {
      FirePhish.obj.SetRunningMode(mode);
      onl = document.getElementById("fp-online");
      offl = document.getElementById("fp-offline");
	
      //change checked items accordingly
      onl.setAttribute("checked", (mode? "true" : "false"));
      offl.setAttribute("checked", (mode? "false" : "true"));

    }
    catch (err)
	  {
      alert('Error: ' + err);
    }
  },
  
  setSiteQueryURL:function()
  {
    answer = prompt("Change the URL to which online, real-time\n" +
                    "site risk-level queries are sent." , FirePhish.getSiteQueryURL(), "Site Query URL");
    if (!answer)
      return;
      
    FirePhish.obj.SetSiteQueryURL(answer);
    
  },
  
  setCountryQueryURL:function()
  {
    answer = prompt("Change the URL to which country queries are sent.", FirePhish.getCountryQueryURL(), "Country Query URL");
    if (!answer)
      return;
      
    FirePhish.obj.SetCountryQueryURL(answer);
  },
  
  setReportSiteURL:function()
  {
    answer = prompt("Change the URL to which you can report a site as phishy.", FirePhish.getReportSiteURL(), "Site Report URL");
    if (!answer)
      return;
      
    FirePhish.obj.SetReportSiteURL(answer);
  },
  
  setRemoteXMLURL:function()
  {
    answer = prompt("Change the location of the XML file which is downloaded\n"+
                    "to be used locally when checking risk-level of sites in offline mode:", FirePhish.getRemoteXMLURL(), "Remote XML URL");
    if (!answer)
      return;
    
    FirePhish.obj.SetRemoteXMLURL(answer);
      
  },
  
  /////Configuration getters
  getRunningMode:function()
  {
    return FirePhish.obj.GetRunningMode();
  },
  
  getSiteQueryURL:function()
  {
    res = new String(FirePhish.obj.GetSiteQueryURL());
    return res;
  },
  
  getCountryQueryURL:function()
  {
    res = new String(FirePhish.obj.GetCountryQueryURL());
    return res;
  },
  
  getReportSiteURL:function()
  {
    res = new String(FirePhish.obj.GetReportSiteURL());
    return res;
  },
  
  getRemoteXMLURL:function()
  {
    res = new String(FirePhish.obj.GetRemoteXMLURL());
    return res;
  },
  
  getLocalXMLFile:function()
  {
    res = new String(FirePhish.obj.GetLocalXMLFile());
    return res;
  },
  
  getSafeListFile:function()
  {
    res = new String(FirePhish.obj.GetSafeListFile());
    return res;
  },
  
  editSafeList:function()
  {
    window.open("chrome://firephish/content/safelist.xul", "SafeListEditor",
                "menubar=no, location=no, resizable=yes, scrollbars=yes, status=no, height=450, width=400, titlebar=yes, modal=yes");
    
      
  },
    
  populateSafeList:function()
  {
    try {
      listb = document.getElementById("fp-safelist-listbox");
      
      //First, clear what is there
	    while (listb.getRowCount() > 0)
		     listb.removeItemAt(0);      
            
      safeurl = new String(FirePhish.obj.GetSafelistNext());
      
      while (safeurl != "")
      {
        litem = listb.appendItem(safeurl, safeurl);
        safeurl = new String(FirePhish.obj.GetSafelistNext());      
      }
      
      
    }
    catch (err) {
      alert(err);  
    }
    
	},
	
	
	//Check the correct mode in the 'set mode' popup for the first time.
	setModeChecks:function()
	{
		try
		{
		  
		  onl = document.getElementById("fp-online");
      offl = document.getElementById("fp-offline");
	
		  if (!FirePhish.getRunningMode()) //offline mode
		    offl.setAttribute("checked", "true");
		  else
		    onl.setAttribute("checked", "true");
		
		}
		catch (err) 
		{
		  alert(err);
		  return;
		}
	},
	
	reportCurrentURL:function()
	{
	  try 
	  {
	    
	    rep_url = FirePhish.obj.GetReportingURL(window.content.document.location);
	    winref = window.open(rep_url, "Report the site as phishy",
             "menubar=no, location=no, resizable=yes, scrollbars=yes, status=no, height=480, width=480, titlebar=yes, modal=yes");
	  }
	  catch (err) 
		{
		  alert(err);
		  return;
		} 
	  
	},
	
	saveSafeList:function()
	{
    try
    {
      if (!confirm("Are you sure you want to save the changes to the Safe List?\n")) 
        return;
      
    
      listb = document.getElementById("fp-safelist-listbox");

      FirePhish.obj.CreateNewSafeList();

      for (i = 0 ; i < listb.getRowCount() ; i++)
          FirePhish.obj.AddToSafeList(listb.getItemAtIndex(i).label);
          
      FirePhish.obj.SetSafeList();
    }
    catch(err)
    {
      alert(err);
    }
	
	},
	
	//Add the current site to the safe list.
	addSiteToSafeList:function()
	{
	  try
	  {
	    curr_url = window.content.document.location;
	  
	    if (FirePhish.obj.CheckSafeList(curr_url))
	    {
	      alert(curr_url + "\n Is a site which is already considered safe.");
	      return;
	    }
	      
	    FirePhish.obj.AddToCurrentSafeList(window.content.document.location);
	    
	    //Check the site added (so that it will be displayed as safe)
	    FirePhish.checkURL(window.content.document.location);

	  }
    catch(err)
    {
      alert(err);
    }	  
	  
	},
	
	updateXML:function()
	{
	  try
	  {
	    if (FirePhish.xml_timout)
	      clearTimeout(FirePhish.xml_timout);
	    
	    
	    FirePhish.xml_timout = setTimeout('FirePhish.updateXML()', 60000*FirePhish.ud_interval);
	    FirePhish.obj.UpdateXML();
	  }
    catch(err)
    {
      alert(err);
    }
	},
	
	autoUpdate:function()
	{
	  try
	  {

	    answer = prompt("Set an interval (in minutes) between auto-updates from the server.\n" +
                      "The DB will be downloaded only if it has been updated." , FirePhish.ud_interval, "Interval Between Updates");
      if (!answer)
        return;
        
       FirePhish.ud_interval = answer;
	  }
    catch(err)
    {
      alert(err);
    }	  
	},
	
	
  about:function()
  {
    window.open("chrome://firephish/content/about.xul", "About FirePhish",
             "menubar=no, location=no, resizable=yes, scrollbars=yes, status=no, height=150, width=280, titlebar=yes, modal=yes");
  },
  
  
  siteInfo:function()
  {
    try
    {
      info = new String();
      info += "Site information for:\n" + FirePhish.obj.GetLatestURL() + "\n\n";
      
      addition = new String();
      
      server = FirePhish.obj.GetResultServer();
      ip = FirePhish.obj.GetResultIP();
      path = FirePhish.obj.GetResultPath();
      domain = FirePhish.obj.GetResultDomain();
      userscheme = FirePhish.obj.GetResultUserScheme();
      susphost = FirePhish.obj.GetResultSuspiciousHost();
      
      if (server > 0 && path > 0)
        addition += " - This exact URL is listed as phishy\n";
      else if (ip > 0 && path > 0)
        addition += " - ";
      else
      {
        if (server > 0)
          addition += " - The server of this URL is listed as phishy\n";
        
        if (ip > 0)
          addition += " - The IP address of this site is listed as phishy\n";
          
        if (path > 0)
          addition += " - This specific path in this sever is listed as phishy\n";
        
        if (domain > 0)
          addition += " - The domain of this site is listed as phishy\n";
        
        if (userscheme > 0)
          addition += " - This URL has a suspicious login format\n";
          
        if (susphost > 0)
          addition += " - Host is suspicious\n";
      }
      
      risk_level = document.getElementById("FirePhish-RiskLevelValuelabel").value;
      
      if (addition == "")
      {
        if (risk_level == "Low")
          info += "Nothing is suspicious about this site,\n hence the risk level is low.\n";
        else if (risk_level == "Safe")
          info += "This site is considered a safe site, as defined in your Safe List.";          
      }
      else
        info += addition + "The calculated risk level is therefore " + risk_level + ".\n\n";
      
      comments = new String(FirePhish.obj.GetComments());
      
      if (comments.length > 4) //For some reason the length of no-comment is 4...
        info += "Comments about the site:\n" + comments;
        
      //Display the information message    
      alert(info);
      
    }
    catch(err)
    {
      alert(err);
    }
  },
  
};


//Initialize the FirePhish variable
firePhishInit();


function firePhishInit()
{
  if (!FirePhish.obj) //Create the FirePhish object only once
  {
   	try 
		{ 
		FirePhish.obj = new Object;
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		const cid = "@opdb.berlios.de/FirePhish;1";
		FirePhish.obj = Components.classes[cid].createInstance();
		FirePhish.obj = FirePhish.obj.QueryInterface(Components.interfaces.IFirePhish);
		
		//Initialize libphish
		FirePhish.obj.InitPhish(navigator.userAgent, "FirePhish/0.1.0");
		
		//Update-interval for checking the XML file
		FirePhish.ud_interval = 15;
		} 
		catch (err) 
		{
		alert(err);
		return;
		}
		
  }

  //Call for the first time the 'changedURL()' function
  changedURL();
}

FirePhish.prevUrl = 'none';
function changedURL() 
{
 try {
   setTimeout('changedURL()', 1000); // check every second...
   
   if (window.length == 0) //To avoid bad initialization
    return;
    
     
 if (window.content.document.location != FirePhish.prevUrl)
 {
    FirePhish.prevUrl = window.content.document.location; 
 
    //Remove flickering of high-risk site
    if (FirePhish.flck)
    {
      clearInterval(FirePhish.flck)
      FirePhish.flck = null;
    }
    
   //Disable site info button (until it's a checked site)
   document.getElementById("fp-siteinfo").setAttribute("disabled", "true"); 
   
   //Hide country label (until country info. is available)
   document.getElementById("fp-countrylabel").setAttribute("value", "");
   
   //Reset safelist indication
   setStyle("urlbar-container", "backgroundColor", null);
   
   //Check the new URL
   FirePhish.checkURL(window.content.document.location);
 }
   
   

 } catch(err) {
   alert(err)
 }
}    

function setStyle(objId, style, value)
{
  document.getElementById(objId).style[style]= value;
}
** trunk/client/firephish/firephish/content/images/phish.png #property svn:mime-type
   + application/octet-stream
--- trunk/client/firephish/firephish/content/overlay.xul #1:2

<?xml version="1.0"?>
<?xml-stylesheet href="chrome://firephish/skin/overlay.css"
                 type="text/css"?>

<overlay id="FirePhish-overlay" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<script type="application/x-javascript" src="chrome://firephish/content/firephish.js"/>

  <toolbox id="navigator-toolbox">
  
    <toolbar id="FirePhish-toolbar" accesskey="P" class="chromeclass-toolbar"
                context="toolbar-context-menu" toolbarname="FirePhish Toolbar"
                hidden="false" persist="hidden">
     <hbox>

      <toolbarbutton id="FirePhish-toolbarmenubutton" type="menu" label="Anti-Phishing ">
     
        <menupopup>
    
          <menuitem label="Report this site as Phishing..." accesskey="R"              
                          oncommand="FirePhish.reportCurrentURL()" /> 
    
          <menuitem label="Add site to Safe List" accesskey="S"              
                          oncommand="FirePhish.addSiteToSafeList()" />
	                
	      <menuitem label="Edit Safe List..." accesskey="E"              
		                  oncommand="FirePhish.editSafeList()" />
    
          <menuseparator />
      
          <menu id="fp-settings-menu" label="Settings" accesskey="t">
      
			      <menupopup id="fp-settings-popup">
			      
				      <menu id="fp-mode-menu" label="Running Mode" accesskey="m">
				        <menupopup id="fp-settings-popup" 
				         onpopupshowing="FirePhish.setModeChecks();">
				         
				          <menuitem id="fp-offline"
					        type="checkbox"
					        autocheck = "false"
					        label="Offline" tooltiptext="Sites will be checked using the local XML file"
				           accesskey="f" oncommand="FirePhish.setRunningMode(0);"/>

				          <menuitem id="fp-online" 
					          type="checkbox"
					          autocheck = "false"
					          label="Online"  tooltiptext="Site will be checked in the databse on the server"
				           accesskey="n" oncommand="FirePhish.setRunningMode(1);"/>
				        </menupopup>
				      </menu>
				      
				      <menu id="fp-dlxml-menu" label="DB Updates" accesskey="U">
				        <menupopup id="fp-dlxml-popup" 
				         onpopupshowing=";">
				         
				          <menuitem id="fp-updatenow"
					        label="Update Local Database Now" tooltiptext="Downloads from the sever the DB of phishy URLs to a local XML file"
				           accesskey="d" oncommand="FirePhish.updateXML();"/>
				           
				          <menuitem id="fp-updateevery"
					        label="Auto-Update Every..." tooltiptext="Set a time interval between auto-checking for DB updates"
				           accesskey="A" oncommand="FirePhish.autoUpdate();"/>

				        </menupopup>
				      </menu>
				      
				      <menu id="fp-advanced-menu" label="Advanced" accesskey="A">
				      
				        <menupopup id="fp-adv-popup">
				          <menuitem label="Site Query URL..." oncommand="FirePhish.setSiteQueryURL()"
				          tooltiptext="Change the URL of the site to which online-mode site queries are sent"/>  
    				      
				          <menuitem label="Country Query URL..." oncommand="FirePhish.setCountryQueryURL()"
				          tooltiptext="Change the URL of the site to which country queries are sent"/>   
    				      
				          <menuitem label="Site report URL..." oncommand="FirePhish.setReportSiteURL()"
				          tooltiptext="Change the URL of the site to which you can report phishy sites"/>
    				      
				          <menuitem label="Remote XML File URL..." oncommand="FirePhish.setRemoteXMLURL()"
				          tooltiptext="Change the URL from which an XML file is downloaded"/>
    				      			      
				        </menupopup>
				      </menu>

			      
			      </menupopup>
            
          </menu>
   
          <menuseparator />

          <menuitem label="About..." accesskey="A"              
                          oncommand="FirePhish.about()" />

        </menupopup>

      </toolbarbutton>

      <toolbarseparator/>

      <label id="FirePhish-RiskLevelLabel" value="Risk level:" style="padding-top: 7px; padding-left: 1px;" />

      <label id="FirePhish-RiskLevelValuelabel" value="Unknown" style="padding-top: 7px; color: gray; font-weight: bold;" />

      <toolbarbutton id="fp-siteinfo" tooltiptext="Information about the site"
                        label="Site Information" oncommand="FirePhish.siteInfo()" />

      <toolbarseparator/>
      <label id="fp-countrylabel" value="" style="padding-top: 7px; padding-left: 1px;" />

      <label id="FirePhish-CountryValuelabel" value="" style="padding-top: 7px; padding-right: 6px;" />
     </hbox>
    </toolbar>

  </toolbox>

</overlay>


--- trunk/client/firephish/firephish/content/safelist.xul #1:2

<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<!DOCTYPE window SYSTEM "chrome://firephish/locale/phish.dtd">

<window 
  id="firephish-safelist-window"
  orient="vertical"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" 
  title="FirePhish Safe List Editor">
  
  <script type="application/x-javascript" src="chrome://firephish/content/firephish.js"/>
    
  <vbox flex="1">

    <description>
      Edit your Safe List.
      Any URL containing a URL in the Safe List as a prefix is considered safe.
    </description>
    
    <hbox>

    <button label="Save" accesskey="S" oncommand="FirePhish.saveSafeList();"/> 
    
    
    <button label="Add..." accesskey="A" oncommand="listb = document.getElementById(&quot;fp-safelist-listbox&quot;);
                                                    newurl = prompt(&quot;Enter a URL to add to the safe list:&quot;, &quot;http://&quot;, &quot;Enter a URL&quot;);
                                                    if (newurl) listb.appendItem(newurl, newurl);"/>
    
    
    <button id="fp-edit-sl" label="Edit" accesskey="E" oncommand="listb = document.getElementById(&quot;fp-safelist-listbox&quot;);
                                                                  sel_item = listb.selectedItem;
                                                                  editedurl = prompt(&quot;Edit URL:&quot;, sel_item.label, &quot;Edit Safe List Item&quot;);
                                                                  if (editedurl) sel_item.label = editedurl;"/>
    
    
    <button label="Remove" accesskey="R" oncommand="listb = document.getElementById(&quot;fp-safelist-listbox&quot;);
                                                    listb.removeItemAt(listb.selectedIndex);"/> 
    </hbox>
        
    <listbox flex="1" id = "fp-safelist-listbox">
    </listbox>
    
    

  </vbox>
  
  <script>
  FirePhish.populateSafeList();
  </script>

</window>


--- trunk/client/firephish/firephish/install.rdf #1:2

<?xml version="1.0"?>
<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
     xmlns:em="http://www.mozilla.org/2004/em-rdf#">

  <Description about="urn:mozilla:install-manifest">

    <em:targetApplication>
      <Description>
        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
        <em:minVersion>1.5</em:minVersion>
        <em:maxVersion>1.5.0.*</em:maxVersion>
      </Description>
    </em:targetApplication>
  
    <em:id>firephish at opdb.berlios.de</em:id>
    <em:name>FirePhish Anti-Phishing Extension</em:name>
    <em:version>0.1</em:version>
    <em:description>A tool to prevent phishing.</em:description>
    <em:creator>Boaz Anin, Meni Livne, Shahar Karin</em:creator>

    <em:homepageURL>http://opdb.berlios.de/</em:homepageURL>
    <em:aboutURL>chrome://firephish/content/about.xul</em:aboutURL>
    <em:iconURL>chrome://firephish/skin/phishicon.png</em:iconURL>
    <em:updateURL>http://opdb.berlios.de/download/update.rdf</em:updateURL>
    
    <em:targetPlatform>WINNT_x86-msvc</em:targetPlatform>
    <em:targetPlatform>Linux_x86-gcc3</em:targetPlatform>

  </Description>

</RDF>
--- trunk/client/firephish/firephish/locale/en-US/overlay.dtd #1:2

<!ENTITY firephish "Test FirePhish">
\ No newline at end of file
--- trunk/client/firephish/firephish/locale/en-US/phish.dtd #1:2

<!ENTITY title.label "FirePhish Testing...!">
<!ENTITY separate.label "Boaz is testing stuff!">
<!ENTITY close.label "Close">
\ No newline at end of file
** trunk/client/firephish/firephish/platform/Linux_x86-gcc3/components/FirePhish.so #property svn:mime-type
   + application/octet-stream
** trunk/client/firephish/firephish/platform/WINNT_x86-msvc/components/FirePhish.dll #property svn:mime-type
   + application/octet-stream
--- trunk/client/firephish/firephish/skin/overlay.css #1:2

/* This is just an example. You shouldn't do this. */
#FirePhish-toolbar 
{

}
#FirePhish-toolbarmenubutton
{
    list-style-image: url("chrome://firephish/content/images/phish.png");
    list-style-type: circle;
    background-repeat: no-repeat;
    background-position : center left;
}
\ No newline at end of file
** trunk/client/firephish/firephish/skin/phishicon.png #property svn:mime-type
   + application/octet-stream
--- trunk/client/firephish/update.rdf #1:2

<?xml version="1.0"?>

<r:RDF xmlns:r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
       xmlns="http://www.mozilla.org/2004/em-rdf#">

<r:Description about="urn:mozilla:extension:{05d43694-8abf-11da-9559-00e08161165f}">
  <updates>
    <r:Seq>
      <r:li>
        <r:Description>
          <version>0.1</version>

          <targetApplication>
            <r:Description>
              <id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</id>
              <minVersion>1.5</minVersion>
              <maxVersion>1.5.0.*</maxVersion>
              <updateLink>http://opdb.berlios.de/download/firephish.xpi</updateLink>
            </r:Description>

          </targetApplication>
        </r:Description>
      </r:li>
    </r:Seq>
  </updates>

  <version>0.1</version>
  <updateLink>http://opdb.berlios.de/download/firephish.xpi</updateLink>

</r:Description>

</r:RDF>
\ No newline at end of file
--- trunk/client/firephish/xpcom/FirePhish.cpp #1:2

#include <stdlib.h>
#include <map>
#include <string>
#include "FirePhish.h"
#include <phish.h>
#include <nsMemory.h>
#include <prthread.h>

using std::map;
using std::string;

NS_IMPL_ISUPPORTS1(FirePhish, IFirePhish)

/* void InitPhish (in string agent, in string cver); */
NS_IMETHODIMP FirePhish::InitPhish(const char *agent, const char *cver)
{
  phish_init(agent, cver);
  UpdateXML();
  return NS_OK;
}


FirePhish::FirePhish()
{
  
  //Allocate latest results object
  latest_results = (phish_url_data_t*)nsMemory::Alloc(sizeof(phish_url_data_t));
  
  latest_checked_site = NULL;

  //Initialize the phish_result object
  latest_results->comments = NULL;
  ResetResults();

  m_sl_entry = NULL;
  
  //Initialize TLD-to-fullCountryName map
  //Information taken from http://www.iana.org/ (official site of the
  //Internet Assigned Numbers Authority).
  tld_to_name["AC"] = "Ascension Island";
  tld_to_name["AE"] = "United Arab Emirates";
  tld_to_name["AF"] = "Afghanistan";
  tld_to_name["AG"] = "Antigua and Barbuda";
  tld_to_name["AI"] = "Anguilla";
  tld_to_name["AL"] = "Albania";
  tld_to_name["AM"] = "Armenia";
  tld_to_name["AN"] = "Netherlands Antilles";
  tld_to_name["AO"] = "Angola";
  tld_to_name["AQ"] = "Antarctica";
  tld_to_name["AR"] = "Argentina";
  tld_to_name["AS"] = "American Samoa";
  tld_to_name["AT"] = "Austria";
  tld_to_name["AU"] = "Australia";
  tld_to_name["AW"] = "Aruba";
  tld_to_name["AZ"] = "Azerbaijan";
  tld_to_name["AX"] = "Aland Islands";
  tld_to_name["BA"] = "Bosnia and Herzegovina";
  tld_to_name["BB"] = "Barbados";
  tld_to_name["BD"] = "Bangladesh";
  tld_to_name["BE"] = "Belgium";
  tld_to_name["BF"] = "Burkina Faso";
  tld_to_name["BG"] = "Bulgaria";
  tld_to_name["BH"] = "Bahrain";
  tld_to_name["BI"] = "Burundi";
  tld_to_name["BJ"] = "Benin";
  tld_to_name["BM"] = "Bermuda";
  tld_to_name["BN"] = "Brunei Darussalam";
  tld_to_name["BO"] = "Bolivia";
  tld_to_name["BR"] = "Brazil";
  tld_to_name["BS"] = "Bahamas";
  tld_to_name["BT"] = "Bhutan";
  tld_to_name["BV"] = "Bouvet Island";
  tld_to_name["BW"] = "Botswana";
  tld_to_name["BY"] = "Belarus";
  tld_to_name["BZ"] = "Belize";
  tld_to_name["CA"] = "Canada";
  tld_to_name["CC"] = "Cocos (Keeling) Islands";
  tld_to_name["CD"] = "Congo, The Democratic Republic of the";
  tld_to_name["CF"] = "Central African Republic";
  tld_to_name["CG"] = "Congo, Republic of";
  tld_to_name["CH"] = "Switzerland";
  tld_to_name["CI"] = "Cote d'Ivoire";
  tld_to_name["CK"] = "Cook Islands";
  tld_to_name["CL"] = "Chile";
  tld_to_name["CM"] = "Cameroon";
  tld_to_name["CN"] = "China";
  tld_to_name["CO"] = "Colombia";
  tld_to_name["CR"] = "Costa Rica";
  tld_to_name["CS"] = "Serbia and Montenegro";
  tld_to_name["CU"] = "Cuba";
  tld_to_name["CV"] = "Cape Verde";
  tld_to_name["CX"] = "Christmas Island";
  tld_to_name["CY"] = "Cyprus";
  tld_to_name["CZ"] = "Czech Republic";
  tld_to_name["DE"] = "Germany";
  tld_to_name["DJ"] = "Djibouti";
  tld_to_name["DK"] = "Denmark";
  tld_to_name["DM"] = "Dominica";
  tld_to_name["DO"] = "Dominican Republic";
  tld_to_name["DZ"] = "Algeria";
  tld_to_name["EC"] = "Ecuador";
  tld_to_name["EE"] = "Estonia";
  tld_to_name["EG"] = "Egypt";
  tld_to_name["EH"] = "Western Sahara";
  tld_to_name["ER"] = "Eritrea";
  tld_to_name["ES"] = "Spain";
  tld_to_name["ET"] = "Ethiopia";
  tld_to_name["EU"] = "European Union";
  tld_to_name["FI"] = "Finland";
  tld_to_name["FJ"] = "Fiji";
  tld_to_name["FK"] = "Falkland Islands (Malvinas)";
  tld_to_name["FM"] = "Micronesia, Federal State of";
  tld_to_name["FO"] = "Faroe Islands";
  tld_to_name["FR"] = "France";
  tld_to_name["GA"] = "Gabon";
  tld_to_name["GB"] = "United Kingdom";
  tld_to_name["GD"] = "Grenada";
  tld_to_name["GE"] = "Georgia";
  tld_to_name["GF"] = "French Guiana";
  tld_to_name["GG"] = "Guernsey";
  tld_to_name["GH"] = "Ghana";
  tld_to_name["GI"] = "Gibraltar";
  tld_to_name["GL"] = "Greenland";
  tld_to_name["GM"] = "Gambia";
  tld_to_name["GN"] = "Guinea";
  tld_to_name["GP"] = "Guadeloupe";
  tld_to_name["GQ"] = "Equatorial Guinea";
  tld_to_name["GR"] = "Greece";
  tld_to_name["GS"] = "South Georgia and the South Sandwich Islands";
  tld_to_name["GT"] = "Guatemala";
  tld_to_name["GU"] = "Guam";
  tld_to_name["GW"] = "Guinea-Bissau";
  tld_to_name["GY"] = "Guyana";
  tld_to_name["HK"] = "Hong Kong";
  tld_to_name["HM"] = "Heard and McDonald Islands";
  tld_to_name["HN"] = "Honduras";
  tld_to_name["HR"] = "Croatia/Hrvatska";
  tld_to_name["HT"] = "Haiti";
  tld_to_name["HU"] = "Hungary";
  tld_to_name["ID"] = "Indonesia";
  tld_to_name["IE"] = "Ireland";
  tld_to_name["IL"] = "Israel";
  tld_to_name["IM"] = "Isle of Man";
  tld_to_name["IN"] = "India";
  tld_to_name["IO"] = "British Indian Ocean Territory";
  tld_to_name["IQ"] = "Iraq";
  tld_to_name["IR"] = "Iran, Islamic Republic of";
  tld_to_name["IS"] = "Iceland";
  tld_to_name["IT"] = "Italy";
  tld_to_name["JE"] = "Jersey";
  tld_to_name["JM"] = "Jamaica";
  tld_to_name["JO"] = "Jordan";
  tld_to_name["JP"] = "Japan";
  tld_to_name["KE"] = "Kenya";
  tld_to_name["KG"] = "Kyrgyzstan";
  tld_to_name["KH"] = "Cambodia";
  tld_to_name["KI"] = "Kiribati";
  tld_to_name["KM"] = "Comoros";
  tld_to_name["KN"] = "Saint Kitts and Nevis";
  tld_to_name["KP"] = "Korea, Democratic People's Republic";
  tld_to_name["KR"] = "Korea, Republic of";
  tld_to_name["KW"] = "Kuwait";
  tld_to_name["KY"] = "Cayman Islands";
  tld_to_name["KZ"] = "Kazakhstan";
  tld_to_name["LA"] = "Lao People's Democratic Republic";
  tld_to_name["LB"] = "Lebanon";
  tld_to_name["LC"] = "Saint Lucia";
  tld_to_name["LI"] = "Liechtenstein";
  tld_to_name["LK"] = "Sri Lanka";
  tld_to_name["LR"] = "Liberia";
  tld_to_name["LS"] = "Lesotho";
  tld_to_name["LT"] = "Lithuania";
  tld_to_name["LU"] = "Luxembourg";
  tld_to_name["LV"] = "Latvia";
  tld_to_name["LY"] = "Libyan Arab Jamahiriya";
  tld_to_name["MA"] = "Morocco";
  tld_to_name["MC"] = "Monaco";
  tld_to_name["MD"] = "Moldova, Republic of";
  tld_to_name["MG"] = "Madagascar";
  tld_to_name["MH"] = "Marshall Islands";
  tld_to_name["MK"] = "Macedonia, The Former Yugoslav Republic of";
  tld_to_name["ML"] = "Mali";
  tld_to_name["MM"] = "Myanmar";
  tld_to_name["MN"] = "Mongolia";
  tld_to_name["MO"] = "Macau";
  tld_to_name["MP"] = "Northern Mariana Islands";
  tld_to_name["MQ"] = "Martinique";
  tld_to_name["MR"] = "Mauritania";
  tld_to_name["MS"] = "Montserrat";
  tld_to_name["MT"] = "Malta";
  tld_to_name["MU"] = "Mauritius";
  tld_to_name["MV"] = "Maldives";
  tld_to_name["MW"] = "Malawi";
  tld_to_name["MX"] = "Mexico";
  tld_to_name["MY"] = "Malaysia";
  tld_to_name["MZ"] = "Mozambique";
  tld_to_name["NA"] = "Namibia";
  tld_to_name["NC"] = "New Caledonia";
  tld_to_name["NE"] = "Niger";
  tld_to_name["NF"] = "Norfolk Island";
  tld_to_name["NG"] = "Nigeria";
  tld_to_name["NI"] = "Nicaragua";
  tld_to_name["NL"] = "Netherlands";
  tld_to_name["NO"] = "Norway";
  tld_to_name["NP"] = "Nepal";
  tld_to_name["NR"] = "Nauru";
  tld_to_name["NU"] = "Niue";
  tld_to_name["NZ"] = "New Zealand";
  tld_to_name["OM"] = "Oman";
  tld_to_name["PA"] = "Panama";
  tld_to_name["PE"] = "Peru";
  tld_to_name["PF"] = "French Polynesia";
  tld_to_name["PG"] = "Papua New Guinea";
  tld_to_name["PH"] = "Philippines";
  tld_to_name["PK"] = "Pakistan";
  tld_to_name["PL"] = "Poland";
  tld_to_name["PM"] = "Saint Pierre and Miquelon";
  tld_to_name["PN"] = "Pitcairn Island";
  tld_to_name["PR"] = "Puerto Rico";
  tld_to_name["PS"] = "Palestinian Territories";
  tld_to_name["PT"] = "Portugal";
  tld_to_name["PW"] = "Palau";
  tld_to_name["PY"] = "Paraguay";
  tld_to_name["QA"] = "Qatar";
  tld_to_name["RE"] = "Reunion Island";
  tld_to_name["RO"] = "Romania";
  tld_to_name["RU"] = "Russian Federation";
  tld_to_name["RW"] = "Rwanda";
  tld_to_name["SA"] = "Saudi Arabia";
  tld_to_name["SB"] = "Solomon Islands";
  tld_to_name["SC"] = "Seychelles";
  tld_to_name["SD"] = "Sudan";
  tld_to_name["SE"] = "Sweden";
  tld_to_name["SG"] = "Singapore";
  tld_to_name["SH"] = "Saint Helena";
  tld_to_name["SI"] = "Slovenia";
  tld_to_name["SJ"] = "Svalbard and Jan Mayen Islands";
  tld_to_name["SK"] = "Slovak Republic";
  tld_to_name["SL"] = "Sierra Leone";
  tld_to_name["SM"] = "San Marino";
  tld_to_name["SN"] = "Senegal";
  tld_to_name["SO"] = "Somalia";
  tld_to_name["SR"] = "Suriname";
  tld_to_name["ST"] = "Sao Tome and Principe";
  tld_to_name["SV"] = "El Salvador";
  tld_to_name["SY"] = "Syrian Arab Republic";
  tld_to_name["SZ"] = "Swaziland";
  tld_to_name["TC"] = "Turks and Caicos Islands";
  tld_to_name["TD"] = "Chad";
  tld_to_name["TF"] = "French Southern Territories";
  tld_to_name["TG"] = "Togo";
  tld_to_name["TH"] = "Thailand";
  tld_to_name["TJ"] = "Tajikistan";
  tld_to_name["TK"] = "Tokelau";
  tld_to_name["TL"] = "Timor-Leste";
  tld_to_name["TM"] = "Turkmenistan";
  tld_to_name["TN"] = "Tunisia";
  tld_to_name["TO"] = "Tonga";
  tld_to_name["TP"] = "East Timor";
  tld_to_name["TR"] = "Turkey";
  tld_to_name["TT"] = "Trinidad and Tobago";
  tld_to_name["TV"] = "Tuvalu";
  tld_to_name["TW"] = "Taiwan";
  tld_to_name["TZ"] = "Tanzania";
  tld_to_name["UA"] = "Ukraine";
  tld_to_name["UG"] = "Uganda";
  tld_to_name["UK"] = "United Kingdom";
  tld_to_name["UM"] = "United States Minor Outlying Islands";
  tld_to_name["US"] = "United States";
  tld_to_name["UY"] = "Uruguay";
  tld_to_name["UZ"] = "Uzbekistan";
  tld_to_name["VA"] = "Holy See (Vatican City State)";
  tld_to_name["VC"] = "Saint Vincent and the Grenadines";
  tld_to_name["VE"] = "Venezuela";
  tld_to_name["VG"] = "Virgin Islands, British";
  tld_to_name["VI"] = "Virgin Islands, U.S.";
  tld_to_name["VN"] = "Vietnam";
  tld_to_name["VU"] = "Vanuatu";
  tld_to_name["WF"] = "Wallis and Futuna Islands";
  tld_to_name["WS"] = "Western Samoa";
  tld_to_name["YE"] = "Yemen";
  tld_to_name["YT"] = "Mayotte";
  tld_to_name["YU"] = "Yugoslavia";
  tld_to_name["ZA"] = "South Africa";
  tld_to_name["ZM"] = "Zambia";
  tld_to_name["ZW"] = "Zimbabwe";

}

FirePhish::~FirePhish()
{
  //Free the comments
  phish_deleteURLData(latest_results);

  //Release the latest results object
  nsMemory::Free(latest_results);

  phish_shutdown();
}


NS_IMETHODIMP FirePhish::CheckURL(const char *url_str, PRInt32 *_retval)
{
    phish_result_t res;

    latest_checked_site = (char*)nsMemory::Clone(url_str, strlen(url_str)+1);
    
    if ((res = phish_checkURL(url_str, latest_results)) != PHISH_SUCCESS)
    {
      *_retval = 0; //Unknown risk level
      return NS_OK;
    }

    //Return according to risk level
    switch (latest_results->risk_level)
    {
      case PHISH_RISK_UNKNOWN:
        *_retval = 0;
        return NS_OK;
      case PHISH_RISK_LOW:
        *_retval = 1;
        return NS_OK;
      case PHISH_RISK_MEDIUM:
        *_retval = 2;
        return NS_OK;
      case PHISH_RISK_HIGH:
        *_retval = 3;
        return NS_OK;    
      default:
        *_retval = 0;
        return NS_OK;
    }

    return NS_OK;
}

/* string GetCountry (); */
NS_IMETHODIMP FirePhish::GetCountry(char **_retval)
{
  string tldname(latest_results->country);
  string fullname = tld_to_name[tldname];
  const char *res = fullname.c_str();
  
  *_retval = (char*)nsMemory::Clone(res, strlen(res) + 1);
  return NS_OK;
}

/* string GetComments (); */
NS_IMETHODIMP FirePhish::GetComments(char **_retval)
{
  if (latest_results->comments)
    *_retval = (char*)nsMemory::Clone(latest_results->comments, strlen(latest_results->comments)+1);
  else
    *_retval = NULL;
  return NS_OK;
}

/* boolean CheckSafeList (in string url_str); */
NS_IMETHODIMP FirePhish::CheckSafeList(const char *url_str, PRBool *_retval)
{
  int reply = 0;
  phish_result_t res; 
  res = phish_checkSafeList(url_str, &reply);

  *_retval = (reply == 1);

  if (*_retval)
    latest_checked_site = (char*)nsMemory::Clone(url_str, strlen(url_str)+1);

  return NS_OK;
}



/* void SetRunningMode (in long mode); */
NS_IMETHODIMP FirePhish::SetRunningMode(PRInt32 mode)
{
  phish_mode_t md = (mode == 0) ? PHISH_OFFLINE_MODE : PHISH_ONLINE_MODE;
  phish_setRunningMode(md);

  return NS_OK;
}

/* void SetSiteQueryURL (in string url); */
NS_IMETHODIMP FirePhish::SetSiteQueryURL(const char *url)
{
  phish_setSiteQueryURL(url);
  return NS_OK;
}

/* void SetCountryQueryURL (in string url); */
NS_IMETHODIMP FirePhish::SetCountryQueryURL(const char *url)
{
  phish_setCountryQueryURL(url);
  return NS_OK;
}

/* void SetReportSiteURL (in string url); */
NS_IMETHODIMP FirePhish::SetReportSiteURL(const char *url)
{
  phish_setReportSiteURL(url);
  return NS_OK;
}

/* void SetRemoteXMLURL (in string url); */
NS_IMETHODIMP FirePhish::SetRemoteXMLURL(const char *url)
{
  phish_setRemoteXMLURL(url);
  return NS_OK;
}

/* void SetLocalXMLFile (in string path); */
NS_IMETHODIMP FirePhish::SetLocalXMLFile(const char *path)
{
  phish_setLocalXMLFile(path);
  return NS_OK;
}

/* void SetSafeListFile (in string path); */
NS_IMETHODIMP FirePhish::SetSafeListFile(const char *path)
{
  phish_setSafeListFile(path);
  return NS_OK;
}


/* long GetrunningMode (); */
NS_IMETHODIMP FirePhish::GetRunningMode(PRInt32 *_retval)
{
    phish_mode_t m;
    phish_runningMode(&m);
    
    int res = 0;
    if (m == PHISH_ONLINE_MODE)
      res = 1;

    *_retval = res;
    return NS_OK;
}

/* string GetsiteQueryURL (); */
NS_IMETHODIMP FirePhish::GetSiteQueryURL(char **_retval)
{
    const char* res;
    phish_siteQueryURL(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}

/* string GetcountryQueryURL (); */
NS_IMETHODIMP FirePhish::GetCountryQueryURL(char **_retval)
{
    const char* res;
    phish_countryQueryURL(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}

/* string GetreportSiteURL (); */
NS_IMETHODIMP FirePhish::GetReportSiteURL(char **_retval)
{
    const char* res;
    phish_reportSiteURL(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}

/* string GetremoteXMLURL (); */
NS_IMETHODIMP FirePhish::GetRemoteXMLURL(char **_retval)
{
    const char* res;
    phish_remoteXMLURL(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}

/* string GetlocalXMLFile (); */
NS_IMETHODIMP FirePhish::GetLocalXMLFile(char **_retval)
{
    const char* res;
    phish_localXMLFile(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}

/* string GetsafeListFile (); */
NS_IMETHODIMP FirePhish::GetSafeListFile(char **_retval)
{
    const char* res;
    phish_safeListFile(&res);
    int len = strlen(res);

    *_retval = (char*)nsMemory::Clone(res, len + 1);
    return NS_OK;
}


/* string GetSafelistAt (in long i); */
NS_IMETHODIMP FirePhish::GetSafelistNext(char **_retval)
{
  const char *url;

  if (m_sl_entry == NULL)
    phish_getSafeListFirst(&m_sl_entry);
  else
    phish_getSafeListNext(m_sl_entry, &m_sl_entry);

  if (m_sl_entry == NULL)
    m_latest_safe_url[0] = '\0';
  else
  {
    phish_getSafeListData(m_sl_entry, &url);

    strcpy(m_latest_safe_url, url);
  }

  *_retval = (char*)nsMemory::Clone(m_latest_safe_url, strlen(m_latest_safe_url)+1);

  return NS_OK;
}


/* void CreateNewSafeList (); */
NS_IMETHODIMP FirePhish::CreateNewSafeList()
{
  phish_newSafeList(&m_safelist);
  return NS_OK;
}

/* void AddToSafeList (in string url); */
NS_IMETHODIMP FirePhish::AddToSafeList(const char *url)
{
  phish_addToSafeList(m_safelist, url);
  return NS_OK;
}

/* void AddToCurrentSafeList (in string url); */
NS_IMETHODIMP FirePhish::AddToCurrentSafeList(const char *url)
{
  phish_addToCurrentSafeList(url);
  return NS_OK;
}

/* void SetSafeList (); */
NS_IMETHODIMP FirePhish::SetSafeList()
{
  phish_setSafeList(m_safelist);
  phish_saveSafeList(); //Also save the safelist file.
  return NS_OK;
}


/* string GetReportingURL (in string url); */
NS_IMETHODIMP FirePhish::GetReportingURL(const char *url, char **_retval)
{
  char *temp;
  phish_getReportingURL(url, &temp);

  *_retval = (char*)nsMemory::Clone(temp, strlen(temp)+1);

  return NS_OK;
}


/* void UpdateXML (); */
NS_IMETHODIMP FirePhish::UpdateXML()
{
  PR_CreateThread(PR_USER_THREAD,
                  (void(*)(void*))phish_downloadDBAsXML,
                  NULL,
                  PR_PRIORITY_NORMAL,
                  PR_LOCAL_THREAD,
                  PR_UNJOINABLE_THREAD,
                  0);

  //phish_downloadDBAsXML();
  return NS_OK;
}


/* void ResetResults (); */
NS_IMETHODIMP FirePhish::ResetResults()
{
  
  //Free the comments
  phish_deleteURLData(latest_results);

  latest_results->comments = NULL;
  latest_results->comments_length = 0;
  latest_results->country[0] = '\0';
  latest_results->ip = -1;
  latest_results->path = -1;
  latest_results->server = -1;
  latest_results->risk_level = PHISH_RISK_UNKNOWN;
  latest_results->domain = -1;
  latest_results->suspicious_host = -1;
  latest_results->user_scheme = -1;

  nsMemory::Free(latest_checked_site);
  latest_checked_site = NULL;


  return NS_OK;
}


/* string GetLatestURL (); */
NS_IMETHODIMP FirePhish::GetLatestURL(char **_retval)
{
  if (latest_checked_site)
    *_retval = (char*)nsMemory::Clone(latest_checked_site, 
                strlen(latest_checked_site) + 1);
  else
    *_retval = NULL;
  return NS_OK;
}


/* long GetResultServer (); */
NS_IMETHODIMP FirePhish::GetResultServer(PRInt32 *_retval)
{
  *_retval = latest_results->server;
  return NS_OK;
}

/* long GetResultIP (); */
NS_IMETHODIMP FirePhish::GetResultIP(PRInt32 *_retval)
{
  *_retval = latest_results->ip;
  return NS_OK;
}

/* long GetResultPath (); */
NS_IMETHODIMP FirePhish::GetResultPath(PRInt32 *_retval)
{
  *_retval = latest_results->path;
  return NS_OK;
}

/* long GetResultDomain (); */
NS_IMETHODIMP FirePhish::GetResultDomain(PRInt32 *_retval)
{
  *_retval = latest_results->domain;
  return NS_OK;
}

/* long GetResultUserScheme (); */
NS_IMETHODIMP FirePhish::GetResultUserScheme(PRInt32 *_retval)
{
  *_retval = latest_results->user_scheme;
  return NS_OK;
}

/* long GetResultSuspiciousHost (); */
NS_IMETHODIMP FirePhish::GetResultSuspiciousHost(PRInt32 *_retval)
{
  *_retval = latest_results->suspicious_host;
  return NS_OK;
}

/* void CheckCountry (in string url); */
NS_IMETHODIMP FirePhish::CheckCountry(const char *url)
{
  phish_checkCountry(url, latest_results);
  return NS_OK;
}
--- trunk/client/firephish/xpcom/FirePhish.h #1:2

#ifndef __FIREPHISH_H
#define __FIREPHISH_H

#include "IFirePhish.h"
#include <phish.h>
#include <map>

#define FIREPHISH_CONTRACTID "@opdb.berlios.de/FirePhish;1"
#define FIREPHISH_CLASSNAME "FirePhish XPCOM Interface"
#define FIREPHISH_CID  { 0xf11b82bf, 0x8ac3, 0x11da,	{ 0x95, 0x59, 0x0, 0xe0, 0x81, 0x61, 0x16, 0x5f } }

using std::map;
using std::string;

/* Header file */
class FirePhish : public IFirePhish
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_IFIREPHISH

  FirePhish();
  virtual ~FirePhish();
private:
  phish_safelist_t* m_safelist;
  phish_safe_list_entry_t *m_sl_entry;
  phish_url_data_t *latest_results;
  char m_latest_safe_url[256];
  char *latest_checked_site;
  map<string, string> tld_to_name;
};








#endif /* ____FIREPHISH_H */

--- trunk/client/firephish/xpcom/FirePhishModule.cpp #1:2

#include "nsIGenericFactory.h"
#include "FirePhish.h"

NS_GENERIC_FACTORY_CONSTRUCTOR(FirePhish)

static nsModuleComponentInfo components[] =
{
    {
       FIREPHISH_CLASSNAME, 
       FIREPHISH_CID,
       FIREPHISH_CONTRACTID,
       FirePhishConstructor,
    }
};

NS_IMPL_NSGETMODULE("FirePhishModule", components)
--- trunk/client/firephish/xpcom/IFirePhish.h #1:2

/*
 * DO NOT EDIT.  THIS FILE IS GENERATED FROM IFirePhish.idl
 */

#ifndef __gen_IFirePhish_h__
#define __gen_IFirePhish_h__


#ifndef __gen_nsISupports_h__
#include "nsISupports.h"
#endif

#ifndef __gen_nsIMemory_h__
#include "nsIMemory.h"
#endif

/* For IDL files that don't want to include root IDL files. */
#ifndef NS_NO_VTABLE
#define NS_NO_VTABLE
#endif

/* starting interface:    IFirePhish */
#define IFIREPHISH_IID_STR "05d43694-8abf-11da-9559-00e08161165f"

#define IFIREPHISH_IID \
  {0x05d43694, 0x8abf, 0x11da, \
    { 0x95, 0x59, 0x00, 0xe0, 0x81, 0x61, 0x16, 0x5f }}

class NS_NO_VTABLE IFirePhish : public nsISupports {
 public: 

  NS_DEFINE_STATIC_IID_ACCESSOR(IFIREPHISH_IID)

  /** Returns the risk level: 
   *  0 - unknown
   *  1 - low
   *  2 - medium
   *  3 - high
   */
  /* long CheckURL (in string url_str); */
  NS_IMETHOD CheckURL(const char *url_str, PRInt32 *_retval) = 0;

  /** Returns the full name of the country */
  /* string GetCountry (); */
  NS_IMETHOD GetCountry(char **_retval) = 0;

  /** Returns the comments about the (phishy) site */
  /* string GetComments (); */
  NS_IMETHOD GetComments(char **_retval) = 0;

  /** Methods for returning latest results information */
  /* long GetResultServer (); */
  NS_IMETHOD GetResultServer(PRInt32 *_retval) = 0;

  /* long GetResultIP (); */
  NS_IMETHOD GetResultIP(PRInt32 *_retval) = 0;

  /* long GetResultPath (); */
  NS_IMETHOD GetResultPath(PRInt32 *_retval) = 0;

  /* long GetResultDomain (); */
  NS_IMETHOD GetResultDomain(PRInt32 *_retval) = 0;

  /* long GetResultUserScheme (); */
  NS_IMETHOD GetResultUserScheme(PRInt32 *_retval) = 0;

  /* long GetResultSuspiciousHost (); */
  NS_IMETHOD GetResultSuspiciousHost(PRInt32 *_retval) = 0;

  /* boolean CheckSafeList (in string url_str); */
  NS_IMETHOD CheckSafeList(const char *url_str, PRBool *_retval) = 0;

  /** Configuration handling */
  /* void SetRunningMode (in long mode); */
  NS_IMETHOD SetRunningMode(PRInt32 mode) = 0;

  /* void SetSiteQueryURL (in string url); */
  NS_IMETHOD SetSiteQueryURL(const char *url) = 0;

  /* void SetCountryQueryURL (in string url); */
  NS_IMETHOD SetCountryQueryURL(const char *url) = 0;

  /* void SetReportSiteURL (in string url); */
  NS_IMETHOD SetReportSiteURL(const char *url) = 0;

  /* void SetRemoteXMLURL (in string url); */
  NS_IMETHOD SetRemoteXMLURL(const char *url) = 0;

  /* void SetLocalXMLFile (in string path); */
  NS_IMETHOD SetLocalXMLFile(const char *path) = 0;

  /* void SetSafeListFile (in string path); */
  NS_IMETHOD SetSafeListFile(const char *path) = 0;

  /* long GetRunningMode (); */
  NS_IMETHOD GetRunningMode(PRInt32 *_retval) = 0;

  /* string GetSiteQueryURL (); */
  NS_IMETHOD GetSiteQueryURL(char **_retval) = 0;

  /* string GetCountryQueryURL (); */
  NS_IMETHOD GetCountryQueryURL(char **_retval) = 0;

  /* string GetReportSiteURL (); */
  NS_IMETHOD GetReportSiteURL(char **_retval) = 0;

  /* string GetRemoteXMLURL (); */
  NS_IMETHOD GetRemoteXMLURL(char **_retval) = 0;

  /* string GetLocalXMLFile (); */
  NS_IMETHOD GetLocalXMLFile(char **_retval) = 0;

  /* string GetSafeListFile (); */
  NS_IMETHOD GetSafeListFile(char **_retval) = 0;

  /** Returns the URL in the next element of the safe list.
   *  If there's no next item, "" is returned.
   */
  /* string GetSafelistNext (); */
  NS_IMETHOD GetSafelistNext(char **_retval) = 0;

  /** Given a URL of a site to report, return a URL that the client should go
   *  to.
   */
  /* string GetReportingURL (in string url); */
  NS_IMETHOD GetReportingURL(const char *url, char **_retval) = 0;

  /** Make m_safelist point to a newly created safelist. */
  /* void CreateNewSafeList (); */
  NS_IMETHOD CreateNewSafeList(void) = 0;

  /** Adds 'url' to the SafeList pointed to by m_safelist */
  /* void AddToSafeList (in string url); */
  NS_IMETHOD AddToSafeList(const char *url) = 0;

  /** Adds 'url' to the current Safe List in use. */
  /* void AddToCurrentSafeList (in string url); */
  NS_IMETHOD AddToCurrentSafeList(const char *url) = 0;

  /** Makes m_safelist the new safelist. */
  /* void SetSafeList (); */
  NS_IMETHOD SetSafeList(void) = 0;

  /** Download the remote XML file (if it was changed since last update) */
  /* void UpdateXML (); */
  NS_IMETHOD UpdateXML(void) = 0;

  /** Restest the 'latest_results' member object */
  /* void ResetResults (); */
  NS_IMETHOD ResetResults(void) = 0;

  /** Return the latest URL which was checked */
  /* string GetLatestURL (); */
  NS_IMETHOD GetLatestURL(char **_retval) = 0;

  /** Initializes libphish */
  /* void InitPhish (in string agent, in string cver); */
  NS_IMETHOD InitPhish(const char *agent, const char *cver) = 0;

  /** Check only the country of a site */
  /* void CheckCountry (in string url); */
  NS_IMETHOD CheckCountry(const char *url) = 0;

};

/* Use this macro when declaring classes that implement this interface. */
#define NS_DECL_IFIREPHISH \
  NS_IMETHOD CheckURL(const char *url_str, PRInt32 *_retval); \
  NS_IMETHOD GetCountry(char **_retval); \
  NS_IMETHOD GetComments(char **_retval); \
  NS_IMETHOD GetResultServer(PRInt32 *_retval); \
  NS_IMETHOD GetResultIP(PRInt32 *_retval); \
  NS_IMETHOD GetResultPath(PRInt32 *_retval); \
  NS_IMETHOD GetResultDomain(PRInt32 *_retval); \
  NS_IMETHOD GetResultUserScheme(PRInt32 *_retval); \
  NS_IMETHOD GetResultSuspiciousHost(PRInt32 *_retval); \
  NS_IMETHOD CheckSafeList(const char *url_str, PRBool *_retval); \
  NS_IMETHOD SetRunningMode(PRInt32 mode); \
  NS_IMETHOD SetSiteQueryURL(const char *url); \
  NS_IMETHOD SetCountryQueryURL(const char *url); \
  NS_IMETHOD SetReportSiteURL(const char *url); \
  NS_IMETHOD SetRemoteXMLURL(const char *url); \
  NS_IMETHOD SetLocalXMLFile(const char *path); \
  NS_IMETHOD SetSafeListFile(const char *path); \
  NS_IMETHOD GetRunningMode(PRInt32 *_retval); \
  NS_IMETHOD GetSiteQueryURL(char **_retval); \
  NS_IMETHOD GetCountryQueryURL(char **_retval); \
  NS_IMETHOD GetReportSiteURL(char **_retval); \
  NS_IMETHOD GetRemoteXMLURL(char **_retval); \
  NS_IMETHOD GetLocalXMLFile(char **_retval); \
  NS_IMETHOD GetSafeListFile(char **_retval); \
  NS_IMETHOD GetSafelistNext(char **_retval); \
  NS_IMETHOD GetReportingURL(const char *url, char **_retval); \
  NS_IMETHOD CreateNewSafeList(void); \
  NS_IMETHOD AddToSafeList(const char *url); \
  NS_IMETHOD AddToCurrentSafeList(const char *url); \
  NS_IMETHOD SetSafeList(void); \
  NS_IMETHOD UpdateXML(void); \
  NS_IMETHOD ResetResults(void); \
  NS_IMETHOD GetLatestURL(char **_retval); \
  NS_IMETHOD InitPhish(const char *agent, const char *cver); \
  NS_IMETHOD CheckCountry(const char *url); 

/* Use this macro to declare functions that forward the behavior of this interface to another object. */
#define NS_FORWARD_IFIREPHISH(_to) \
  NS_IMETHOD CheckURL(const char *url_str, PRInt32 *_retval) { return _to CheckURL(url_str, _retval); } \
  NS_IMETHOD GetCountry(char **_retval) { return _to GetCountry(_retval); } \
  NS_IMETHOD GetComments(char **_retval) { return _to GetComments(_retval); } \
  NS_IMETHOD GetResultServer(PRInt32 *_retval) { return _to GetResultServer(_retval); } \
  NS_IMETHOD GetResultIP(PRInt32 *_retval) { return _to GetResultIP(_retval); } \
  NS_IMETHOD GetResultPath(PRInt32 *_retval) { return _to GetResultPath(_retval); } \
  NS_IMETHOD GetResultDomain(PRInt32 *_retval) { return _to GetResultDomain(_retval); } \
  NS_IMETHOD GetResultUserScheme(PRInt32 *_retval) { return _to GetResultUserScheme(_retval); } \
  NS_IMETHOD GetResultSuspiciousHost(PRInt32 *_retval) { return _to GetResultSuspiciousHost(_retval); } \
  NS_IMETHOD CheckSafeList(const char *url_str, PRBool *_retval) { return _to CheckSafeList(url_str, _retval); } \
  NS_IMETHOD SetRunningMode(PRInt32 mode) { return _to SetRunningMode(mode); } \
  NS_IMETHOD SetSiteQueryURL(const char *url) { return _to SetSiteQueryURL(url); } \
  NS_IMETHOD SetCountryQueryURL(const char *url) { return _to SetCountryQueryURL(url); } \
  NS_IMETHOD SetReportSiteURL(const char *url) { return _to SetReportSiteURL(url); } \
  NS_IMETHOD SetRemoteXMLURL(const char *url) { return _to SetRemoteXMLURL(url); } \
  NS_IMETHOD SetLocalXMLFile(const char *path) { return _to SetLocalXMLFile(path); } \
  NS_IMETHOD SetSafeListFile(const char *path) { return _to SetSafeListFile(path); } \
  NS_IMETHOD GetRunningMode(PRInt32 *_retval) { return _to GetRunningMode(_retval); } \
  NS_IMETHOD GetSiteQueryURL(char **_retval) { return _to GetSiteQueryURL(_retval); } \
  NS_IMETHOD GetCountryQueryURL(char **_retval) { return _to GetCountryQueryURL(_retval); } \
  NS_IMETHOD GetReportSiteURL(char **_retval) { return _to GetReportSiteURL(_retval); } \
  NS_IMETHOD GetRemoteXMLURL(char **_retval) { return _to GetRemoteXMLURL(_retval); } \
  NS_IMETHOD GetLocalXMLFile(char **_retval) { return _to GetLocalXMLFile(_retval); } \
  NS_IMETHOD GetSafeListFile(char **_retval) { return _to GetSafeListFile(_retval); } \
  NS_IMETHOD GetSafelistNext(char **_retval) { return _to GetSafelistNext(_retval); } \
  NS_IMETHOD GetReportingURL(const char *url, char **_retval) { return _to GetReportingURL(url, _retval); } \
  NS_IMETHOD CreateNewSafeList(void) { return _to CreateNewSafeList(); } \
  NS_IMETHOD AddToSafeList(const char *url) { return _to AddToSafeList(url); } \
  NS_IMETHOD AddToCurrentSafeList(const char *url) { return _to AddToCurrentSafeList(url); } \
  NS_IMETHOD SetSafeList(void) { return _to SetSafeList(); } \
  NS_IMETHOD UpdateXML(void) { return _to UpdateXML(); } \
  NS_IMETHOD ResetResults(void) { return _to ResetResults(); } \
  NS_IMETHOD GetLatestURL(char **_retval) { return _to GetLatestURL(_retval); } \
  NS_IMETHOD InitPhish(const char *agent, const char *cver) { return _to InitPhish(agent, cver); } \
  NS_IMETHOD CheckCountry(const char *url) { return _to CheckCountry(url); } 

/* Use this macro to declare functions that forward the behavior of this interface to another object in a safe way. */
#define NS_FORWARD_SAFE_IFIREPHISH(_to) \
  NS_IMETHOD CheckURL(const char *url_str, PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->CheckURL(url_str, _retval); } \
  NS_IMETHOD GetCountry(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetCountry(_retval); } \
  NS_IMETHOD GetComments(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetComments(_retval); } \
  NS_IMETHOD GetResultServer(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultServer(_retval); } \
  NS_IMETHOD GetResultIP(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultIP(_retval); } \
  NS_IMETHOD GetResultPath(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultPath(_retval); } \
  NS_IMETHOD GetResultDomain(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultDomain(_retval); } \
  NS_IMETHOD GetResultUserScheme(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultUserScheme(_retval); } \
  NS_IMETHOD GetResultSuspiciousHost(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetResultSuspiciousHost(_retval); } \
  NS_IMETHOD CheckSafeList(const char *url_str, PRBool *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->CheckSafeList(url_str, _retval); } \
  NS_IMETHOD SetRunningMode(PRInt32 mode) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetRunningMode(mode); } \
  NS_IMETHOD SetSiteQueryURL(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetSiteQueryURL(url); } \
  NS_IMETHOD SetCountryQueryURL(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetCountryQueryURL(url); } \
  NS_IMETHOD SetReportSiteURL(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetReportSiteURL(url); } \
  NS_IMETHOD SetRemoteXMLURL(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetRemoteXMLURL(url); } \
  NS_IMETHOD SetLocalXMLFile(const char *path) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetLocalXMLFile(path); } \
  NS_IMETHOD SetSafeListFile(const char *path) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetSafeListFile(path); } \
  NS_IMETHOD GetRunningMode(PRInt32 *_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetRunningMode(_retval); } \
  NS_IMETHOD GetSiteQueryURL(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetSiteQueryURL(_retval); } \
  NS_IMETHOD GetCountryQueryURL(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetCountryQueryURL(_retval); } \
  NS_IMETHOD GetReportSiteURL(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetReportSiteURL(_retval); } \
  NS_IMETHOD GetRemoteXMLURL(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetRemoteXMLURL(_retval); } \
  NS_IMETHOD GetLocalXMLFile(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetLocalXMLFile(_retval); } \
  NS_IMETHOD GetSafeListFile(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetSafeListFile(_retval); } \
  NS_IMETHOD GetSafelistNext(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetSafelistNext(_retval); } \
  NS_IMETHOD GetReportingURL(const char *url, char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetReportingURL(url, _retval); } \
  NS_IMETHOD CreateNewSafeList(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->CreateNewSafeList(); } \
  NS_IMETHOD AddToSafeList(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->AddToSafeList(url); } \
  NS_IMETHOD AddToCurrentSafeList(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->AddToCurrentSafeList(url); } \
  NS_IMETHOD SetSafeList(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->SetSafeList(); } \
  NS_IMETHOD UpdateXML(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->UpdateXML(); } \
  NS_IMETHOD ResetResults(void) { return !_to ? NS_ERROR_NULL_POINTER : _to->ResetResults(); } \
  NS_IMETHOD GetLatestURL(char **_retval) { return !_to ? NS_ERROR_NULL_POINTER : _to->GetLatestURL(_retval); } \
  NS_IMETHOD InitPhish(const char *agent, const char *cver) { return !_to ? NS_ERROR_NULL_POINTER : _to->InitPhish(agent, cver); } \
  NS_IMETHOD CheckCountry(const char *url) { return !_to ? NS_ERROR_NULL_POINTER : _to->CheckCountry(url); } 

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class _MYCLASS_ : public IFirePhish
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_IFIREPHISH

  _MYCLASS_();

private:
  ~_MYCLASS_();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS1(_MYCLASS_, IFirePhish)

_MYCLASS_::_MYCLASS_()
{
  /* member initializers and constructor code */
}

_MYCLASS_::~_MYCLASS_()
{
  /* destructor code */
}

/* long CheckURL (in string url_str); */
NS_IMETHODIMP _MYCLASS_::CheckURL(const char *url_str, PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetCountry (); */
NS_IMETHODIMP _MYCLASS_::GetCountry(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetComments (); */
NS_IMETHODIMP _MYCLASS_::GetComments(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultServer (); */
NS_IMETHODIMP _MYCLASS_::GetResultServer(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultIP (); */
NS_IMETHODIMP _MYCLASS_::GetResultIP(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultPath (); */
NS_IMETHODIMP _MYCLASS_::GetResultPath(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultDomain (); */
NS_IMETHODIMP _MYCLASS_::GetResultDomain(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultUserScheme (); */
NS_IMETHODIMP _MYCLASS_::GetResultUserScheme(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetResultSuspiciousHost (); */
NS_IMETHODIMP _MYCLASS_::GetResultSuspiciousHost(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* boolean CheckSafeList (in string url_str); */
NS_IMETHODIMP _MYCLASS_::CheckSafeList(const char *url_str, PRBool *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetRunningMode (in long mode); */
NS_IMETHODIMP _MYCLASS_::SetRunningMode(PRInt32 mode)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetSiteQueryURL (in string url); */
NS_IMETHODIMP _MYCLASS_::SetSiteQueryURL(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetCountryQueryURL (in string url); */
NS_IMETHODIMP _MYCLASS_::SetCountryQueryURL(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetReportSiteURL (in string url); */
NS_IMETHODIMP _MYCLASS_::SetReportSiteURL(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetRemoteXMLURL (in string url); */
NS_IMETHODIMP _MYCLASS_::SetRemoteXMLURL(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetLocalXMLFile (in string path); */
NS_IMETHODIMP _MYCLASS_::SetLocalXMLFile(const char *path)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetSafeListFile (in string path); */
NS_IMETHODIMP _MYCLASS_::SetSafeListFile(const char *path)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long GetRunningMode (); */
NS_IMETHODIMP _MYCLASS_::GetRunningMode(PRInt32 *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetSiteQueryURL (); */
NS_IMETHODIMP _MYCLASS_::GetSiteQueryURL(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetCountryQueryURL (); */
NS_IMETHODIMP _MYCLASS_::GetCountryQueryURL(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetReportSiteURL (); */
NS_IMETHODIMP _MYCLASS_::GetReportSiteURL(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetRemoteXMLURL (); */
NS_IMETHODIMP _MYCLASS_::GetRemoteXMLURL(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetLocalXMLFile (); */
NS_IMETHODIMP _MYCLASS_::GetLocalXMLFile(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetSafeListFile (); */
NS_IMETHODIMP _MYCLASS_::GetSafeListFile(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetSafelistNext (); */
NS_IMETHODIMP _MYCLASS_::GetSafelistNext(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetReportingURL (in string url); */
NS_IMETHODIMP _MYCLASS_::GetReportingURL(const char *url, char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void CreateNewSafeList (); */
NS_IMETHODIMP _MYCLASS_::CreateNewSafeList()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void AddToSafeList (in string url); */
NS_IMETHODIMP _MYCLASS_::AddToSafeList(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void AddToCurrentSafeList (in string url); */
NS_IMETHODIMP _MYCLASS_::AddToCurrentSafeList(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void SetSafeList (); */
NS_IMETHODIMP _MYCLASS_::SetSafeList()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void UpdateXML (); */
NS_IMETHODIMP _MYCLASS_::UpdateXML()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void ResetResults (); */
NS_IMETHODIMP _MYCLASS_::ResetResults()
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* string GetLatestURL (); */
NS_IMETHODIMP _MYCLASS_::GetLatestURL(char **_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void InitPhish (in string agent, in string cver); */
NS_IMETHODIMP _MYCLASS_::InitPhish(const char *agent, const char *cver)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void CheckCountry (in string url); */
NS_IMETHODIMP _MYCLASS_::CheckCountry(const char *url)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif


#endif /* __gen_IFirePhish_h__ */
--- trunk/client/firephish/xpcom/IFirePhish.idl #1:2

#include "nsISupports.idl"
#include "nsIMemory.idl"
#include <map>

[scriptable, uuid(05d43694-8abf-11da-9559-00e08161165f)]
interface IFirePhish : nsISupports
{

  /** Returns the risk level: 
   *  0 - unknown
   *  1 - low
   *  2 - medium
   *  3 - high
   */
  long CheckURL(in string url_str);

  /** Returns the full name of the country */
  string GetCountry();

  /** Returns the comments about the (phishy) site */
  string GetComments();

  /** Methods for returning latest results information */
  long GetResultServer();
  long GetResultIP();
  long GetResultPath();
  long GetResultDomain();
  long GetResultUserScheme();
  long GetResultSuspiciousHost();

  boolean CheckSafeList(in string url_str);

  /** Configuration handling */
  void SetRunningMode(in long mode); //1 - Online, 0 - Offline
  void SetSiteQueryURL(in string url);
  void SetCountryQueryURL(in string url);
  void SetReportSiteURL(in string url);
  void SetRemoteXMLURL(in string url);
  void SetLocalXMLFile(in string path);
  void SetSafeListFile(in string path);
  long GetRunningMode();     //1 - Online, 0 - Offline
  string GetSiteQueryURL();
  string GetCountryQueryURL();
  string GetReportSiteURL();
  string GetRemoteXMLURL();
  string GetLocalXMLFile();
  string GetSafeListFile();


  /** Returns the URL in the next element of the safe list.
   *  If there's no next item, "" is returned.
   */
  string GetSafelistNext();

  /** Given a URL of a site to report, return a URL that the client should go
   *  to.
   */
  string GetReportingURL(in string url);

  /** Make m_safelist point to a newly created safelist. */
  void CreateNewSafeList();

  /** Adds 'url' to the SafeList pointed to by m_safelist */
  void AddToSafeList(in string url);

  /** Adds 'url' to the current Safe List in use. */
  void AddToCurrentSafeList(in string url);

  /** Makes m_safelist the new safelist. */
  void SetSafeList();

  /** Download the remote XML file (if it was changed since last update) */
  void UpdateXML();

  /** Restest the 'latest_results' member object */
  void ResetResults();

  /** Return the latest URL which was checked */
  string GetLatestURL();

  /** Initializes libphish */
  void InitPhish(in string agent, in string cver);

  /** Check only the country of a site */
  void CheckCountry(in string url);
};
--- trunk/client/firephish/xpcom/Makefile #1:2

CXX   = c++
CPPFLAGS +=     -fno-rtti              \
		-fno-exceptions \
		-shared
 
# Change this to point at your Gecko SDK directory. 
GECKO_SDK_PATH = /usr/lib/mozilla-firefox-1.5.0.1
 
# GCC only define which allows us to not have to #include mozilla-config 
# in every .cpp file.  If your not using GCC remove this line and add 
# #include "mozilla-config.h" to each of your .cpp files. 
GECKO_CONFIG_INCLUDE = -include mozilla-config.h 
 
GECKO_DEFINES  = -DXPCOM_GLUE
 
GECKO_INCLUDES = -I /usr/include/mozilla-firefox-1.5.0.1/nspr -I /usr/include/mozilla-firefox-1.5.0.1
#GECKO_INCLUDES = -I $(GECKO_SDK_PATH)/include 
 
GECKO_LDFLAGS =  -L $(GECKO_SDK_PATH) \
                 -lnspr4      \
                 -lplds4

FILES = FirePhish.cpp FirePhishModule.cpp -Wl,-Bstatic -lphish -Wl,-Bdynamic

TARGET = FirePhish.so

build: 
	$(CXX) -g -Wall -Os -o $(TARGET) $(GECKO_CONFIG_INCLUDE) $(GECKO_DEFINES) $(GECKO_INCLUDES) $(GECKO_LDFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(FILES)
	chmod +x $(TARGET)
 
clean: 
	rm $(TARGET)
--- trunk/client/karpion/AUTHORS #1:2

Meni Livne <livne at kde.org>
--- trunk/client/karpion/COPYING #1:2

		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
--- trunk/client/karpion/INSTALL #1:2

Basic Installation
==================

   These are generic installation instructions.

   The `configure' shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a `Makefile' in each directory of the package.
It may also create one or more `.h' files containing system-dependent
definitions.  Finally, it creates a shell script `config.status' that
you can run in the future to recreate the current configuration, a file
`config.cache' that saves the results of its tests to speed up
reconfiguring, and a file `config.log' containing compiler output
(useful mainly for debugging `configure').

   If you need to do unusual things to compile the package, please try
to figure out how `configure' could check whether to do them, and mail
diffs or instructions to the address given in the `README' so they can
be considered for the next release.  If at some point `config.cache'
contains results you don't want to keep, you may remove or edit it.

   The file `configure.in' is used to create `configure' by a program
called `autoconf'.  You only need `configure.in' if you want to change
it or regenerate `configure' using a newer version of `autoconf'.

The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `./configure' to configure the package for your system.  If you're
     using `csh' on an old version of System V, you might need to type
     `sh ./configure' instead to prevent `csh' from trying to execute
     `configure' itself.

     Running `configure' takes a while.  While running, it prints some
     messages telling which features it is checking for.

  2. Type `make' to compile the package.

  3. Type `make install' to install the programs and any data files and
     documentation.

  4. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  

Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  You can give `configure'
initial values for variables by setting them in the environment.  Using
a Bourne-compatible shell, you can do that on the command line like
this:
     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure

Or on systems that have the `env' program, you can do it like this:
     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure

Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you must use a version of `make' that
supports the `VPATH' variable, such as GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.

   If you have to use a `make' that does not supports the `VPATH'
variable, you have to compile the package for one architecture at a time
in the source code directory.  After you have installed the package for
one architecture, use `make distclean' before reconfiguring for another
architecture.

Installation Names
==================

   By default, `make install' will install the package's files in
`/usr/local/bin', `/usr/local/man', etc.  You can specify an
installation prefix other than `/usr/local' by giving `configure' the
option `--prefix=PATH'.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
give `configure' the option `--exec-prefix=PATH', the package will use
PATH as the prefix for installing programs and libraries.
Documentation and other data files will still use the regular prefix.

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.

Optional Features
=================

   Some packages pay attention to `--enable-FEATURE' options to
`configure', where FEATURE indicates an optional part of the package.
They may also pay attention to `--with-PACKAGE' options, where PACKAGE
is something like `gnu-as' or `x' (for the X Window System).  The
`README' should mention any `--enable-' and `--with-' options that the
package recognizes.

   For packages that use the X Window System, `configure' can usually
find the X include and library files automatically, but if it doesn't,
you can use the `configure' options `--x-includes=DIR' and
`--x-libraries=DIR' to specify their locations.

Specifying the System Type
==========================

   There may be some features `configure' can not figure out
automatically, but needs to determine by the type of host the package
will run on.  Usually `configure' can figure that out, but if it prints
a message saying it can not guess the host type, give it the
`--host=TYPE' option.  TYPE can either be a short name for the system
type, such as `sun4', or a canonical name with three fields:
     CPU-COMPANY-SYSTEM

See the file `config.sub' for the possible values of each field.  If
`config.sub' isn't included in this package, then this package doesn't
need to know the host type.

   If you are building compiler tools for cross-compiling, you can also
use the `--target=TYPE' option to select the type of system they will
produce code for and the `--build=TYPE' option to select the type of
system on which you are compiling the package.

Sharing Defaults
================

   If you want to set default values for `configure' scripts to share,
you can create a site shell script called `config.site' that gives
default values for variables like `CC', `cache_file', and `prefix'.
`configure' looks for `PREFIX/share/config.site' if it exists, then
`PREFIX/etc/config.site' if it exists.  Or, you can set the
`CONFIG_SITE' environment variable to the location of the site script.
A warning: not all `configure' scripts look for a site script.

Operation Controls
==================

   `configure' recognizes the following options to control how it
operates.

`--cache-file=FILE'
     Use and save the results of the tests in FILE instead of
     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
     debugging `configure'.

`--help'
     Print a summary of the options to `configure', and exit.

`--quiet'
`--silent'
`-q'
     Do not print messages saying which checks are being made.

`--srcdir=DIR'
     Look for the package's source code in directory DIR.  Usually
     `configure' can determine that directory automatically.

`--version'
     Print the version of Autoconf used to generate the `configure'
     script, and exit.

`configure' also accepts some other, not widely useful, options.

--- trunk/client/karpion/Makefile.am #1:2

SUBDIRS = $(TOPSUBDIRS)

$(top_srcdir)/configure.in: configure.in.in $(top_srcdir)/subdirs
	cd $(top_srcdir) && $(MAKE) -f admin/Makefile.common configure.in ;

$(top_srcdir)/subdirs:
	cd $(top_srcdir) && $(MAKE) -f admin/Makefile.common subdirs

$(top_srcdir)/acinclude.m4: $(top_srcdir)/admin/acinclude.m4.in $(top_srcdir)/admin/libtool.m4.in
	@cd $(top_srcdir) && cat admin/acinclude.m4.in admin/libtool.m4.in > acinclude.m4

MAINTAINERCLEANFILES = subdirs configure.in acinclude.m4 configure.files 

package-messages:
	cd $(top_srcdir) && $(MAKE) -f admin/Makefile.common package-messages
	$(MAKE) -C po merge

EXTRA_DIST = admin COPYING configure.in.in

dist-hook:
	cd $(top_distdir) && perl admin/am_edit -padmin
	cd $(top_distdir) && $(MAKE) -f admin/Makefile.common subdirs
--- trunk/client/karpion/Makefile.cvs #1:2

all: 
	@echo "This Makefile is only for the CVS repository"
	@echo "This will be deleted before making the distribution"
	@echo ""
	$(MAKE) -f admin/Makefile.common cvs

dist:
	$(MAKE) -f admin/Makefile.common dist

.SILENT:
--- trunk/client/karpion/README #1:2

ABOUT KONQUEROR ANTI-PHISHING TOOLBAR (KARPION)

The Anti-Phishing toolbar is an extension for the Konqueror browser that helps
protect against phishing attacks.
See http://opdb.berlios.de/doc/karpion-manual.html for a short guide to the
Konqueror Anti-Phishing Toolbar.


INSTALLATION

The file 'INSTALL' contains generic installation instructions.
The Anti-Phishing toolbar requires libphish, a library to interact with the
Open Phishing Database. libphish can be obtained at the OPDB website,
at http://opdb.berlios.de/.

Installation is basically done as usual:
./configure
make
make install

with the latter command being executed as root.


ABOUT OPDB

The Konqueror Anti-Phishing toolbar is part of the Open Phishing Database
project, an effort to create and maintain and open database of phishing sites
in order to protect users, in addition to providing extensions to browsers
that utilise the database.


THE ICON

The anti-phishing icon is based on the babelfish icon from Everaldo's crystal
icon set for KDE: http://www.kde-look.org/content/show.php?content=8341


MORE INFORMATION

See the OPDB website at http://opdb.berlios.de/ for general information about
the Open Phishing Database, browser extensions, and contact information and
mailing lists.


--- trunk/client/karpion/config.h.in #1:2

/* config.h.in.  Generated from configure.in by autoheader.  */

/* Define if you have the CoreAudio API */
#undef HAVE_COREAUDIO

/* Define to 1 if you have the <crt_externs.h> header file. */
#undef HAVE_CRT_EXTERNS_H

/* Defines if your system has the crypt function */
#undef HAVE_CRYPT

/* Define to 1 if you have the <dlfcn.h> header file. */
#undef HAVE_DLFCN_H

/* Define to 1 if you have the <inttypes.h> header file. */
#undef HAVE_INTTYPES_H

/* Define if you have libjpeg */
#undef HAVE_LIBJPEG

/* Define to 1 if you have the `phish' library (-lphish). */
#undef HAVE_LIBPHISH

/* Define if you have libpng */
#undef HAVE_LIBPNG

/* Define if you have a working libpthread (will enable threaded code) */
#undef HAVE_LIBPTHREAD

/* Define if you have libz */
#undef HAVE_LIBZ

/* Define to 1 if you have the <memory.h> header file. */
#undef HAVE_MEMORY_H

/* Define if your system needs _NSGetEnviron to set up the environment */
#undef HAVE_NSGETENVIRON

/* Define if you have the res_init function */
#undef HAVE_RES_INIT

/* Define if you have a STL implementation by SGI */
#undef HAVE_SGI_STL

/* Define to 1 if you have the `snprintf' function. */
#undef HAVE_SNPRINTF

/* Define to 1 if you have the <stdint.h> header file. */
#undef HAVE_STDINT_H

/* Define to 1 if you have the <stdlib.h> header file. */
#undef HAVE_STDLIB_H

/* Define to 1 if you have the <strings.h> header file. */
#undef HAVE_STRINGS_H

/* Define to 1 if you have the <string.h> header file. */
#undef HAVE_STRING_H

/* Define if you have strlcat */
#undef HAVE_STRLCAT

/* Define if you have the strlcat prototype */
#undef HAVE_STRLCAT_PROTO

/* Define if you have strlcpy */
#undef HAVE_STRLCPY

/* Define if you have the strlcpy prototype */
#undef HAVE_STRLCPY_PROTO

/* Define to 1 if you have the <sys/stat.h> header file. */
#undef HAVE_SYS_STAT_H

/* Define to 1 if you have the <sys/types.h> header file. */
#undef HAVE_SYS_TYPES_H

/* Define to 1 if you have the <unistd.h> header file. */
#undef HAVE_UNISTD_H

/* Define to 1 if you have the `vsnprintf' function. */
#undef HAVE_VSNPRINTF

/* Suffix for lib directories */
#undef KDELIBSUFF

/* Define a safe value for MAXPATHLEN */
#undef KDEMAXPATHLEN

/* Name of package */
#undef PACKAGE

/* Define to the address where bug reports for this package should be sent. */
#undef PACKAGE_BUGREPORT

/* Define to the full name of this package. */
#undef PACKAGE_NAME

/* Define to the full name and version of this package. */
#undef PACKAGE_STRING

/* Define to the one symbol short name of this package. */
#undef PACKAGE_TARNAME

/* Define to the version of this package. */
#undef PACKAGE_VERSION

/* The size of a `char *', as computed by sizeof. */
#undef SIZEOF_CHAR_P

/* The size of a `int', as computed by sizeof. */
#undef SIZEOF_INT

/* The size of a `long', as computed by sizeof. */
#undef SIZEOF_LONG

/* The size of a `short', as computed by sizeof. */
#undef SIZEOF_SHORT

/* The size of a `size_t', as computed by sizeof. */
#undef SIZEOF_SIZE_T

/* The size of a `unsigned long', as computed by sizeof. */
#undef SIZEOF_UNSIGNED_LONG

/* Define to 1 if you have the ANSI C header files. */
#undef STDC_HEADERS

/* Version number of package */
#undef VERSION

/* Define to 1 if your processor stores words with the most significant byte
   first (like Motorola and SPARC, unlike Intel and VAX). */
#undef WORDS_BIGENDIAN

/*
 * jpeg.h needs HAVE_BOOLEAN, when the system uses boolean in system
 * headers and I'm too lazy to write a configure test as long as only
 * unixware is related
 */
#ifdef _UNIXWARE
#define HAVE_BOOLEAN
#endif



/*
 * AIX defines FD_SET in terms of bzero, but fails to include <strings.h>
 * that defines bzero.
 */

#if defined(_AIX)
#include <strings.h>
#endif



#if defined(HAVE_NSGETENVIRON) && defined(HAVE_CRT_EXTERNS_H)
# include <sys/time.h>
# include <crt_externs.h>
# define environ (*_NSGetEnviron())
#endif



#if !defined(HAVE_STRLCAT_PROTO)
#ifdef __cplusplus
extern "C" {
#endif
unsigned long strlcat(char*, const char*, unsigned long);
#ifdef __cplusplus
}
#endif
#endif



#if !defined(HAVE_STRLCPY_PROTO)
#ifdef __cplusplus
extern "C" {
#endif
unsigned long strlcpy(char*, const char*, unsigned long);
#ifdef __cplusplus
}
#endif
#endif



/*
 * On HP-UX, the declaration of vsnprintf() is needed every time !
 */

#if !defined(HAVE_VSNPRINTF) || defined(hpux)
#if __STDC__
#include <stdarg.h>
#include <stdlib.h>
#else
#include <varargs.h>
#endif
#ifdef __cplusplus
extern "C"
#endif
int vsnprintf(char *str, size_t n, char const *fmt, va_list ap);
#ifdef __cplusplus
extern "C"
#endif
int snprintf(char *str, size_t n, char const *fmt, ...);
#endif



#if defined(__SVR4) && !defined(__svr4__)
#define __svr4__ 1
#endif


/* Compatibility define */
#undef ksize_t

/* Define the real type of socklen_t */
#undef socklen_t
--- trunk/client/karpion/configure.in #1:2

dnl    This file is part of the KDE libraries/packages
dnl    Copyright (C) 2001 Stephan Kulow (coolo at kde.org)
 
dnl    This file is free software; you can redistribute it and/or
dnl    modify it under the terms of the GNU Library General Public
dnl    License as published by the Free Software Foundation; either
dnl    version 2 of the License, or (at your option) any later version.
 
dnl    This library is distributed in the hope that it will be useful,
dnl    but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl    Library General Public License for more details.
 
dnl    You should have received a copy of the GNU Library General Public License
dnl    along with this library; see the file COPYING.LIB.  If not, write to
dnl    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
dnl    Boston, MA 02111-1307, USA.

# Original Author was Kalle at kde.org
# I lifted it in some mater. (Stephan Kulow)
# I used much code from Janos Farkas

dnl Process this file with autoconf to produce a configure script.

AC_INIT(acinclude.m4) dnl a source file from your sub dir

dnl This is so we can use kde-common
AC_CONFIG_AUX_DIR(admin)

dnl This ksh/zsh feature conflicts with `cd blah ; pwd`
unset CDPATH

dnl Checking host/target/build systems, for make, install etc.
AC_CANONICAL_SYSTEM 
dnl Perform program name transformation
AC_ARG_PROGRAM

dnl Automake doc recommends to do this only here. (Janos)
AM_INIT_AUTOMAKE(karpion, 0.1.0) dnl searches for some needed programs

KDE_SET_PREFIX

dnl generate the config header
AM_CONFIG_HEADER(config.h) dnl at the distribution this done

dnl Checks for programs.
AC_CHECK_COMPILERS
AC_ENABLE_SHARED(yes)
AC_ENABLE_STATIC(no)
KDE_PROG_LIBTOOL

dnl for NLS support. Call them in this order!
dnl WITH_NLS is for the po files
AM_KDE_WITH_NLS

KDE_USE_QT(3.2.0)
AC_PATH_KDE
#MIN_CONFIG(3.2.0)

dnl PACKAGE set before
AC_C_BIGENDIAN
AC_CHECK_KDEMAXPATHLEN

AC_CHECK_LIB(phish, phish_init, [], [
echo
echo "You're missing libphish. Konqueror anti-phishing toolbar requires the "
echo "libphish library."
echo "You can get libphish at the Open Phishing Database website at: "
echo "http://opdb.berlios.de/"
echo
exit -1
])

AC_CHECK_HEADERS(phish.h)

KDE_CREATE_SUBDIRSLIST
AC_CONFIG_FILES([ Makefile ])
AC_CONFIG_FILES([ doc/Makefile ])
AC_CONFIG_FILES([ doc/en/Makefile ])
AC_CONFIG_FILES([ po/Makefile ])
AC_CONFIG_FILES([ src/Makefile ])
AC_OUTPUT
if test "$all_tests" = "bad"; then
  if test ! "$cache_file" = "/dev/null"; then
    echo ""    
    echo "Please remove the file $cache_file after changing your setup"
    echo "so that configure will find the changes next time."
    echo ""
  fi
else
  echo ""
  echo "Good - your configure finished. Start make now"
  echo ""
fi
--- trunk/client/karpion/configure.in.in #1:2

#MIN_CONFIG(3.2.0)

AM_INIT_AUTOMAKE(karpion, 0.1.0)
AC_C_BIGENDIAN
AC_CHECK_KDEMAXPATHLEN

AC_CHECK_LIB(phish, phish_init, [], [
echo
echo "You're missing libphish. Konqueror anti-phishing toolbar requires the "
echo "libphish library."
echo "You can get libphish at the Open Phishing Database website at: "
echo "http://opdb.berlios.de/"
echo
exit -1
])

AC_CHECK_HEADERS(phish.h)


--- trunk/client/karpion/doc/Makefile.am #1:2

# the SUBDIRS is filled automatically by am_edit. If files are 
# in this directory they are installed into the english dir

KDE_LANG = en
KDE_DOCS = karpion
SUBDIRS = $(AUTODIRS)  
--- trunk/client/karpion/doc/en/Makefile.am #1:2

KDE_DOCS = karpion
KDE_LANG = en
--- trunk/client/karpion/doc/en/index.docbook #1:2

<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY karpion "<application>karpion 0.1.0</application>">
  <!ENTITY kappname "&karpion;"><!-- Do *not* replace kappname-->
  <!ENTITY package "kde-module"><!-- kdebase, kdeadmin, etc -->
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE"><!-- change language only here -->
  
  
  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!-- kdoctemplate v0.8 October 1 1999 
     Minor update to "Credits and Licenses" section on August 24, 2000
     Removed "Revision history" section on 22 January 2001
     Changed to Installation/Help menu entities 18 October 2001
     Other minor cleanup and changes 18 October 2001 -->


<!--
This template was designed by: David Rugge davidrugge at mindspring.com
with lots of help from: Eric Bischoff ebisch at cybercable.tm.fr
and Frederik Fouvry fouvry at sfs.nphil.uni-tuebingen.de
of the KDE DocBook team.

You may freely use this template for writing any sort of KDE documentation.
If you have any changes or improvements, please let us know.

Remember:
- in XML, the case of the <tags> and attributes is relevant ;
- also, quote all attributes.

Please don't forget to remove all these comments in your final documentation,
thanks ;-).
-->

<!-- ................................................................ -->

<!-- The language must NOT be changed here. -->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title>The &karpion; Handbook</title>

<authorgroup>
<author>
<firstname></firstname>
<othername></othername>
<surname>Meni Livne</surname>
<affiliation>
<address><email>livne at kde.org</email></address>
</affiliation>
</author>
</authorgroup>

<!-- TRANS:ROLES_OF_TRANSLATORS -->

<copyright>
<year>1999</year>
<year>2006</year>
<holder>Meni Livne</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook
     and in the FDL itself on how to use it. -->
<legalnotice>&FDLNotice;</legalnotice>

<!-- Date and version information of the documentation
Don't forget to include this last date and this last revision number, we
need them for translation coordination !
Please respect the format of the date (YYYY-MM-DD) and of the version
(V.MM.LL), it could be used by automation scripts.
Do NOT change these in the translation. -->

<date>2001-10-18</date>
<releaseinfo>0.1.0</releaseinfo>

<!-- Abstract about this handbook -->

<abstract>
<para>
&karpion; is an application specially designed to do nothing you would
ever want.
</para>
</abstract>

<!-- This is a set of Keywords for indexing by search engines.
Please at least include KDE, the KDE package it is in, the name
 of your application, and a few relevant keywords. -->

<keywordset>
<keyword>KDE</keyword>
<keyword>karpion</keyword>
<keyword>nothing</keyword>
<keyword>nothing else</keyword>
</keywordset>

</bookinfo>

<!-- The contents of the documentation begin here.  Label
each chapter so with the id attribute. This is necessary for two reasons: it
allows you to easily reference the chapter from other chapters of your
document, and if there is no ID, the name of the generated HTML files will vary
from time to time making it hard to manage for maintainers and for the CVS
system. Any chapter labelled (OPTIONAL) may be left out at the author's
discretion. Other chapters should not be left out in order to maintain a
consistent documentation style across all KDE apps. -->

<chapter id="introduction">
<title>Introduction</title>

<!-- The introduction chapter contains a brief introduction for the
application that explains what it does and where to report
problems. Basically a long version of the abstract.  Don't include a
revision history. (see installation appendix comment) -->

<para>
&karpion; is a program that lets you do absolutely nothing. Please report
any problems or feature requests to the &kde; mailing lists.
</para>
</chapter>

<chapter id="using-karpion">
<title>Using &karpion;</title>

<!-- This chapter should tell the user how to use your app. You should use as
many sections (Chapter, Sect1, Sect3, etc...) as is necessary to fully document
your application. -->

<para>

<!-- Note that all graphics should be in .png format. Use no gifs because of
patent issues. -->

<screenshot>
<screeninfo>Here's a screenshot of &karpion;</screeninfo>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="screenshot.png" format="PNG"/>
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="screenshot.eps" format="EPS"/>
	  </imageobject>
	  <textobject>
	    <phrase>Screenshot</phrase>
	  </textobject>
	</mediaobject>
</screenshot>
</para>


<sect1 id="karpion-features">
<title>More &karpion; features</title>

<para>It slices! It dices! and it comes with a free toaster!</para>
<para>
The Squiggle Tool <guiicon><inlinemediaobject>
	  <imageobject>
	    <imagedata fileref="squiggle.png" format="PNG"/>
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="squiggle.eps" format="EPS"/>
	  </imageobject>
	  <textobject>
	    <phrase>Squiggle</phrase>
	  </textobject>
</inlinemediaobject></guiicon> is used to draw squiggly lines all over
the &karpion; main window. It's not a bug, it's a feature!
</para>

</sect1>
</chapter>

<chapter id="commands">
<title>Command Reference</title>

<!-- (OPTIONAL, BUT RECOMMENDED) This chapter should list all of the
application windows and their menubar and toolbar commands for easy reference.
Also include any keys that have a special function but have no equivalent in the
menus or toolbars. This may not be necessary for small apps or apps with no tool
or menu bars. -->

<sect1 id="karpion-mainwindow">
<title>The main &karpion; window</title>

<sect2>
<title>The File Menu</title>
<para>
<variablelist>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo action="simul">&Ctrl;<keycap>N</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>New</guimenuitem>
</menuchoice></term>
<listitem><para><action>Creates a new document</action></para></listitem>
</varlistentry>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo action="simul">&Ctrl;<keycap>S</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>Save</guimenuitem>
</menuchoice></term>
<listitem><para><action>Saves the document</action></para></listitem>
</varlistentry>
<varlistentry>
<term><menuchoice>
<shortcut>
<keycombo action="simul">&Ctrl;<keycap>Q</keycap></keycombo>
</shortcut>
<guimenu>File</guimenu>
<guimenuitem>Quit</guimenuitem>
</menuchoice></term>
<listitem><para><action>Quits</action> &karpion;</para></listitem>
</varlistentry>
</variablelist>
</para>

</sect2>

<sect2>
<title>The <guimenu>Help</guimenu> Menu</title>

<!-- Assuming you have a standard help menu (help, what's this, about -->
<!-- &karpion;, about KDE) then the documentation is already written. -->
<!-- The following entity is valid anywhere that a variablelist is -->
<!-- valid.  -->

&help.menu.documentation;

</sect2>

</sect1>
</chapter>

<chapter id="developers">
<title>Developer's Guide to &karpion;</title>

<!-- (OPTIONAL) A Programming/Scripting reference chapter should be
used for apps that use plugins or that provide their own scripting hooks
and/or development libraries. -->

<para>
Programming &karpion; plugins is a joy to behold. Just read through the next
66 pages of API's to learn how!
</para>

<!-- Use refentries to describe APIs.  Refentries are fairly complicated and you
should consult the docbook reference for further details. The example below was
taken from that reference and shortened a bit for readability. -->

<refentry id="re-1007-unmanagechildren-1">
<refmeta>
<refentrytitle>XtUnmanageChildren</refentrytitle>
<refmiscinfo>Xt - Geometry Management</refmiscinfo>
</refmeta>
<refnamediv>
<refname>XtUnmanageChildren
</refname>
<refpurpose>remove a list of children from a parent widget's managed
list.
<indexterm id="ix-1007-unmanagechildren-1"><primary>widgets</primary><secondary>removing</secondary></indexterm>
<indexterm id="ix-1007-unmanagechildren-2"><primary>XtUnmanageChildren</primary></indexterm> 
</refpurpose>

</refnamediv>
<refsynopsisdiv>
<refsynopsisdivinfo>
<date>4 March 1996</date>
</refsynopsisdivinfo>
<synopsis>
void XtUnmanageChildren(<replaceable class="parameter">children</replaceable>, <replaceable class="parameter">num_children</replaceable>)
    WidgetList <replaceable class="parameter">children</replaceable>;
    Cardinal <replaceable class="parameter">num_children</replaceable>;
</synopsis>

<refsect2 id="r2-1007-unmanagechildren-1">
<title>Inputs</title>
<variablelist>
<varlistentry>
<term><replaceable class="parameter">children</replaceable>
</term>
<listitem>
<para>Specifies an array of child widgets. Each child must be of
class RectObj or any subclass thereof.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><replaceable class="parameter">num_children</replaceable>
</term>
<listitem>
<para>Specifies the number of elements in <replaceable class="parameter">children</replaceable>.
</para>
</listitem>
</varlistentry>
</variablelist>
</refsect2></refsynopsisdiv>

<refsect1 id="r1-1007-unmanagechildren-1">
<title>Description
</title>
<para><function>XtUnmanageChildren()</function> unmaps the specified widgets
and removes them from their parent's geometry management.
The widgets will disappear from the screen, and (depending
on its parent) may no longer have screen space allocated for
them.
</para>
<para>Each of the widgets in the <replaceable class="parameter">children</replaceable> array must have
the same parent.
</para>
<para>See the &ldquo;Algorithm&rdquo; section below for full details of the
widget unmanagement procedure.
</para>
</refsect1>

<refsect1 id="r1-1007-unmanagechildren-2">
<title>Usage</title>
<para>Unmanaging widgets is the usual method for temporarily
making them invisible.  They can be re-managed with
<function>XtManageChildren()</function>.
</para>
<para>You can unmap a widget, but leave it under geometry
management by calling <function>XtUnmapWidget()</function>.  You can
destroy a widget's window without destroying the widget by
calling <function>XtUnrealizeWidget()</function>.  You can destroy a
widget completely with <function>XtDestroyWidget()</function>.
</para>
<para>If you are only going to unmanage a single widget, it is
more convenient to call <function>XtUnmanageChild()</function>.  It is
often more convenient to call <function>XtUnmanageChild()</function>
several times than it is to declare and initialize an array
of widgets to pass to <function>XtUnmanageChildren()</function>.  Calling
<function>XtUnmanageChildren()</function> is more efficient, however,
because it only calls the parent's <function>change_managed()</function>
method once.
</para>
</refsect1>

<refsect1 id="r1-1007-unmanagechildren-3">
<title>Algorithm
</title>
<para><function>XtUnmanageChildren()</function> performs the following:
</para>
<variablelist>
<varlistentry>
<term>-
</term>
<listitem>
<para>Ignores the child if it already is unmanaged or is being
destroyed.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>-
</term>
<listitem>
<para>Otherwise, if the child is realized, it makes it nonvisible
by unmapping it.
</para>
</listitem>
</varlistentry>
</variablelist>
<para>
</para>
</refsect1>

<refsect1 id="r1-1007-unmanagechildren-4">
<title>Structures</title>
<para>The <type>WidgetList</type> type is simply an array of widgets:
</para>
<screen id="sc-1007-unmanagechildren-1">typedef Widget *WidgetList;
</screen>
</refsect1>
</refentry>

</chapter>

<chapter id="faq">
<title>Questions and Answers</title>

<!-- (OPTIONAL but recommended) This chapter should include all of the silly
(and not-so-silly) newbie questions that fill up your mailbox. This chapter
should be reserved for BRIEF questions and answers! If one question uses more
than a page or so then it should probably be part of the
"Using this Application" chapter instead. You should use links to
cross-reference questions to the parts of your documentation that answer them.
This is also a great place to provide pointers to other FAQ's if your users
must do some complicated configuration on other programs in order for your
application work. -->

&reporting.bugs;
&updating.documentation;

<qandaset id="faqlist">
<qandaentry>
<question>
<para>My Mouse doesn't work. How do I quit &karpion;?</para>
</question>
<answer>
<para>You silly goose! Check out the <link linkend="commands">Commands
Section</link> for the answer.</para>
</answer>
</qandaentry>
<qandaentry>
<question>
<para>Why can't I twiddle my documents?</para>
</question>
<answer>
<para>You can only twiddle your documents if you have the foobar.lib
installed.</para>
</answer>
</qandaentry>
</qandaset>
</chapter>

<chapter id="credits">

<!-- Include credits for the programmers, documentation writers, and
contributors here. The license for your software should then be included below
the credits with a reference to the appropriate license file included in the KDE
distribution. -->

<title>Credits and License</title>

<para>
&karpion;
</para>
<para>
Program copyright 2006 Meni Livne <email>livne at kde.org</email>
</para>
<para>
Contributors:
<itemizedlist>
<listitem><para>Konqui the KDE Dragon <email>konqui at kde.org</email></para>
</listitem>
<listitem><para>Tux the Linux Penguin <email>tux at linux.org</email></para>
</listitem>
</itemizedlist>
</para>

<para>
Documentation copyright 2006 Meni Livne <email>livne at kde.org</email>
</para>

<!-- TRANS:CREDIT_FOR_TRANSLATORS -->

&underFDL;               <!-- FDL: do not remove -->

<!-- Determine which license your application is licensed under, 
     and delete all the remaining licenses below:

     (NOTE:  All documentation are licensed under the FDL, 
     regardless of what license the application uses) -->

&underGPL;        	 <!-- GPL License -->
&underBSDLicense;        <!-- BSD License -->
&underArtisticLicense;   <!-- BSD Artistic License -->
&underX11License;        <!-- X11 License  -->

</chapter>

<appendix id="installation">
<title>Installation</title>

<sect1 id="getting-karpion">
<title>How to obtain &karpion;</title>

<!-- This first entity contains boiler plate for applications that are
part of KDE CVS.  You should remove it if you are releasing your
application --> 

&install.intro.documentation;

</sect1>

<sect1 id="requirements">
<title>Requirements</title>

<!--
List any special requirements for your application here. This should include:
.Libraries or other software that is not included in kdesupport,
kdelibs, or kdebase.
.Hardware requirements like amount of RAM, disk space, graphics card
capabilities, screen resolution, special expansion cards, etc.
.Operating systems the app will run on. If your app is designed only for a
specific OS, (you wrote a graphical LILO configurator for example) put this
information here.
-->

<para>
In order to successfully use &karpion;, you need &kde; 1.1. Foobar.lib is
required in order to support the advanced &karpion; features. &karpion; uses
about 5 megs of memory to run, but this may vary depending on your
platform and configuration.
</para>

<para>
All required libraries as well as &karpion; itself can be found
on <ulink url="ftp://ftp.karpion.org">The &karpion; home page</ulink>.
</para>

<!-- For a list of updates, you may refer to the application web site
or the ChangeLog file, or ... -->
<para>
You can find a list of changes at <ulink
url="http://apps.kde.org/karpion">http://apps.kde.org/karpion</ulink>.
</para>
</sect1>

<sect1 id="compilation">
<title>Compilation and Installation</title>

<!-- This entity contains the boilerplate text for standard -->
<!-- compilation instructions.  If your application requires any -->
<!-- special handling, remove it, and replace with your own text. -->

&install.compile.documentation;

</sect1>

<sect1 id="configuration">
<title>Configuration</title>

<para>Don't forget to tell your system to start the <filename>dtd</filename>
dicer-toaster daemon first, or &karpion; won't work !</para>

</sect1>

</appendix>

&documentation.index;
</book>

<!--
Local Variables:
mode: sgml
sgml-minimize-attributes:nil
sgml-general-insert-case:lower
sgml-indent-step:0
sgml-indent-data:nil
End:

vim:tabstop=2:shiftwidth=2:expandtab 
-->

--- trunk/client/karpion/karpion.kdevelop #1:2

<?xml version = '1.0'?>
<kdevelop>
  <general>
    <author>Meni Livne</author>
    <email>livne at kde.org</email>
    <version>0.1.0</version>
    <projectmanagement>KDevKDEAutoProject</projectmanagement>
    <primarylanguage>C++</primarylanguage>
    <keywords>
      <keyword>C++</keyword>
      <keyword>Code</keyword>
      <keyword>Qt</keyword>
      <keyword>KDE</keyword>
    </keywords>
    <ignoreparts/>
  </general>
  <kdevautoproject>
    <general>
      <activetarget>src/libkarpion.la</activetarget>
      <useconfiguration>debug</useconfiguration>
    </general>
    <configurations>
      <optimized>
        <builddir>optimized</builddir>
        <ccompiler>kdevgccoptions</ccompiler>
        <cxxcompiler>kdevgppoptions</cxxcompiler>
        <f77compiler>kdevg77options</f77compiler>
        <cxxflags>-O2 -g0</cxxflags>
      </optimized>
      <debug>
        <configargs>--enable-debug=full</configargs>
        <builddir>debug</builddir>
        <ccompiler>kdevgccoptions</ccompiler>
        <cxxcompiler>kdevgppoptions</cxxcompiler>
        <f77compiler>kdevg77options</f77compiler>
        <cxxflags>-O0 -g3</cxxflags>
      </debug>
    </configurations>
    <make>
      <envvars>
        <envvar value="1" name="WANT_AUTOCONF_2_5" />
        <envvar value="1" name="WANT_AUTOMAKE_1_6" />
      </envvars>
    </make>
    <run>
      <directoryradio>executable</directoryradio>
    </run>
  </kdevautoproject>
  <kdevfileview>
    <groups>
      <group pattern="*.cpp;*.cxx;*.h" name="Sources" />
      <group pattern="*.ui" name="User Interface" />
      <group pattern="*.png" name="Icons" />
      <group pattern="*.po;*.ts" name="Translations" />
      <group pattern="*" name="Others" />
      <hidenonprojectfiles>false</hidenonprojectfiles>
      <hidenonlocation>false</hidenonlocation>
    </groups>
    <tree>
      <hidepatterns>*.o,*.lo,CVS</hidepatterns>
      <hidenonprojectfiles>false</hidenonprojectfiles>
    </tree>
  </kdevfileview>
  <kdevdoctreeview>
    <ignoretocs>
      <toc>ada</toc>
      <toc>ada_bugs_gcc</toc>
      <toc>bash</toc>
      <toc>bash_bugs</toc>
      <toc>clanlib</toc>
      <toc>fortran_bugs_gcc</toc>
      <toc>gnome1</toc>
      <toc>gnustep</toc>
      <toc>gtk</toc>
      <toc>gtk_bugs</toc>
      <toc>haskell</toc>
      <toc>haskell_bugs_ghc</toc>
      <toc>java_bugs_gcc</toc>
      <toc>java_bugs_sun</toc>
      <toc>opengl</toc>
      <toc>pascal_bugs_fp</toc>
      <toc>php</toc>
      <toc>php_bugs</toc>
      <toc>perl</toc>
      <toc>perl_bugs</toc>
      <toc>python</toc>
      <toc>python_bugs</toc>
      <toc>ruby</toc>
      <toc>ruby_bugs</toc>
      <toc>sdl</toc>
      <toc>stl</toc>
      <toc>sw</toc>
      <toc>w3c-dom-level2-html</toc>
      <toc>w3c-svg</toc>
      <toc>w3c-uaag10</toc>
      <toc>wxwidgets_bugs</toc>
    </ignoretocs>
    <ignoreqt_xml>
      <toc>qmake User Guide</toc>
    </ignoreqt_xml>
  </kdevdoctreeview>
  <kdevdebugger>
    <general>
      <dbgshell>libtool</dbgshell>
    </general>
  </kdevdebugger>
  <kdevfilecreate>
    <filetypes/>
    <useglobaltypes>
      <type ext="ui" />
      <type ext="cpp" />
      <type ext="h" />
    </useglobaltypes>
  </kdevfilecreate>
  <kdevdocumentation>
    <projectdoc>
      <docsystem>Doxygen Documentation Collection</docsystem>
      <docurl>karpion.tag</docurl>
    </projectdoc>
  </kdevdocumentation>
  <substmap>
    <APPNAME>karpion</APPNAME>
    <APPNAMELC>karpion</APPNAMELC>
    <APPNAMESC>Karpion</APPNAMESC>
    <APPNAMEUC>KARPION</APPNAMEUC>
    <AUTHOR>Meni Livne</AUTHOR>
    <EMAIL>livne at kde.org</EMAIL>
    <LICENSE>GPL</LICENSE>
    <LICENSEFILE>COPYING</LICENSEFILE>
    <VERSION>0.1.0</VERSION>
    <YEAR>2006</YEAR>
    <dest>/home/meni/study/pl/tau/workshop/svn/trunk/client/karpion</dest>
  </substmap>
  <kdevcppsupport>
    <references/>
    <codecompletion>
      <includeGlobalFunctions>true</includeGlobalFunctions>
      <includeTypes>true</includeTypes>
      <includeEnums>true</includeEnums>
      <includeTypedefs>false</includeTypedefs>
      <automaticCodeCompletion>true</automaticCodeCompletion>
      <automaticArgumentsHint>true</automaticArgumentsHint>
      <automaticHeaderCompletion>true</automaticHeaderCompletion>
      <codeCompletionDelay>250</codeCompletionDelay>
      <argumentsHintDelay>400</argumentsHintDelay>
      <headerCompletionDelay>250</headerCompletionDelay>
    </codecompletion>
    <designerintegration>
      <qtdesigner>
        <implementation class="KarpionConfigDialog" path="src/karpionconfigdlg.ui" implementationpath="src/karpionconfigdlgimpl.h" />
      </qtdesigner>
    </designerintegration>
  </kdevcppsupport>
  <dist>
    <custom>false</custom>
    <bzip>false</bzip>
    <archname/>
    <appname>karpion</appname>
    <version>0.1.0</version>
    <release/>
    <vendor/>
    <licence/>
    <summary/>
    <group/>
    <packager/>
    <description/>
    <changelog/>
    <devpackage>false</devpackage>
    <docspackage>false</docspackage>
    <appicon>false</appicon>
    <arch>0</arch>
    <genHTML>false</genHTML>
    <useRPM>false</useRPM>
    <ftpkde>false</ftpkde>
    <appskde>false</appskde>
    <url/>
  </dist>
</kdevelop>
--- trunk/client/karpion/po/Makefile.am #1:2

POFILES = AUTO
--- trunk/client/karpion/src/Makefile.am #1:2

INCLUDES    = $(all_includes)
METASOURCES = AUTO

KDE_ICON = AUTO

# Install this plugin in the KDE modules directory
kde_module_LTLIBRARIES = libkarpionplugin.la

# This is all standard.  Remove the LIB_KHTML reference if you are not
# using the KHTML Part
libkarpionplugin_la_SOURCES = plugin_karpion.cpp karpionconfigdlg.ui \
	karpionconfigdlgimpl.cpp
libkarpionplugin_la_LIBADD = -lphish $(LIB_KPARTS) $(LIB_KHTML)
libkarpionplugin_la_LDFLAGS = -avoid-version -module -no-undefined \
	$(KDE_PLUGIN) $(all_libraries)

# Install the .rc file in the Part's directory (in this case, the part
# is KHTMLPart)
pluginsdir = $(kde_datadir)/khtml/kpartplugins
plugins_DATA = plugin_karpion.rc plugin_karpion.desktop

messages: rc.cpp
	$(EXTRACTRC) `find . -name \*.ui -o -name \*.rc` > rc.cpp
	$(XGETTEXT) *.cpp -o $(podir)/karpion.pot
noinst_HEADERS = karpionconfigdlgimpl.h
** trunk/client/karpion/src/cr16-action-karpion.png #property svn:mime-type
   + application/octet-stream
** trunk/client/karpion/src/cr22-action-karpion.png #property svn:mime-type
   + application/octet-stream
--- trunk/client/karpion/src/karpion.lsm #1:2

Begin3
Title:          karpion -- Some description
Version:        0.1.0
Entered-date:   
Description:    
Keywords:       KDE Qt
Author:         Meni Livne <livne at kde.org>
Maintained-by:  Meni Livne <livne at kde.org>
Home-page:      
Alternate-site: 
Primary-site:   ftp://ftp.kde.org/pub/kde/unstable/apps/utils
                xxxxxx  karpion-0.1.0.tar.gz
                xxx     karpion-0.1.0.lsm
Platform:       Linux. Needs KDE
Copying-policy: GPL
End
--- trunk/client/karpion/src/karpionconfigdlg.ui #1:2

<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
<class>KarpionConfigDlg</class>
<widget class="QDialog">
    <property name="name">
        <cstring>KarpionConfigDlg</cstring>
    </property>
    <property name="geometry">
        <rect>
            <x>0</x>
            <y>0</y>
            <width>527</width>
            <height>368</height>
        </rect>
    </property>
    <property name="caption">
        <string>Configure Konqueror Anti-Phishing Toolbar</string>
    </property>
    <property name="sizeGripEnabled">
        <bool>true</bool>
    </property>
    <grid>
        <property name="name">
            <cstring>unnamed</cstring>
        </property>
        <widget class="QLayoutWidget" row="1" column="0">
            <property name="name">
                <cstring>Layout1</cstring>
            </property>
            <hbox>
                <property name="name">
                    <cstring>unnamed</cstring>
                </property>
                <property name="margin">
                    <number>0</number>
                </property>
                <property name="spacing">
                    <number>6</number>
                </property>
                <widget class="QPushButton">
                    <property name="name">
                        <cstring>buttonHelp</cstring>
                    </property>
                    <property name="text">
                        <string>&amp;Help</string>
                    </property>
                    <property name="accel">
                        <string>F1</string>
                    </property>
                    <property name="autoDefault">
                        <bool>true</bool>
                    </property>
                </widget>
                <spacer>
                    <property name="name">
                        <cstring>Horizontal Spacing2</cstring>
                    </property>
                    <property name="orientation">
                        <enum>Horizontal</enum>
                    </property>
                    <property name="sizeType">
                        <enum>Expanding</enum>
                    </property>
                    <property name="sizeHint">
                        <size>
                            <width>20</width>
                            <height>20</height>
                        </size>
                    </property>
                </spacer>
                <widget class="QPushButton">
                    <property name="name">
                        <cstring>buttonOk</cstring>
                    </property>
                    <property name="text">
                        <string>&amp;OK</string>
                    </property>
                    <property name="accel">
                        <string></string>
                    </property>
                    <property name="autoDefault">
                        <bool>true</bool>
                    </property>
                    <property name="default">
                        <bool>true</bool>
                    </property>
                </widget>
                <widget class="QPushButton">
                    <property name="name">
                        <cstring>buttonCancel</cstring>
                    </property>
                    <property name="text">
                        <string>Ca&amp;ncel</string>
                    </property>
                    <property name="accel">
                        <string>Alt+N</string>
                    </property>
                    <property name="autoDefault">
                        <bool>true</bool>
                    </property>
                </widget>
            </hbox>
        </widget>
        <widget class="QTabWidget" row="0" column="0">
            <property name="name">
                <cstring>tabWidget</cstring>
            </property>
            <property name="tabPosition">
                <enum>Top</enum>
            </property>
            <property name="tabShape">
                <enum>Rounded</enum>
            </property>
            <widget class="QWidget">
                <property name="name">
                    <cstring>Widget8</cstring>
                </property>
                <attribute name="title">
                    <string>&amp;General</string>
                </attribute>
                <grid>
                    <property name="name">
                        <cstring>unnamed</cstring>
                    </property>
                    <widget class="QLayoutWidget" row="0" column="0">
                        <property name="name">
                            <cstring>layout24</cstring>
                        </property>
                        <vbox>
                            <property name="name">
                                <cstring>unnamed</cstring>
                            </property>
                            <widget class="QLayoutWidget">
                                <property name="name">
                                    <cstring>layout21</cstring>
                                </property>
                                <hbox>
                                    <property name="name">
                                        <cstring>unnamed</cstring>
                                    </property>
                                    <widget class="QLabel">
                                        <property name="name">
                                            <cstring>textLabel1</cstring>
                                        </property>
                                        <property name="sizePolicy">
                                            <sizepolicy>
                                                <hsizetype>0</hsizetype>
                                                <vsizetype>5</vsizetype>
                                                <horstretch>0</horstretch>
                                                <verstretch>0</verstretch>
                                            </sizepolicy>
                                        </property>
                                        <property name="text">
                                            <string>Running mode:</string>
                                        </property>
                                    </widget>
                                    <widget class="QComboBox">
                                        <item>
                                            <property name="text">
                                                <string>Online</string>
                                            </property>
                                        </item>
                                        <item>
                                            <property name="text">
                                                <string>Offline</string>
                                            </property>
                                        </item>
                                        <property name="name">
                                            <cstring>running_mode</cstring>
                                        </property>
                                        <property name="sizePolicy">
                                            <sizepolicy>
                                                <hsizetype>0</hsizetype>
                                                <vsizetype>0</vsizetype>
                                                <horstretch>0</horstretch>
                                                <verstretch>0</verstretch>
                                            </sizepolicy>
                                        </property>
                                    </widget>
                                    <spacer>
                                        <property name="name">
                                            <cstring>spacer12</cstring>
                                        </property>
                                        <property name="orientation">
                                            <enum>Horizontal</enum>
                                        </property>
                                        <property name="sizeType">
                                            <enum>Expanding</enum>
                                        </property>
                                        <property name="sizeHint">
                                            <size>
                                                <width>40</width>
                                                <height>20</height>
                                            </size>
                                        </property>
                                    </spacer>
                                </hbox>
                            </widget>
                            <widget class="QLayoutWidget">
                                <property name="name">
                                    <cstring>layout22</cstring>
                                </property>
                                <hbox>
                                    <property name="name">
                                        <cstring>unnamed</cstring>
                                    </property>
                                    <widget class="QCheckBox">
                                        <property name="name">
                                            <cstring>check_country</cstring>
                                        </property>
                                        <property name="text">
                                            <string>Check for countr&amp;y of sites</string>
                                        </property>
                                        <property name="accel">
                                            <string>Alt+Y</string>
                                        </property>
                                    </widget>
                                    <spacer>
                                        <property name="name">
                                            <cstring>spacer13</cstring>
                                        </property>
                                        <property name="orientation">
                                            <enum>Horizontal</enum>
                                        </property>
                                        <property name="sizeType">
                                            <enum>Expanding</enum>
                                        </property>
                                        <property name="sizeHint">
                                            <size>
                                                <width>40</width>
                                                <height>20</height>
                                            </size>
                                        </property>
                                    </spacer>
                                </hbox>
                            </widget>
                            <spacer>
                                <property name="name">
                                    <cstring>spacer4</cstring>
                                </property>
                                <property name="orientation">
                                    <enum>Vertical</enum>
                                </property>
                                <property name="sizeType">
                                    <enum>Fixed</enum>
                                </property>
                                <property name="sizeHint">
                                    <size>
                                        <width>20</width>
                                        <height>5</height>
                                    </size>
                                </property>
                            </spacer>
                            <widget class="QLayoutWidget">
                                <property name="name">
                                    <cstring>layout23</cstring>
                                </property>
                                <hbox>
                                    <property name="name">
                                        <cstring>unnamed</cstring>
                                    </property>
                                    <widget class="QLabel">
                                        <property name="name">
                                            <cstring>textLabel2</cstring>
                                        </property>
                                        <property name="sizePolicy">
                                            <sizepolicy>
                                                <hsizetype>0</hsizetype>
                                                <vsizetype>5</vsizetype>
                                                <horstretch>0</horstretch>
                                                <verstretch>0</verstretch>
                                            </sizepolicy>
                                        </property>
                                        <property name="text">
                                            <string>Check for updates to site list every:</string>
                                        </property>
                                    </widget>
                                    <widget class="QSpinBox">
                                        <property name="name">
                                            <cstring>update_interval</cstring>
                                        </property>
                                        <property name="sizePolicy">
                                            <sizepolicy>
                                                <hsizetype>0</hsizetype>
                                                <vsizetype>0</vsizetype>
                                                <horstretch>0</horstretch>
                                                <verstretch>0</verstretch>
                                            </sizepolicy>
                                        </property>
                                        <property name="suffix">
                                            <string> minutes</string>
                                        </property>
                                        <property name="maxValue">
                                            <number>360</number>
                                        </property>
                                        <property name="minValue">
                                            <number>15</number>
                                        </property>
                                        <property name="value">
                                            <number>30</number>
                                        </property>
                                    </widget>
                                    <spacer>
                                        <property name="name">
                                            <cstring>spacer14</cstring>
                                        </property>
                                        <property name="orientation">
                                            <enum>Horizontal</enum>
                                        </property>
                                        <property name="sizeType">
                                            <enum>Expanding</enum>
                                        </property>
                                        <property name="sizeHint">
                                            <size>
                                                <width>40</width>
                                                <height>20</height>
                                            </size>
                                        </property>
                                    </spacer>
                                </hbox>
                            </widget>
                            <spacer>
                                <property name="name">
                                    <cstring>spacer15</cstring>
                                </property>
                                <property name="orientation">
                                    <enum>Vertical</enum>
                                </property>
                                <property name="sizeType">
                                    <enum>Expanding</enum>
                                </property>
                                <property name="sizeHint">
                                    <size>
                                        <width>20</width>
                                        <height>40</height>
                                    </size>
                                </property>
                            </spacer>
                        </vbox>
                    </widget>
                </grid>
            </widget>
            <widget class="QWidget">
                <property name="name">
                    <cstring>Widget9</cstring>
                </property>
                <attribute name="title">
                    <string>S&amp;afe List</string>
                </attribute>
                <grid>
                    <property name="name">
                        <cstring>unnamed</cstring>
                    </property>
                    <widget class="QLayoutWidget" row="0" column="0">
                        <property name="name">
                            <cstring>layout9</cstring>
                        </property>
                        <hbox>
                            <property name="name">
                                <cstring>unnamed</cstring>
                            </property>
                            <widget class="QListBox">
                                <property name="name">
                                    <cstring>safelistbox</cstring>
                                </property>
                            </widget>
                            <widget class="QLayoutWidget">
                                <property name="name">
                                    <cstring>layout8</cstring>
                                </property>
                                <vbox>
                                    <property name="name">
                                        <cstring>unnamed</cstring>
                                    </property>
                                    <widget class="QPushButton">
                                        <property name="name">
                                            <cstring>sl_add</cstring>
                                        </property>
                                        <property name="text">
                                            <string>&amp;Add...</string>
                                        </property>
                                        <property name="accel">
                                            <string>Alt+A</string>
                                        </property>
                                    </widget>
                                    <widget class="QPushButton">
                                        <property name="name">
                                            <cstring>sl_modify</cstring>
                                        </property>
                                        <property name="text">
                                            <string>Modif&amp;y...</string>
                                        </property>
                                        <property name="accel">
                                            <string>Alt+Y</string>
                                        </property>
                                    </widget>
                                    <widget class="QPushButton">
                                        <property name="name">
                                            <cstring>sl_remove</cstring>
                                        </property>
                                        <property name="text">
                                            <string>&amp;Remove</string>
                                        </property>
                                        <property name="accel">
                                            <string>Alt+R</string>
                                        </property>
                                    </widget>
                                    <spacer>
                                        <property name="name">
                                            <cstring>spacer2</cstring>
                                        </property>
                                        <property name="orientation">
                                            <enum>Vertical</enum>
                                        </property>
                                        <property name="sizeType">
                                            <enum>Expanding</enum>
                                        </property>
                                        <property name="sizeHint">
                                            <size>
                                                <width>20</width>
                                                <height>170</height>
                                            </size>
                                        </property>
                                    </spacer>
                                </vbox>
                            </widget>
                        </hbox>
                    </widget>
                </grid>
            </widget>
        </widget>
    </grid>
</widget>
<connections>
    <connection>
        <sender>buttonOk</sender>
        <signal>clicked()</signal>
        <receiver>KarpionConfigDlg</receiver>
        <slot>accept()</slot>
    </connection>
    <connection>
        <sender>buttonCancel</sender>
        <signal>clicked()</signal>
        <receiver>KarpionConfigDlg</receiver>
        <slot>reject()</slot>
    </connection>
</connections>
<layoutdefaults spacing="6" margin="11"/>
</UI>
--- trunk/client/karpion/src/karpionconfigdlgimpl.cpp #1:2

/***************************************************************************
 *   Copyright (C) 2006 by Meni Livne <livne at kde.org>                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "karpionconfigdlgimpl.h"

#include <kconfig.h>
#include <klocale.h>
#include <kinputdialog.h>

#include <qcombobox.h>
#include <qcheckbox.h>
#include <qspinbox.h>
#include <qlistbox.h>

#include <phish.h>


KarpionConfigDialog::KarpionConfigDialog(KConfig *cfg, QWidget *parent,
                                         const char *name) :
                                                KarpionConfigDlg(parent, name)
{
  phish_mode_t mode;
  m_config = cfg;
  
  cfg->setGroup("General");
  
  check_country->setChecked(cfg->readEntry("CheckCountry", "0").toInt() != 0);
  update_interval->setValue(cfg->readEntry("UpdateInterval", "30").toInt());
  
  phish_runningMode(&mode);
  switch(mode)
  {
    case PHISH_ONLINE_MODE:
      running_mode->setCurrentText(i18n("Online"));
      break;
    case PHISH_OFFLINE_MODE:
      running_mode->setCurrentText(i18n("Offline"));
      break;
  }
  
  // populate safe list
  phish_safe_list_entry_t *entry;
  
  phish_getSafeListFirst(&entry);
  while (entry != NULL)
  {
    phish_safe_list_entry_t *next;
    const char *url;
    
    phish_getSafeListData(entry, &url);
    safelistbox->insertItem(url);
    phish_getSafeListNext(entry, &next);
    entry = next;
  }
  
  connect((QObject *)sl_add, SIGNAL(clicked()), SLOT(safeListAdd()));
  connect((QObject *)sl_modify, SIGNAL(clicked()), SLOT(safeListModify()));
  connect((QObject *)sl_remove, SIGNAL(clicked()), SLOT(safeListRemove()));
}

KarpionConfigDialog::~KarpionConfigDialog()
{
}

void KarpionConfigDialog::accept()
{
  m_config->writeEntry("CheckCountry", check_country->isChecked() ? 1 : 0);
  m_config->writeEntry("UpdateInterval", update_interval->value());
  
  if (running_mode->currentText() == i18n("Online"))
    phish_setRunningMode(PHISH_ONLINE_MODE);
  else if (running_mode->currentText() == i18n("Offline"))
    phish_setRunningMode(PHISH_OFFLINE_MODE);
  
  // set new safe list
  phish_safe_list_t *newlist;
  
  phish_newSafeList(&newlist);
  
  for (unsigned int i = 0 ; i < safelistbox->count() ; i++)
  {
    phish_addToSafeList(newlist, safelistbox->text(i).ascii());
  }
  
  phish_setSafeList(newlist);
  phish_saveSafeList();
  phish_saveSettings();
  
  m_config->sync();
  
  QDialog::accept();
}

void KarpionConfigDialog::safeListAdd()
{
  QString url = KInputDialog::getText(i18n("Add URL To Safe List"),
                                      i18n("Enter a URL to add to the safe "
                                          "list."), QString(), 0, this);
  if (!url.isNull())
    safelistbox->insertItem(url);
}

void KarpionConfigDialog::safeListModify()
{
  if (safelistbox->currentItem() == -1)
    return;
  
  QString url = KInputDialog::getText(i18n("Modify Safe List URL"),
                                      i18n("Enter a new URL."),
                                      safelistbox->currentText(), 0, this);
  
  if (!url.isNull())
    safelistbox->changeItem(url, safelistbox->currentItem());
}

void KarpionConfigDialog::safeListRemove()
{
  if (safelistbox->currentItem() != -1)
    safelistbox->removeItem(safelistbox->currentItem());
}


#include "karpionconfigdlgimpl.moc"
--- trunk/client/karpion/src/karpionconfigdlgimpl.h #1:2

/***************************************************************************
 *   Copyright (C) 2006 by Meni Livne <livne at kde.org>                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __KARPIONCONFIGDLGIMPL_H
#define __KARPIONCONFIGDLGIMPL_H

#include "karpionconfigdlg.h"


class KConfig;

class KarpionConfigDialog : public KarpionConfigDlg
{
  Q_OBJECT
      
  public:
    KarpionConfigDialog(KConfig *cfg, QWidget *parent = 0,
                        const char *name = 0);
    ~KarpionConfigDialog();
    
  protected slots:
    void accept();
    
  private slots:
    void safeListAdd();
    void safeListModify();
    void safeListRemove();
    
  private:
    KConfig *m_config;
};


#endif /* __KARPIONCONFIGDLGIMPL_H */
--- trunk/client/karpion/src/plugin_karpion.cpp #1:2

/***************************************************************************
 *   Copyright (C) 2006 by Meni Livne <livne at kde.org>                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "plugin_karpion.h"
#include "karpionconfigdlgimpl.h"

#include <string.h>

#include <qlabel.h>
#include <qtimer.h>

#include <kgenericfactory.h>
#include <khtmlview.h>
#include <khtml_part.h>
#include <kstandarddirs.h>
#include <kprotocolmanager.h>
#include <kconfig.h>
#include <kaction.h>
#include <klocale.h>
#include <kglobal.h>
#include <kparts/mainwindow.h>
#include <ktoolbarlabelaction.h>
#include <kaboutapplication.h>

#include <kdialogbase.h>


#define KARPION_VERSION "0.1.0"

typedef KGenericFactory<KarpionPlugin> KarpionPluginFactory;
K_EXPORT_COMPONENT_FACTORY(libkarpionplugin, KarpionPluginFactory("karpion"))


enum {KarpionXMLUpdateEvent = QEvent::User,
      KarpionCheckURLEvent,
      KarpionCheckCountryEvent };


QCache<KarpionURLData> KarpionPlugin::m_url_cache;
KConfig *KarpionPlugin::m_config;
bool KarpionPlugin::m_config_read = false;
phish_mode_t KarpionPlugin::m_running_mode;
bool KarpionPlugin::m_check_country;
int KarpionPlugin::m_update_interval;
QTimer KarpionPlugin::m_update_timer;


KarpionPlugin::KarpionPlugin(QObject* parent, const char* name,
                             const QStringList&) : Plugin(parent, name),
                                                   m_url_data(NULL),
                                                   m_part(0),
                                                   xml_thread(this),
                                                   url_thread(this),
                                                   country_thread(this)
{
  if (!parent->inherits("KHTMLPart"))
  {
    return;
  }
  
  setInstance(KarpionPluginFactory::instance());
  
  m_part = dynamic_cast<KHTMLPart *>(parent);
  
  m_about_data = new KAboutData("karpion", I18N_NOOP("Konqueror Anti-"
                                "Phishing Extension"), KARPION_VERSION,
                                I18N_NOOP("A Konqueror toolbar extension to "
                                          "prevent phishing."),
                                KAboutData::License_GPL,
                                I18N_NOOP("(c) 2006, Meni Livne"),
                                I18N_NOOP("Part of the Open Phishing "
                                          "Database Project."),
                                "http://opdb.berlios.de/");
  
  m_about_data->addAuthor("Meni Livne", 0, "livne at kde.org");
  m_about_data->addCredit("Boaz Anin", I18N_NOOP("libphish co-author"),
                          "boazanin at gmail.com");
  m_about_data->addCredit("Shahar Karin", I18N_NOOP("libphish co-author"),
                          "shaharka at post.tau.ac.il");
  
  m_aa = new KAboutApplication(m_about_data, 0, 0, false);
  
  m_menu = new KActionMenu(i18n("Anti-Phishing"), "karpion",
                           actionCollection(), "karpion_sitemenu");
  m_menu->setDelayed(false);
  
  m_reportphishing = new KAction(i18n("Report This Site As Phishing..."), 0,
                                 this, SLOT(reportPhishing()),
                                 actionCollection(), "karpion_reportphishing");
  m_addsafelist = new KAction(i18n("Add Site To Safe List..."), 0,
                                   this, SLOT(addToSafeList()),
                                   actionCollection(), "karpion_addsafelist");
  m_configure = new KAction(i18n("Configure Phishing Toolbar..."), "configure",
                            0, this, SLOT(configure()), actionCollection(),
                            "karpion_configure");
  m_about = new KAction(i18n("About Konqueror Phishing Toolbar"), "karpion",
                        0, this, SLOT(about()), actionCollection(),
                        "karpion_about");
  
  m_menu->insert(m_reportphishing);
  m_menu->insert(m_addsafelist);
  m_menu->insert(new KActionSeparator(actionCollection()));
  m_menu->insert(m_configure);
  m_menu->insert(new KActionSeparator(actionCollection()));
  m_menu->insert(m_about);
  
  m_risk = new KToolBarLabelAction("", 0, 0, 0, actionCollection(),
                                   "karpion_risklabel");
  
  m_country = new KToolBarLabelAction("", 0, 0, 0, actionCollection(),
                                      "karpion_countrylabel");
  
  m_siteinfo = new KAction(i18n("Site Information..."), 0, this,
                           SLOT(siteInfo()), actionCollection(),
                           "karpion_siteinfo");
  
  m_url_cache.setAutoDelete(true);
  
  clear();
  
  QTimer::singleShot(0, this, SLOT(delayedSetup()));
}

KarpionPlugin::~KarpionPlugin()
{
  phish_shutdown();
}

void KarpionPlugin::readConfig()
{
  m_config->setGroup("General");
  
  m_check_country = (m_config->readEntry("CheckCountry", "0").toInt() != 0);
  m_update_interval = m_config->readEntry("UpdateInterval", "30").toInt();
  
  phish_runningMode(&m_running_mode);
  
  if (m_running_mode == PHISH_ONLINE_MODE)
    m_update_timer.stop();
  else
  {
    updateXML();
    m_update_timer.start(m_update_interval * 60 * 1000);
  }
}

void KarpionPlugin::delayedSetup()
{
  phish_result_t r;
  
  if (m_part == 0)
    return;
  
  KMainWindow *mainwin = (KMainWindow *)m_part->view()->topLevelWidget();
  
  KToolBar *toolbar = mainwin->toolBar("karpionToolBar");
  
  toolbar->setIconText(KToolBar::IconTextRight);
  
  QString ver = QString("Karpion/%1").arg(KARPION_VERSION);
  r = phish_init(KProtocolManager::defaultUserAgent().ascii(), ver.ascii());
  if (r != PHISH_SUCCESS)
    kdDebug() << "phish_init() result = " << r << endl;
  
  connect(m_part, SIGNAL(docCreated()), this, SLOT(checkCurrentURL()));
  
  connect(&m_update_timer, SIGNAL(timeout()), SLOT(updateXML()));
  
  if (!m_config_read)
  {
    m_config_read = true;
    
    m_config = new KConfig("karpionrc", false, false);
    readConfig();
  }
}

void KarpionPlugin::customEvent(QCustomEvent *ev)
{
  switch(ev->type())
  {
    case KarpionXMLUpdateEvent:
      break;
      
    case KarpionCheckURLEvent:
      m_url_data = new phish_url_data_t;
      *m_url_data = url_thread.urlData();
      m_url_cache.insert(url_thread.url(), new KarpionURLData(m_url_data));
      
      setRiskLevel(m_url_data->risk_level);
      m_siteinfo->setEnabled(true);
      
      if (m_check_country)
        setCountry(m_url_data->country);
      
      break;
      
    case KarpionCheckCountryEvent:
      if (m_safe == 1)
      {
        m_url_data = new phish_url_data_t;
        *m_url_data = country_thread.urlData();
        m_url_cache.insert(country_thread.url(), new KarpionURLData(m_url_data));
      }
      else
      {
        strncpy(m_url_data->country, country_thread.urlData().country, 2);
        m_url_data->country[2] = '\0';
      }
      
      m_siteinfo->setEnabled(true);
      setCountry(m_url_data->country);
      
      break;
      
    default:
      break;
  }
}

void KarpionPlugin::checkCurrentURL()
{
  KarpionURLData *url_d;
  phish_result_t r;
  QString url;
  int safe;
  
  if (m_check_country)
  {
    m_country->setEnabled(true);
  }
  else
  {
    clearCountry();
    m_country->setEnabled(false);
  }
  
  KURL kurl(m_part->url());
  if (!kurl.isValid() || kurl.host().isEmpty())
  {
    clear();
    return;
  }
  
  url = kurl.url();
  
  r = phish_checkSafeList(url.ascii(), &safe);
  m_safe = safe;
  
  if (m_safe)
  {
    if (m_check_country)
    {
      if ((url_d = m_url_cache.find(url)) != 0)
      {
        m_url_data = url_d->data();
        setCountry(m_url_data->country);
        m_siteinfo->setEnabled(true);
      }
      else
      {
        checkCountry(url);
      }
    }
    
    setRiskLevel(PHISH_RISK_NONE);
  }
  else
  {
    if ((url_d = m_url_cache.find(url)) != 0)
    {
      m_url_data = url_d->data();
      setRiskLevel(m_url_data->risk_level);
      m_siteinfo->setEnabled(true);
      
      if (m_check_country)
        setCountry(m_url_data->country);
    }
    else
    {
      if (m_running_mode == PHISH_OFFLINE_MODE)
      {
        m_url_data = new phish_url_data_t;
        r = phish_checkURL(url.ascii(), m_url_data);
        
        m_url_cache.insert(url, new KarpionURLData(m_url_data));
        
        setRiskLevel(m_url_data->risk_level);
        m_siteinfo->setEnabled(true);
        
        if (m_check_country)
          checkCountry(url);
      }
      else
      {
        checkURL(url);
      }
    }
  }
}

void KarpionPlugin::checkURL(const QString& url)
{
  setCheckingRiskLevel();
  m_siteinfo->setEnabled(false);
  
  if (m_check_country)
    setCheckingCountry();
  
  url_thread.setURL(url);
  url_thread.start();
}

void KarpionPlugin::checkCountry(const QString& url)
{
  setCheckingCountry();
  country_thread.setURL(url);
  country_thread.start();
}

void KarpionPlugin::updateXML()
{
  xml_thread.start();
}

void KarpionPlugin::setRiskLevel(phish_risk_t level)
{
  QString text = "<nobr>";
  text += i18n("Risk Level:");
  text += " ";
  
  switch(level)
  {
    case PHISH_RISK_UNKNOWN:
      text += i18n("<b>Unknown</b>");
      break;
    case PHISH_RISK_NONE:
      text += i18n("<font color=darkgreen><b>None</b></font>");
      break;
    case PHISH_RISK_LOW:
      text += i18n("<b>Low</b>");
      break;
    case PHISH_RISK_MEDIUM:
      text += i18n("<font color=orange><b>Medium</b></font>");
      break;
    case PHISH_RISK_HIGH:
      text += i18n("<font color=red><b>High</b></font>");
      break;
  }
  
  text += "</nobr>";
  
  m_risk->setText(text);
}

void KarpionPlugin::setCheckingRiskLevel()
{
  QString risk_text = i18n("Risk Level:");
  QString checking_text = i18n("Checking...");
  m_risk->setText(QString("<nobr>%1 <font color=darkgrey><b>%2</b></font>")
                                      .arg(risk_text).arg(checking_text));
}

void KarpionPlugin::setCountry(const QString& country_code)
{
  if (country_code.length() != 2)
    clearCountry();
  
  QString full_name = KGlobal::locale()->twoAlphaToCountryName(country_code);
  if (!full_name.isEmpty())
  {
    QString flag_file = locate("locale", QString("l10n/%1/flag.png")
        .arg(country_code.lower()));
    
    QString text = "<nobr>";
    text += i18n("Country");
    m_country->setText(text + QString(":&nbsp;<img src=\"%1\"/>&nbsp;%2</nobr>")
                                              .arg(flag_file).arg(full_name));
  }
  else
  {
    clearCountry();
  }
}

void KarpionPlugin::clearCountry()
{
  m_country->setText("<nobr>" + i18n("Country: Unknown") + "</nobr>");
}

void KarpionPlugin::setCheckingCountry()
{
  QString text = "<nobr>";
  text += i18n("Country");
  m_country->setText(text + QString(":&nbsp;%1</nobr>").arg(i18n("Checking...")));
}

void KarpionPlugin::clear()
{
  m_url_data = NULL;
  m_siteinfo->setEnabled(false);
  setRiskLevel(PHISH_RISK_UNKNOWN);
  clearCountry();
}

void KarpionPlugin::reportPhishing()
{
  char *url;
  phish_result_t r;
  
  KURL kurl(m_part->url());
  if (!kurl.isValid() || kurl.host().isEmpty())
    return;
  
  r = phish_getReportingURL(kurl.url(), &url);
  
  if (r != PHISH_SUCCESS)
  {
    // handle error
  }
  
  m_part->browserExtension()->createNewWindow(KURL(url));
  
  free(url);
}

void KarpionPlugin::addToSafeList()
{
  phish_result_t r;
  
  KURL kurl(m_part->url());
  if (!kurl.isValid() || kurl.host().isEmpty())
    return;
  
  r = phish_addToCurrentSafeList(kurl.url());
  
  if (r != PHISH_SUCCESS)
  {
    // handle error
  }
  
  // update display now that site is safe
  checkCurrentURL();
}

void KarpionPlugin::siteInfo()
{
  if (m_url_data == NULL)
    return;
  
  QString text;
  
  KDialogBase *dlg = new KDialogBase(0, 0, true, i18n("Site Information"),
                                     KDialogBase::Close);
  QLabel *label = new QLabel(dlg);
  dlg->setMainWidget(label);
  
  text += QString("<nobr>%1</nobr><br><br>")
                                  .arg(i18n("Site Information For %1")
                                   .arg(m_part->url().url()));
  
  if (m_safe)
  {
    text += i18n("Site is in safe list.<br>");
  }
  else
  {
    QString risk;
    
    switch (m_url_data->risk_level)
    {
      case PHISH_RISK_UNKNOWN:
        risk = i18n("Unknown");
        break;
      case PHISH_RISK_NONE:
        risk = i18n("None");
        break;
      case PHISH_RISK_LOW:
        risk = i18n("Low");
        break;
      case PHISH_RISK_MEDIUM:
        risk = i18n("Medium");
        break;
      case PHISH_RISK_HIGH:
        risk = i18n("High");
        break;
    }
    
    text += i18n("Risk Level: %1<br>").arg(risk);
    
    if (m_url_data->server == -1)
    {
      if (m_url_data->ip == 1 && m_url_data->path == 1)
        text += i18n("Complete address of site is in database.<br>");
      else if (m_url_data->ip == 1)
        text += i18n("IP address of site is in database.<br>");
    }
    else
    {
      if (m_url_data->server == 1 && m_url_data->path == 1)
      {
        text += i18n("Complete address of site is in database.<br>");
        
        if (m_url_data->ip == 1)
          text += i18n("IP address of site is in database.<br>");
      }
      else
      {
        if (m_url_data->server == 1)
          text += i18n("Hostname of site is in database.<br>");
        if (m_url_data->domain == 1)
          text += i18n("Domain name of site is in database.<br>");
        if (m_url_data->path == 1)
          text += i18n("Path of site is in database.<br>");
        if (m_url_data->ip == 1)
          text += i18n("IP address of site is in database.<br>");
      }
    }
    
    if (m_url_data->user_scheme == 1)
      text += i18n("Site address has user at host scheme.<br>");
    
    if (m_url_data->suspicious_host == 1)
      text += i18n("Hostname of site contains suspicious characters.<br>");
    
    if (m_url_data->comments_length > 0)
    {
      text += "<br>";
      text += i18n("Comments:");
      text += "<br>";
      text += m_url_data->comments;
    }
  }
  
  label->setText(text);
  dlg->show();
}

void KarpionPlugin::configure()
{
  KarpionConfigDialog *dlg = new KarpionConfigDialog(m_config);
  
  if (dlg->exec() == QDialog::Accepted)
  {
    readConfig();
  }
  
  delete dlg;
}

void KarpionPlugin::about()
{
  m_aa->show();
}

KarpionURLData::KarpionURLData(phish_url_data_t *url_data)
{
  m_url_data = url_data;
}

KarpionURLData::~KarpionURLData()
{
  phish_deleteURLData(m_url_data);
  delete m_url_data;
}


void KarpionXMLUpdateThread::run()
{
  m_result = phish_downloadDBAsXML();
  QCustomEvent *ev = new QCustomEvent(KarpionXMLUpdateEvent);
  QApplication::postEvent(m_caller, ev);
  exit();
}

void KarpionCheckURLThread::run()
{
  m_result = phish_checkURL(m_url.ascii(), &m_url_data);
  QCustomEvent *ev = new QCustomEvent(KarpionCheckURLEvent);
  QApplication::postEvent(m_caller, ev);
  exit();
}

void KarpionCheckCountryThread::run()
{
  m_result = phish_checkCountry(m_url.ascii(), &m_url_data);
  QCustomEvent *ev = new QCustomEvent(KarpionCheckCountryEvent);
  QApplication::postEvent(m_caller, ev);
  exit();
}


#include "plugin_karpion.moc"

--- trunk/client/karpion/src/plugin_karpion.desktop #1:2

[Desktop Entry]
Comment=A Konqueror toolbar extension to prevent phishing
Encoding=UTF-8
Icon=karpion
Name=Anti-Phishing Toolbar
Type=Service
X-KDE-Library=karpion
X-KDE-ParentApp=konqueror
X-KDE-PluginInfo-Author=Meni Livne
X-KDE-PluginInfo-Category=Extensions
X-KDE-PluginInfo-Depends=
X-KDE-PluginInfo-Email=livne at kde.org
X-KDE-PluginInfo-EnabledByDefault=true
X-KDE-PluginInfo-License=GPL
X-KDE-PluginInfo-Name=karpion
X-KDE-PluginInfo-Version=0.1.0
X-KDE-PluginInfo-Website=
--- trunk/client/karpion/src/plugin_karpion.h #1:2

/***************************************************************************
 *   Copyright (C) 2006 by Meni Livne <livne at kde.org>                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __PLUGIN_KARPION_H_
#define __PLUGIN_KARPION_H_

#include <qwidget.h>
#include <qcache.h>
#include <qtimer.h>
#include <qthread.h>
#include <kparts/plugin.h>

#include <phish.h>

class KHTMLPart;
class KToolBarLabelAction;
class KAboutApplication;


class KarpionURLData
{
  public:
    KarpionURLData(phish_url_data_t *url_data);
    ~KarpionURLData();
    
    phish_url_data_t *data() const { return m_url_data; };
    
  private:
    phish_url_data_t *m_url_data;
};


class KarpionXMLUpdateThread : public QThread
{
  public:
    KarpionXMLUpdateThread(QObject *caller) : m_caller(caller) {};
    virtual void run();
    phish_result_t result() const { return m_result; };
    
  private:
    QObject *m_caller;
    phish_result_t m_result;
};

class KarpionCheckURLThread : public QThread
{
  public:
    KarpionCheckURLThread(QObject *caller) : m_caller(caller) {};
    virtual void run();
    void setURL(const QString& url) { m_url = url; };
    QString url() const { return m_url; };
    
    phish_result_t result() const { return m_result; };
    phish_url_data_t urlData() const { return m_url_data; };
    
  private:
    QObject *m_caller;
    QString m_url;
    phish_result_t m_result;
    phish_url_data_t m_url_data;
};

class KarpionCheckCountryThread : public QThread
{
  public:
    KarpionCheckCountryThread(QObject *caller) : m_caller(caller) {};
    virtual void run();
    void setURL(const QString& url) { m_url = url; };
    QString url() const { return m_url; };
    
    phish_result_t result() const { return m_result; };
    phish_url_data_t urlData() const { return m_url_data; };
    
  private:
    QObject *m_caller;
    QString m_url;
    phish_result_t m_result;
    phish_url_data_t m_url_data;
};


class KarpionPlugin : public KParts::Plugin
{
  Q_OBJECT
  public:
    KarpionPlugin(QObject* parent = 0, const char *name = 0,
                  const QStringList& = 0);
    virtual ~KarpionPlugin();
    
  protected:
    void customEvent(QCustomEvent *ev);
    
  private slots:
    void delayedSetup();
    
    void checkCurrentURL();
    void updateXML();
    
    void reportPhishing();
    void addToSafeList();
    void configure();
    void about();
    
    void siteInfo();
    
  private:
    void checkURL(const QString& url);
    void checkCountry(const QString& url);
    
    void setRiskLevel(phish_risk_t level);
    void setCheckingRiskLevel();
    void setCountry(const QString& country_code);
    void clearCountry();
    void setCheckingCountry();
    
    void clear();
    
    void readConfig();
    
    phish_url_data_t *m_url_data;
    bool m_safe;
    
    static QCache<KarpionURLData> m_url_cache;
    
    static KConfig *m_config;
    static bool m_config_read;
    static phish_mode_t m_running_mode;
    static bool m_check_country;
    static int m_update_interval;
    
    static QTimer m_update_timer;
    
    KAboutData *m_about_data;
    KAboutApplication *m_aa;
    
    KHTMLPart *m_part;
    
    KarpionXMLUpdateThread xml_thread;
    KarpionCheckURLThread url_thread;
    KarpionCheckCountryThread country_thread;
    
    KToolBarLabelAction *m_country;
    KToolBarLabelAction *m_risk;
    
    KActionMenu *m_menu;
    KAction *m_siteinfo;
    KAction *m_reportphishing;
    KAction *m_addsafelist;
    KAction *m_configure;
    KAction *m_about;
};


#endif // __PLUGIN_KARPION_H_

--- trunk/client/karpion/src/plugin_karpion.rc #1:2

<!DOCTYPE kpartgui>
<kpartplugin name="karpion" library="libkarpionplugin" version="1">
<MenuBar>
 <Menu name="tools"><Text>&amp;Tools</Text>
   <Menu name="karpionmenu"><Text>Anti-Phishing</Text>
     <Action name="karpion_siteinfo"/>
     <Separator/>
     <Action name="karpion_reportphishing"/>
     <Action name="karpion_addsafelist"/>
     <Separator/>
     <Action name="karpion_configure"/>
     <Separator/>
     <Action name="karpion_about"/>
   </Menu>
 </Menu>
</MenuBar>
<ToolBar name="karpionToolBar"><Text>Anti-Phishing</Text>
  <Action name="karpion_sitemenu"/>
  <Separator/>
  <Action name="karpion_risklabel"/>
  <Action name="karpion_siteinfo"/>
  <Separator/>
  <Action name="karpion_countrylabel"/>
</ToolBar>
</kpartplugin>
--- trunk/client/libphish/AUTHORS #1:2

Meni Livne <livne at kde.org>
Boaz Anin <boazanin at gmail.com>
Shahar Karin <shaharka at post.tau.ac.il>
--- trunk/client/libphish/COPYING #1:2

		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
--- trunk/client/libphish/INSTALL #1:2

Basic Installation
==================

   These are generic installation instructions.

   The `configure' shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a `Makefile' in each directory of the package.
It may also create one or more `.h' files containing system-dependent
definitions.  Finally, it creates a shell script `config.status' that
you can run in the future to recreate the current configuration, a file
`config.cache' that saves the results of its tests to speed up
reconfiguring, and a file `config.log' containing compiler output
(useful mainly for debugging `configure').

   If you need to do unusual things to compile the package, please try
to figure out how `configure' could check whether to do them, and mail
diffs or instructions to the address given in the `README' so they can
be considered for the next release.  If at some point `config.cache'
contains results you don't want to keep, you may remove or edit it.

   The file `configure.in' is used to create `configure' by a program
called `autoconf'.  You only need `configure.in' if you want to change
it or regenerate `configure' using a newer version of `autoconf'.

The simplest way to compile this package is:

  1. `cd' to the directory containing the package's source code and type
     `./configure' to configure the package for your system.  If you're
     using `csh' on an old version of System V, you might need to type
     `sh ./configure' instead to prevent `csh' from trying to execute
     `configure' itself.

     Running `configure' takes a while.  While running, it prints some
     messages telling which features it is checking for.

  2. Type `make' to compile the package.

  3. Type `make install' to install the programs and any data files and
     documentation.

  4. You can remove the program binaries and object files from the
     source code directory by typing `make clean'.  

Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  You can give `configure'
initial values for variables by setting them in the environment.  Using
a Bourne-compatible shell, you can do that on the command line like
this:
     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure

Or on systems that have the `env' program, you can do it like this:
     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure

Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you must use a version of `make' that
supports the `VPATH' variable, such as GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.

   If you have to use a `make' that does not supports the `VPATH'
variable, you have to compile the package for one architecture at a time
in the source code directory.  After you have installed the package for
one architecture, use `make distclean' before reconfiguring for another
architecture.

Installation Names
==================

   By default, `make install' will install the package's files in
`/usr/local/bin', `/usr/local/man', etc.  You can specify an
installation prefix other than `/usr/local' by giving `configure' the
option `--prefix=PATH'.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
give `configure' the option `--exec-prefix=PATH', the package will use
PATH as the prefix for installing programs and libraries.
Documentation and other data files will still use the regular prefix.

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.

Optional Features
=================

   Some packages pay attention to `--enable-FEATURE' options to
`configure', where FEATURE indicates an optional part of the package.
They may also pay attention to `--with-PACKAGE' options, where PACKAGE
is something like `gnu-as' or `x' (for the X Window System).  The
`README' should mention any `--enable-' and `--with-' options that the
package recognizes.

   For packages that use the X Window System, `configure' can usually
find the X include and library files automatically, but if it doesn't,
you can use the `configure' options `--x-includes=DIR' and
`--x-libraries=DIR' to specify their locations.

Specifying the System Type
==========================

   There may be some features `configure' can not figure out
automatically, but needs to determine by the type of host the package
will run on.  Usually `configure' can figure that out, but if it prints
a message saying it can not guess the host type, give it the
`--host=TYPE' option.  TYPE can either be a short name for the system
type, such as `sun4', or a canonical name with three fields:
     CPU-COMPANY-SYSTEM

See the file `config.sub' for the possible values of each field.  If
`config.sub' isn't included in this package, then this package doesn't
need to know the host type.

   If you are building compiler tools for cross-compiling, you can also
use the `--target=TYPE' option to select the type of system they will
produce code for and the `--build=TYPE' option to select the type of
system on which you are compiling the package.

Sharing Defaults
================

   If you want to set default values for `configure' scripts to share,
you can create a site shell script called `config.site' that gives
default values for variables like `CC', `cache_file', and `prefix'.
`configure' looks for `PREFIX/share/config.site' if it exists, then
`PREFIX/etc/config.site' if it exists.  Or, you can set the
`CONFIG_SITE' environment variable to the location of the site script.
A warning: not all `configure' scripts look for a site script.

Operation Controls
==================

   `configure' recognizes the following options to control how it
operates.

`--cache-file=FILE'
     Use and save the results of the tests in FILE instead of
     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
     debugging `configure'.

`--help'
     Print a summary of the options to `configure', and exit.

`--quiet'
`--silent'
`-q'
     Do not print messages saying which checks are being made.

`--srcdir=DIR'
     Look for the package's source code in directory DIR.  Usually
     `configure' can determine that directory automatically.

`--version'
     Print the version of Autoconf used to generate the `configure'
     script, and exit.

`configure' also accepts some other, not widely useful, options.

--- trunk/client/libphish/Makefile.am #1:2

# not a GNU package. You can remove this line, if
# have all needed files, that a GNU package needs
AUTOMAKE_OPTIONS = foreign 1.4

SUBDIRS = src

bin_SCRIPTS = libphish-config

--- trunk/client/libphish/Makefile.cvs #1:2

default: all

all:
	aclocal
	autoheader
	libtoolize -c -f
	automake -a -c
	autoconf

--- trunk/client/libphish/README #1:2

ABOUT LIBPHISH

Libphish is a library to interact with the Open Phishing Database, providing
a consistent API which browsers and other programs can use to verify the safety
and risk level of URLs.
Libphish is part of the Open Phishing Database project, an effort to create
and maintain and open database of phishing sites in order to protect users,
in addition to providing extensions to browsers that utilise the database.


INSTALLATION

The file 'INSTALL' contains generic installation instructions.
Libphish requires expat, an XML parsing library.
Expat can be obtained at http://expat.sourceforge.net/.

Installation is basically done as usual:
./configure
make
make install

with the latter command being executed as root.


MORE INFORMATION

See the OPDB website at http://opdb.berlios.de/ for general information about
the Open Phishing Database, browser extensions, and contact information and
mailing lists.


--- trunk/client/libphish/configure.in #1:2

AC_INIT(configure.in)

AM_CONFIG_HEADER(config.h)
AM_INIT_AUTOMAKE(libphish, 0.1.0)

AC_LANG_C
AC_PROG_CC
AM_PROG_LIBTOOL

AC_CHECK_LIB(expat, XML_ParserCreate, [], [
  echo
  echo "You're missing expat. libphish requires the expat library."
  echo "See http://expat.sourceforge.net/ for how to get expat."
  echo
  exit -1
])

AC_HEADER_STDC
AC_CHECK_HEADERS(expat.h)

AC_OUTPUT([Makefile src/Makefile libphish-config], [chmod +x libphish-config])

--- trunk/client/libphish/doc/Doxyfile #1:2

# Doxyfile 1.4.4

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------
PROJECT_NAME           = libphish
PROJECT_NUMBER         = 
OUTPUT_DIRECTORY       = D:/Temp/CD/t
CREATE_SUBDIRS         = NO
OUTPUT_LANGUAGE        = English
USE_WINDOWS_ENCODING   = YES
BRIEF_MEMBER_DESC      = YES
REPEAT_BRIEF           = YES
ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the
ALWAYS_DETAILED_SEC    = NO
INLINE_INHERITED_MEMB  = NO
FULL_PATH_NAMES        = NO
STRIP_FROM_PATH        = "C:/Program Files/doxygen/bin/"
STRIP_FROM_INC_PATH    = 
SHORT_NAMES            = NO
JAVADOC_AUTOBRIEF      = NO
MULTILINE_CPP_IS_BRIEF = NO
DETAILS_AT_TOP         = NO
INHERIT_DOCS           = YES
DISTRIBUTE_GROUP_DOC   = NO
SEPARATE_MEMBER_PAGES  = NO
TAB_SIZE               = 2
ALIASES                = 
OPTIMIZE_OUTPUT_FOR_C  = YES
OPTIMIZE_OUTPUT_JAVA   = NO
SUBGROUPING            = YES
#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------
EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = YES
EXTRACT_STATIC         = YES
EXTRACT_LOCAL_CLASSES  = YES
EXTRACT_LOCAL_METHODS  = YES
HIDE_UNDOC_MEMBERS     = NO
HIDE_UNDOC_CLASSES     = NO
HIDE_FRIEND_COMPOUNDS  = NO
HIDE_IN_BODY_DOCS      = NO
INTERNAL_DOCS          = NO
CASE_SENSE_NAMES       = NO
HIDE_SCOPE_NAMES       = NO
SHOW_INCLUDE_FILES     = YES
INLINE_INFO            = YES
SORT_MEMBER_DOCS       = NO
SORT_BRIEF_DOCS        = NO
SORT_BY_SCOPE_NAME     = NO
GENERATE_TODOLIST      = NO
GENERATE_TESTLIST      = NO
GENERATE_BUGLIST       = NO
GENERATE_DEPRECATEDLIST= NO
ENABLED_SECTIONS       = 
MAX_INITIALIZER_LINES  = 30
SHOW_USED_FILES        = YES
SHOW_DIRECTORIES       = NO
FILE_VERSION_FILTER    = 
#---------------------------------------------------------------------------
# configuration options related to warning and progress messages
#---------------------------------------------------------------------------
QUIET                  = NO
WARNINGS               = YES
WARN_IF_UNDOCUMENTED   = YES
WARN_IF_DOC_ERROR      = YES
WARN_NO_PARAMDOC       = NO
WARN_FORMAT            = "$file:$line: $text"
WARN_LOGFILE           = 
#---------------------------------------------------------------------------
# configuration options related to the input files
#---------------------------------------------------------------------------
INPUT                  = D:/Temp/CD/t/phish.h
FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.d \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.idl \
                         *.odl \
                         *.cs \
                         *.php \
                         *.php3 \
                         *.inc \
                         *.m \
                         *.mm \
                         *.dox
RECURSIVE              = NO
EXCLUDE                = 
EXCLUDE_SYMLINKS       = NO
EXCLUDE_PATTERNS       = 
EXAMPLE_PATH           = 
EXAMPLE_PATTERNS       = *
EXAMPLE_RECURSIVE      = NO
IMAGE_PATH             = 
INPUT_FILTER           = 
FILTER_PATTERNS        = 
FILTER_SOURCE_FILES    = NO
#---------------------------------------------------------------------------
# configuration options related to source browsing
#---------------------------------------------------------------------------
SOURCE_BROWSER         = NO
INLINE_SOURCES         = NO
STRIP_CODE_COMMENTS    = YES
REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = YES
USE_HTAGS              = NO
VERBATIM_HEADERS       = YES
#---------------------------------------------------------------------------
# configuration options related to the alphabetical class index
#---------------------------------------------------------------------------
ALPHABETICAL_INDEX     = NO
COLS_IN_ALPHA_INDEX    = 5
IGNORE_PREFIX          = 
#---------------------------------------------------------------------------
# configuration options related to the HTML output
#---------------------------------------------------------------------------
GENERATE_HTML          = YES
HTML_OUTPUT            = html
HTML_FILE_EXTENSION    = .html
HTML_HEADER            = 
HTML_FOOTER            = 
HTML_STYLESHEET        = 
HTML_ALIGN_MEMBERS     = YES
GENERATE_HTMLHELP      = NO
CHM_FILE               = 
HHC_LOCATION           = 
GENERATE_CHI           = NO
BINARY_TOC             = NO
TOC_EXPAND             = NO
DISABLE_INDEX          = NO
ENUM_VALUES_PER_LINE   = 4
GENERATE_TREEVIEW      = YES
TREEVIEW_WIDTH         = 250
#---------------------------------------------------------------------------
# configuration options related to the LaTeX output
#---------------------------------------------------------------------------
GENERATE_LATEX         = NO
LATEX_OUTPUT           = latex
LATEX_CMD_NAME         = latex
MAKEINDEX_CMD_NAME     = makeindex
COMPACT_LATEX          = NO
PAPER_TYPE             = a4wide
EXTRA_PACKAGES         = 
LATEX_HEADER           = 
PDF_HYPERLINKS         = NO
USE_PDFLATEX           = NO
LATEX_BATCHMODE        = NO
LATEX_HIDE_INDICES     = NO
#---------------------------------------------------------------------------
# configuration options related to the RTF output
#---------------------------------------------------------------------------
GENERATE_RTF           = YES
RTF_OUTPUT             = rtf
COMPACT_RTF            = NO
RTF_HYPERLINKS         = YES
RTF_STYLESHEET_FILE    = 
RTF_EXTENSIONS_FILE    = 
#---------------------------------------------------------------------------
# configuration options related to the man page output
#---------------------------------------------------------------------------
GENERATE_MAN           = NO
MAN_OUTPUT             = man
MAN_EXTENSION          = .3
MAN_LINKS              = NO
#---------------------------------------------------------------------------
# configuration options related to the XML output
#---------------------------------------------------------------------------
GENERATE_XML           = NO
XML_OUTPUT             = xml
XML_SCHEMA             = 
XML_DTD                = 
XML_PROGRAMLISTING     = YES
#---------------------------------------------------------------------------
# configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------
GENERATE_AUTOGEN_DEF   = NO
#---------------------------------------------------------------------------
# configuration options related to the Perl module output
#---------------------------------------------------------------------------
GENERATE_PERLMOD       = NO
PERLMOD_LATEX          = NO
PERLMOD_PRETTY         = YES
PERLMOD_MAKEVAR_PREFIX = 
#---------------------------------------------------------------------------
# Configuration options related to the preprocessor   
#---------------------------------------------------------------------------
ENABLE_PREPROCESSING   = NO
MACRO_EXPANSION        = NO
EXPAND_ONLY_PREDEF     = NO
SEARCH_INCLUDES        = YES
INCLUDE_PATH           = 
INCLUDE_FILE_PATTERNS  = 
PREDEFINED             = 
EXPAND_AS_DEFINED      = 
SKIP_FUNCTION_MACROS   = YES
#---------------------------------------------------------------------------
# Configuration::additions related to external references   
#---------------------------------------------------------------------------
TAGFILES               = 
GENERATE_TAGFILE       = 
ALLEXTERNALS           = NO
EXTERNAL_GROUPS        = YES
PERL_PATH              = /usr/bin/perl
#---------------------------------------------------------------------------
# Configuration options related to the dot tool   
#---------------------------------------------------------------------------
CLASS_DIAGRAMS         = YES
HIDE_UNDOC_RELATIONS   = YES
HAVE_DOT               = NO
CLASS_GRAPH            = YES
COLLABORATION_GRAPH    = YES
GROUP_GRAPHS           = YES
UML_LOOK               = NO
TEMPLATE_RELATIONS     = NO
INCLUDE_GRAPH          = YES
INCLUDED_BY_GRAPH      = YES
CALL_GRAPH             = NO
GRAPHICAL_HIERARCHY    = YES
DIRECTORY_GRAPH        = YES
DOT_IMAGE_FORMAT       = png
DOT_PATH               = 
DOTFILE_DIRS           = 
MAX_DOT_GRAPH_WIDTH    = 1024
MAX_DOT_GRAPH_HEIGHT   = 1024
MAX_DOT_GRAPH_DEPTH    = 1000
DOT_TRANSPARENT        = NO
DOT_MULTI_TARGETS      = NO
GENERATE_LEGEND        = YES
DOT_CLEANUP            = YES
#---------------------------------------------------------------------------
# Configuration::additions related to the search engine   
#---------------------------------------------------------------------------
SEARCHENGINE           = NO
--- trunk/client/libphish/doc/annotated.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Structures</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindexHL" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>libphish Data Structures</h1>Here are the data structures with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structphish__url__data__t.html">phish_url_data_t</a></td><td class="indexvalue"></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/doxygen.css #1:2

BODY,H1,H2,H3,H4,H5,H6,P,CENTER,TD,TH,UL,DL,DIV {
	font-family: Geneva, Arial, Helvetica, sans-serif;
}
BODY,TD {
       font-size: 90%;
}
H1 {
	text-align: center;
       font-size: 160%;
}
H2 {
       font-size: 120%;
}
H3 {
       font-size: 100%;
}
CAPTION { font-weight: bold }
DIV.qindex {
	width: 100%;
	background-color: #eeeeff;
	border: 1px solid #b0b0b0;
	text-align: center;
	margin: 2px;
	padding: 2px;
	line-height: 140%;
}
DIV.nav {
	width: 100%;
	background-color: #eeeeff;
	border: 1px solid #b0b0b0;
	text-align: center;
	margin: 2px;
	padding: 2px;
	line-height: 140%;
}
DIV.navtab {
       background-color: #eeeeff;
       border: 1px solid #b0b0b0;
       text-align: center;
       margin: 2px;
       margin-right: 15px;
       padding: 2px;
}
TD.navtab {
       font-size: 70%;
}
A.qindex {
       text-decoration: none;
       font-weight: bold;
       color: #1A419D;
}
A.qindex:visited {
       text-decoration: none;
       font-weight: bold;
       color: #1A419D
}
A.qindex:hover {
	text-decoration: none;
	background-color: #ddddff;
}
A.qindexHL {
	text-decoration: none;
	font-weight: bold;
	background-color: #6666cc;
	color: #ffffff;
	border: 1px double #9295C2;
}
A.qindexHL:hover {
	text-decoration: none;
	background-color: #6666cc;
	color: #ffffff;
}
A.qindexHL:visited { text-decoration: none; background-color: #6666cc; color: #ffffff }
A.el { text-decoration: none; font-weight: bold }
A.elRef { font-weight: bold }
A.code:link { text-decoration: none; font-weight: normal; color: #0000FF}
A.code:visited { text-decoration: none; font-weight: normal; color: #0000FF}
A.codeRef:link { font-weight: normal; color: #0000FF}
A.codeRef:visited { font-weight: normal; color: #0000FF}
A:hover { text-decoration: none; background-color: #f2f2ff }
DL.el { margin-left: -1cm }
.fragment {
       font-family: Fixed, monospace;
       font-size: 95%;
}
PRE.fragment {
	border: 1px solid #CCCCCC;
	background-color: #f5f5f5;
	margin-top: 4px;
	margin-bottom: 4px;
	margin-left: 2px;
	margin-right: 8px;
	padding-left: 6px;
	padding-right: 6px;
	padding-top: 4px;
	padding-bottom: 4px;
}
DIV.ah { background-color: black; font-weight: bold; color: #ffffff; margin-bottom: 3px; margin-top: 3px }
TD.md { background-color: #F4F4FB; font-weight: bold; }
TD.mdPrefix {
       background-color: #F4F4FB;
       color: #606060;
	font-size: 80%;
}
TD.mdname1 { background-color: #F4F4FB; font-weight: bold; color: #602020; }
TD.mdname { background-color: #F4F4FB; font-weight: bold; color: #602020; width: 600px; }
DIV.groupHeader {
       margin-left: 16px;
       margin-top: 12px;
       margin-bottom: 6px;
       font-weight: bold;
}
DIV.groupText { margin-left: 16px; font-style: italic; font-size: 90% }
BODY {
	background: white;
	color: black;
	margin-right: 20px;
	margin-left: 20px;
}
TD.indexkey {
	background-color: #eeeeff;
	font-weight: bold;
	padding-right  : 10px;
	padding-top    : 2px;
	padding-left   : 10px;
	padding-bottom : 2px;
	margin-left    : 0px;
	margin-right   : 0px;
	margin-top     : 2px;
	margin-bottom  : 2px;
	border: 1px solid #CCCCCC;
}
TD.indexvalue {
	background-color: #eeeeff;
	font-style: italic;
	padding-right  : 10px;
	padding-top    : 2px;
	padding-left   : 10px;
	padding-bottom : 2px;
	margin-left    : 0px;
	margin-right   : 0px;
	margin-top     : 2px;
	margin-bottom  : 2px;
	border: 1px solid #CCCCCC;
}
TR.memlist {
   background-color: #f0f0f0; 
}
P.formulaDsp { text-align: center; }
IMG.formulaDsp { }
IMG.formulaInl { vertical-align: middle; }
SPAN.keyword       { color: #008000 }
SPAN.keywordtype   { color: #604020 }
SPAN.keywordflow   { color: #e08000 }
SPAN.comment       { color: #800000 }
SPAN.preprocessor  { color: #806020 }
SPAN.stringliteral { color: #002080 }
SPAN.charliteral   { color: #008080 }
.mdTable {
	border: 1px solid #868686;
	background-color: #F4F4FB;
}
.mdRow {
	padding: 8px 10px;
}
.mdescLeft {
       padding: 0px 8px 4px 8px;
	font-size: 80%;
	font-style: italic;
	background-color: #FAFAFA;
	border-top: 1px none #E0E0E0;
	border-right: 1px none #E0E0E0;
	border-bottom: 1px none #E0E0E0;
	border-left: 1px none #E0E0E0;
	margin: 0px;
}
.mdescRight {
       padding: 0px 8px 4px 8px;
	font-size: 80%;
	font-style: italic;
	background-color: #FAFAFA;
	border-top: 1px none #E0E0E0;
	border-right: 1px none #E0E0E0;
	border-bottom: 1px none #E0E0E0;
	border-left: 1px none #E0E0E0;
	margin: 0px;
}
.memItemLeft {
	padding: 1px 0px 0px 8px;
	margin: 4px;
	border-top-width: 1px;
	border-right-width: 1px;
	border-bottom-width: 1px;
	border-left-width: 1px;
	border-top-color: #E0E0E0;
	border-right-color: #E0E0E0;
	border-bottom-color: #E0E0E0;
	border-left-color: #E0E0E0;
	border-top-style: solid;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	background-color: #FAFAFA;
	font-size: 80%;
}
.memItemRight {
	padding: 1px 8px 0px 8px;
	margin: 4px;
	border-top-width: 1px;
	border-right-width: 1px;
	border-bottom-width: 1px;
	border-left-width: 1px;
	border-top-color: #E0E0E0;
	border-right-color: #E0E0E0;
	border-bottom-color: #E0E0E0;
	border-left-color: #E0E0E0;
	border-top-style: solid;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	background-color: #FAFAFA;
	font-size: 80%;
}
.memTemplItemLeft {
	padding: 1px 0px 0px 8px;
	margin: 4px;
	border-top-width: 1px;
	border-right-width: 1px;
	border-bottom-width: 1px;
	border-left-width: 1px;
	border-top-color: #E0E0E0;
	border-right-color: #E0E0E0;
	border-bottom-color: #E0E0E0;
	border-left-color: #E0E0E0;
	border-top-style: none;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	background-color: #FAFAFA;
	font-size: 80%;
}
.memTemplItemRight {
	padding: 1px 8px 0px 8px;
	margin: 4px;
	border-top-width: 1px;
	border-right-width: 1px;
	border-bottom-width: 1px;
	border-left-width: 1px;
	border-top-color: #E0E0E0;
	border-right-color: #E0E0E0;
	border-bottom-color: #E0E0E0;
	border-left-color: #E0E0E0;
	border-top-style: none;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	background-color: #FAFAFA;
	font-size: 80%;
}
.memTemplParams {
	padding: 1px 0px 0px 8px;
	margin: 4px;
	border-top-width: 1px;
	border-right-width: 1px;
	border-bottom-width: 1px;
	border-left-width: 1px;
	border-top-color: #E0E0E0;
	border-right-color: #E0E0E0;
	border-bottom-color: #E0E0E0;
	border-left-color: #E0E0E0;
	border-top-style: solid;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
       color: #606060;
	background-color: #FAFAFA;
	font-size: 80%;
}
.search     { color: #003399;
              font-weight: bold;
}
FORM.search {
              margin-bottom: 0px;
              margin-top: 0px;
}
INPUT.search { font-size: 75%;
               color: #000080;
               font-weight: normal;
               background-color: #eeeeff;
}
TD.tiny      { font-size: 75%;
}
a {
	color: #252E78;
}
a:visited {
	color: #3D2185;
}
.dirtab { padding: 4px;
          border-collapse: collapse;
          border: 1px solid #b0b0b0;
}
TH.dirtab { background: #eeeeff;
            font-weight: bold;
}
HR { height: 1px;
     border: none;
     border-top: 1px solid black;
}
** trunk/client/libphish/doc/doxygen.png #property svn:mime-type
   + application/octet-stream
--- trunk/client/libphish/doc/files.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: File Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindexHL" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>libphish File List</h1>Here is a list of all files with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="phish_8h.html">phish.h</a> <a href="phish_8h-source.html">[code]</a></td><td class="indexvalue"></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
** trunk/client/libphish/doc/ftv2blank.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2doc.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2folderclosed.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2folderopen.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2lastnode.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2link.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2mlastnode.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2mnode.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2node.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2plastnode.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2pnode.png #property svn:mime-type
   + application/octet-stream
** trunk/client/libphish/doc/ftv2vertline.png #property svn:mime-type
   + application/octet-stream
--- trunk/client/libphish/doc/functions.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindexHL" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindexHL" href="functions.html">All</a> | <a class="qindex" href="functions_vars.html">Variables</a></div>
Here is a list of all struct and union fields with links to the structures/unions they belong to:
<p>
<ul>
<li>comments
: <a class="el" href="structphish__url__data__t.html#o7">phish_url_data_t</a><li>comments_length
: <a class="el" href="structphish__url__data__t.html#o6">phish_url_data_t</a><li>country
: <a class="el" href="structphish__url__data__t.html#o5">phish_url_data_t</a><li>domain
: <a class="el" href="structphish__url__data__t.html#o4">phish_url_data_t</a><li>ip
: <a class="el" href="structphish__url__data__t.html#o2">phish_url_data_t</a><li>path
: <a class="el" href="structphish__url__data__t.html#o3">phish_url_data_t</a><li>risk_level
: <a class="el" href="structphish__url__data__t.html#o0">phish_url_data_t</a><li>server
: <a class="el" href="structphish__url__data__t.html#o1">phish_url_data_t</a><li>suspicious_host
: <a class="el" href="structphish__url__data__t.html#o9">phish_url_data_t</a><li>user_scheme
: <a class="el" href="structphish__url__data__t.html#o8">phish_url_data_t</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/functions_vars.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields - Variables</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindexHL" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindex" href="functions.html">All</a> | <a class="qindexHL" href="functions_vars.html">Variables</a></div>

<p>
<ul>
<li>comments
: <a class="el" href="structphish__url__data__t.html#o7">phish_url_data_t</a><li>comments_length
: <a class="el" href="structphish__url__data__t.html#o6">phish_url_data_t</a><li>country
: <a class="el" href="structphish__url__data__t.html#o5">phish_url_data_t</a><li>domain
: <a class="el" href="structphish__url__data__t.html#o4">phish_url_data_t</a><li>ip
: <a class="el" href="structphish__url__data__t.html#o2">phish_url_data_t</a><li>path
: <a class="el" href="structphish__url__data__t.html#o3">phish_url_data_t</a><li>risk_level
: <a class="el" href="structphish__url__data__t.html#o0">phish_url_data_t</a><li>server
: <a class="el" href="structphish__url__data__t.html#o1">phish_url_data_t</a><li>suspicious_host
: <a class="el" href="structphish__url__data__t.html#o9">phish_url_data_t</a><li>user_scheme
: <a class="el" href="structphish__url__data__t.html#o8">phish_url_data_t</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/globals.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindexHL" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindexHL" href="globals.html">All</a> | <a class="qindex" href="globals_func.html">Functions</a> | <a class="qindex" href="globals_type.html">Typedefs</a> | <a class="qindex" href="globals_enum.html">Enumerations</a> | <a class="qindex" href="globals_eval.html">Enumerator</a></div>
<div class="qindex"><a class="qindex" href="#index_p">p</a></div>

<p>
Here is a list of all functions, variables, defines, enums, and typedefs with links to the files they belong to:
<p>
<h3><a class="anchor" name="index_p">- p -</a></h3><ul>
<li>phish_addToCurrentSafeList()
: <a class="el" href="phish_8h.html#a21">phish.h</a><li>phish_addToSafeList()
: <a class="el" href="phish_8h.html#a23">phish.h</a><li>phish_checkCountry()
: <a class="el" href="phish_8h.html#a13">phish.h</a><li>phish_checkSafeList()
: <a class="el" href="phish_8h.html#a15">phish.h</a><li>phish_checkURL()
: <a class="el" href="phish_8h.html#a12">phish.h</a><li>phish_countryQueryURL()
: <a class="el" href="phish_8h.html#a29">phish.h</a><li>phish_deleteURLData()
: <a class="el" href="phish_8h.html#a14">phish.h</a><li>phish_downloadDBAsXML()
: <a class="el" href="phish_8h.html#a16">phish.h</a><li>phish_getReportingURL()
: <a class="el" href="phish_8h.html#a17">phish.h</a><li>phish_getSafeListData()
: <a class="el" href="phish_8h.html#a20">phish.h</a><li>phish_getSafeListFirst()
: <a class="el" href="phish_8h.html#a18">phish.h</a><li>phish_getSafeListNext()
: <a class="el" href="phish_8h.html#a19">phish.h</a><li>phish_init()
: <a class="el" href="phish_8h.html#a10">phish.h</a><li>phish_localXMLFile()
: <a class="el" href="phish_8h.html#a32">phish.h</a><li>phish_mode_t
: <a class="el" href="phish_8h.html#a41">phish.h</a><li>phish_newSafeList()
: <a class="el" href="phish_8h.html#a22">phish.h</a><li>PHISH_OFFLINE_MODE
: <a class="el" href="phish_8h.html#a41a4">phish.h</a><li>PHISH_ONLINE_MODE
: <a class="el" href="phish_8h.html#a41a3">phish.h</a><li>phish_remoteXMLURL()
: <a class="el" href="phish_8h.html#a31">phish.h</a><li>phish_reportSiteURL()
: <a class="el" href="phish_8h.html#a30">phish.h</a><li>phish_result_t
: <a class="el" href="phish_8h.html#a0">phish.h</a><li>PHISH_RISK_HIGH
: <a class="el" href="phish_8h.html#a42a9">phish.h</a><li>PHISH_RISK_LOW
: <a class="el" href="phish_8h.html#a42a7">phish.h</a><li>PHISH_RISK_MEDIUM
: <a class="el" href="phish_8h.html#a42a8">phish.h</a><li>PHISH_RISK_NONE
: <a class="el" href="phish_8h.html#a42a6">phish.h</a><li>phish_risk_t
: <a class="el" href="phish_8h.html#a42">phish.h</a><li>PHISH_RISK_UNKNOWN
: <a class="el" href="phish_8h.html#a42a5">phish.h</a><li>phish_runningMode()
: <a class="el" href="phish_8h.html#a27">phish.h</a><li>phish_safe_list_entry_t
: <a class="el" href="phish_8h.html#a2">phish.h</a><li>phish_safe_list_t
: <a class="el" href="phish_8h.html#a1">phish.h</a><li>phish_safeListFile()
: <a class="el" href="phish_8h.html#a33">phish.h</a><li>phish_saveSafeList()
: <a class="el" href="phish_8h.html#a25">phish.h</a><li>phish_saveSettings()
: <a class="el" href="phish_8h.html#a26">phish.h</a><li>phish_setCountryQueryURL()
: <a class="el" href="phish_8h.html#a36">phish.h</a><li>phish_setLocalXMLFile()
: <a class="el" href="phish_8h.html#a39">phish.h</a><li>phish_setRemoteXMLURL()
: <a class="el" href="phish_8h.html#a38">phish.h</a><li>phish_setReportSiteURL()
: <a class="el" href="phish_8h.html#a37">phish.h</a><li>phish_setRunningMode()
: <a class="el" href="phish_8h.html#a34">phish.h</a><li>phish_setSafeList()
: <a class="el" href="phish_8h.html#a24">phish.h</a><li>phish_setSafeListFile()
: <a class="el" href="phish_8h.html#a40">phish.h</a><li>phish_setSiteQueryURL()
: <a class="el" href="phish_8h.html#a35">phish.h</a><li>phish_shutdown()
: <a class="el" href="phish_8h.html#a11">phish.h</a><li>phish_siteQueryURL()
: <a class="el" href="phish_8h.html#a28">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/globals_enum.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindexHL" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindex" href="globals.html">All</a> | <a class="qindex" href="globals_func.html">Functions</a> | <a class="qindex" href="globals_type.html">Typedefs</a> | <a class="qindexHL" href="globals_enum.html">Enumerations</a> | <a class="qindex" href="globals_eval.html">Enumerator</a></div>

<p>
<ul>
<li>phish_mode_t
: <a class="el" href="phish_8h.html#a41">phish.h</a><li>phish_risk_t
: <a class="el" href="phish_8h.html#a42">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/globals_eval.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindexHL" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindex" href="globals.html">All</a> | <a class="qindex" href="globals_func.html">Functions</a> | <a class="qindex" href="globals_type.html">Typedefs</a> | <a class="qindex" href="globals_enum.html">Enumerations</a> | <a class="qindexHL" href="globals_eval.html">Enumerator</a></div>

<p>
<ul>
<li>PHISH_OFFLINE_MODE
: <a class="el" href="phish_8h.html#a41a4">phish.h</a><li>PHISH_ONLINE_MODE
: <a class="el" href="phish_8h.html#a41a3">phish.h</a><li>PHISH_RISK_HIGH
: <a class="el" href="phish_8h.html#a42a9">phish.h</a><li>PHISH_RISK_LOW
: <a class="el" href="phish_8h.html#a42a7">phish.h</a><li>PHISH_RISK_MEDIUM
: <a class="el" href="phish_8h.html#a42a8">phish.h</a><li>PHISH_RISK_NONE
: <a class="el" href="phish_8h.html#a42a6">phish.h</a><li>PHISH_RISK_UNKNOWN
: <a class="el" href="phish_8h.html#a42a5">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/globals_func.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindexHL" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindex" href="globals.html">All</a> | <a class="qindexHL" href="globals_func.html">Functions</a> | <a class="qindex" href="globals_type.html">Typedefs</a> | <a class="qindex" href="globals_enum.html">Enumerations</a> | <a class="qindex" href="globals_eval.html">Enumerator</a></div>
<div class="qindex"><a class="qindex" href="#index_p">p</a></div>

<p>

<p>
<h3><a class="anchor" name="index_p">- p -</a></h3><ul>
<li>phish_addToCurrentSafeList()
: <a class="el" href="phish_8h.html#a21">phish.h</a><li>phish_addToSafeList()
: <a class="el" href="phish_8h.html#a23">phish.h</a><li>phish_checkCountry()
: <a class="el" href="phish_8h.html#a13">phish.h</a><li>phish_checkSafeList()
: <a class="el" href="phish_8h.html#a15">phish.h</a><li>phish_checkURL()
: <a class="el" href="phish_8h.html#a12">phish.h</a><li>phish_countryQueryURL()
: <a class="el" href="phish_8h.html#a29">phish.h</a><li>phish_deleteURLData()
: <a class="el" href="phish_8h.html#a14">phish.h</a><li>phish_downloadDBAsXML()
: <a class="el" href="phish_8h.html#a16">phish.h</a><li>phish_getReportingURL()
: <a class="el" href="phish_8h.html#a17">phish.h</a><li>phish_getSafeListData()
: <a class="el" href="phish_8h.html#a20">phish.h</a><li>phish_getSafeListFirst()
: <a class="el" href="phish_8h.html#a18">phish.h</a><li>phish_getSafeListNext()
: <a class="el" href="phish_8h.html#a19">phish.h</a><li>phish_init()
: <a class="el" href="phish_8h.html#a10">phish.h</a><li>phish_localXMLFile()
: <a class="el" href="phish_8h.html#a32">phish.h</a><li>phish_newSafeList()
: <a class="el" href="phish_8h.html#a22">phish.h</a><li>phish_remoteXMLURL()
: <a class="el" href="phish_8h.html#a31">phish.h</a><li>phish_reportSiteURL()
: <a class="el" href="phish_8h.html#a30">phish.h</a><li>phish_runningMode()
: <a class="el" href="phish_8h.html#a27">phish.h</a><li>phish_safeListFile()
: <a class="el" href="phish_8h.html#a33">phish.h</a><li>phish_saveSafeList()
: <a class="el" href="phish_8h.html#a25">phish.h</a><li>phish_saveSettings()
: <a class="el" href="phish_8h.html#a26">phish.h</a><li>phish_setCountryQueryURL()
: <a class="el" href="phish_8h.html#a36">phish.h</a><li>phish_setLocalXMLFile()
: <a class="el" href="phish_8h.html#a39">phish.h</a><li>phish_setRemoteXMLURL()
: <a class="el" href="phish_8h.html#a38">phish.h</a><li>phish_setReportSiteURL()
: <a class="el" href="phish_8h.html#a37">phish.h</a><li>phish_setRunningMode()
: <a class="el" href="phish_8h.html#a34">phish.h</a><li>phish_setSafeList()
: <a class="el" href="phish_8h.html#a24">phish.h</a><li>phish_setSafeListFile()
: <a class="el" href="phish_8h.html#a40">phish.h</a><li>phish_setSiteQueryURL()
: <a class="el" href="phish_8h.html#a35">phish.h</a><li>phish_shutdown()
: <a class="el" href="phish_8h.html#a11">phish.h</a><li>phish_siteQueryURL()
: <a class="el" href="phish_8h.html#a28">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/globals_type.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Data Fields</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindexHL" href="globals.html">Globals</a></div>
<div class="qindex"><a class="qindex" href="globals.html">All</a> | <a class="qindex" href="globals_func.html">Functions</a> | <a class="qindexHL" href="globals_type.html">Typedefs</a> | <a class="qindex" href="globals_enum.html">Enumerations</a> | <a class="qindex" href="globals_eval.html">Enumerator</a></div>

<p>
<ul>
<li>phish_result_t
: <a class="el" href="phish_8h.html#a0">phish.h</a><li>phish_safe_list_entry_t
: <a class="el" href="phish_8h.html#a2">phish.h</a><li>phish_safe_list_t
: <a class="el" href="phish_8h.html#a1">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/index.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish</title></head>
<frameset cols="250,*">
  <frame src="tree.html" name="treefrm">
  <frame src="main.html" name="basefrm">
</frameset>
</html>
--- trunk/client/libphish/doc/main.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindexHL" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>libphish Documentation</h1>
<p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/phish_8h-source.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: phish.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>phish.h</h1><a href="phish_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *   Copyright (C) 2005 Meni Livne &lt;livne at kde.org&gt;                         *</span>
<a name="l00003"></a>00003 <span class="comment"> *   Copyright (C) 2005 Boaz Anin &lt;boazanin at gmail.com&gt;                     *</span>
<a name="l00004"></a>00004 <span class="comment"> *   Copyright (C) 2005 Shahar Karin &lt;shaharka at post.tau.ac.il&gt;             *</span>
<a name="l00005"></a>00005 <span class="comment"> *                                                                         *</span>
<a name="l00006"></a>00006 <span class="comment"> *   This program is free software; you can redistribute it and/or modify  *</span>
<a name="l00007"></a>00007 <span class="comment"> *   it under the terms of the GNU General Public License as published by  *</span>
<a name="l00008"></a>00008 <span class="comment"> *   the Free Software Foundation; either version 2 of the License, or     *</span>
<a name="l00009"></a>00009 <span class="comment"> *   (at your option) any later version.                                   *</span>
<a name="l00010"></a>00010 <span class="comment"> *                                                                         *</span>
<a name="l00011"></a>00011 <span class="comment"> *   This program is distributed in the hope that it will be useful,       *</span>
<a name="l00012"></a>00012 <span class="comment"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *</span>
<a name="l00013"></a>00013 <span class="comment"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *</span>
<a name="l00014"></a>00014 <span class="comment"> *   GNU General Public License for more details.                          *</span>
<a name="l00015"></a>00015 <span class="comment"> *                                                                         *</span>
<a name="l00016"></a>00016 <span class="comment"> *   You should have received a copy of the GNU General Public License     *</span>
<a name="l00017"></a>00017 <span class="comment"> *   along with this program; if not, write to the                         *</span>
<a name="l00018"></a>00018 <span class="comment"> *   Free Software Foundation, Inc.,                                       *</span>
<a name="l00019"></a>00019 <span class="comment"> *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *</span>
<a name="l00020"></a>00020 <span class="comment"> ***************************************************************************/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef __PHISH_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define __PHISH_H</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#define PHISH_LIB_NAME "libphish"</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#define PHISH_LIB_VERSION "0.1.0"</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00036"></a>00036 
<a name="l00038"></a>00038 <span class="preprocessor">#define PHISH_SUCCESS 0</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#define PHISH_ERR_NOT_INITIALISED 1</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#define PHISH_ERR_MEMORY 2</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#define PHISH_ERR_SETTINGS 3</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="preprocessor">#define PHISH_ERR_MALFORMED_URL 11</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="preprocessor">#define PHISH_ERR_TCP_CONNECT 21</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#define PHISH_ERR_SOCK_READ 22</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#define PHISH_ERR_SOCK_WRITE 23</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="preprocessor">#define PHISH_ERR_RESOLVE 24</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00059"></a>00059 <span class="preprocessor">#define PHISH_ERR_HTTP_BAD_HEADER 25</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#define PHISH_ERR_HTTP_BAD_STATUS 26</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#define PHISH_ERR_FILE 31</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="preprocessor">#define PHISH_ERR_FILE_WRITE 32</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#define PHISH_XML_READ_ERROR 41</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#define PHISH_XML_PARSE_ERROR 42</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00074"></a>00074 <span class="preprocessor">#define PHISH_ERR_OPDB_BAD_REPLY 51</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="preprocessor">#define PHISH_XML_NOT_MODIFIED 61</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="preprocessor">#define PHISH_URL_LENGTH_LIMIT 4192</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 
<a name="l00086"></a><a class="code" href="phish_8h.html#a0">00086</a> <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="phish_8h.html#a0">phish_result_t</a>;
<a name="l00087"></a>00087 
<a name="l00089"></a><a class="code" href="phish_8h.html#a41">00089</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="phish_8h.html#a41a3">PHISH_ONLINE_MODE</a>, <a class="code" href="phish_8h.html#a41a4">PHISH_OFFLINE_MODE</a> } <a class="code" href="phish_8h.html#a41">phish_mode_t</a>;
<a name="l00090"></a>00090 
<a name="l00092"></a><a class="code" href="phish_8h.html#a42">00092</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="phish_8h.html#a42a5">PHISH_RISK_UNKNOWN</a>, <a class="code" href="phish_8h.html#a42a6">PHISH_RISK_NONE</a>,
<a name="l00093"></a>00093                <a class="code" href="phish_8h.html#a42a7">PHISH_RISK_LOW</a>, <a class="code" href="phish_8h.html#a42a8">PHISH_RISK_MEDIUM</a>,
<a name="l00094"></a>00094                <a class="code" href="phish_8h.html#a42a9">PHISH_RISK_HIGH</a> } <a class="code" href="phish_8h.html#a42">phish_risk_t</a>;
<a name="l00095"></a>00095 
<a name="l00099"></a><a class="code" href="structphish__url__data__t.html">00099</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00100"></a>00100 <span class="keyword"></span>{
<a name="l00102"></a><a class="code" href="structphish__url__data__t.html#o0">00102</a>   phish_risk_t risk_level;
<a name="l00103"></a>00103 
<a name="l00105"></a><a class="code" href="structphish__url__data__t.html#o1">00105</a>   <span class="keywordtype">int</span> server;
<a name="l00106"></a>00106 
<a name="l00108"></a><a class="code" href="structphish__url__data__t.html#o2">00108</a>   <span class="keywordtype">int</span> ip;
<a name="l00109"></a>00109 
<a name="l00111"></a><a class="code" href="structphish__url__data__t.html#o3">00111</a>   <span class="keywordtype">int</span> path;
<a name="l00112"></a>00112 
<a name="l00114"></a><a class="code" href="structphish__url__data__t.html#o4">00114</a>   <span class="keywordtype">int</span> domain;
<a name="l00115"></a>00115 
<a name="l00119"></a><a class="code" href="structphish__url__data__t.html#o5">00119</a>   <span class="keywordtype">char</span> country[3];
<a name="l00120"></a>00120 
<a name="l00122"></a><a class="code" href="structphish__url__data__t.html#o6">00122</a>   size_t comments_length;
<a name="l00123"></a>00123 
<a name="l00125"></a><a class="code" href="structphish__url__data__t.html#o7">00125</a>   <span class="keywordtype">char</span> *comments;
<a name="l00126"></a>00126 
<a name="l00128"></a><a class="code" href="structphish__url__data__t.html#o8">00128</a>   <span class="keywordtype">int</span> user_scheme;
<a name="l00129"></a>00129 
<a name="l00134"></a><a class="code" href="structphish__url__data__t.html#o9">00134</a>   <span class="keywordtype">int</span> suspicious_host;
<a name="l00135"></a>00135   
<a name="l00136"></a>00136 } <a class="code" href="structphish__url__data__t.html">phish_url_data_t</a>;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00140"></a><a class="code" href="phish_8h.html#a1">00140</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>phish_safelist_t phish_safe_list_t;
<a name="l00141"></a>00141 
<a name="l00143"></a><a class="code" href="phish_8h.html#a2">00143</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>phish_safelist_entry_t phish_safe_list_entry_t;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00154"></a>00154 phish_result_t <a class="code" href="phish_8h.html#a10">phish_init</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *user_agent,
<a name="l00155"></a>00155                           <span class="keyword">const</span> <span class="keywordtype">char</span> *client_version);
<a name="l00156"></a>00156 
<a name="l00160"></a>00160 phish_result_t <a class="code" href="phish_8h.html#a11">phish_shutdown</a>();
<a name="l00161"></a>00161 
<a name="l00168"></a>00168 phish_result_t <a class="code" href="phish_8h.html#a12">phish_checkURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url, <a class="code" href="structphish__url__data__t.html">phish_url_data_t</a> *results);
<a name="l00169"></a>00169 
<a name="l00177"></a>00177 phish_result_t <a class="code" href="phish_8h.html#a13">phish_checkCountry</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url, <a class="code" href="structphish__url__data__t.html">phish_url_data_t</a> *results);
<a name="l00178"></a>00178 
<a name="l00182"></a>00182 phish_result_t <a class="code" href="phish_8h.html#a14">phish_deleteURLData</a>(<a class="code" href="structphish__url__data__t.html">phish_url_data_t</a> *url_data);
<a name="l00183"></a>00183 
<a name="l00189"></a>00189 phish_result_t <a class="code" href="phish_8h.html#a15">phish_checkSafeList</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">int</span> *reply);
<a name="l00190"></a>00190 
<a name="l00198"></a>00198 phish_result_t <a class="code" href="phish_8h.html#a16">phish_downloadDBAsXML</a>();
<a name="l00199"></a>00199 
<a name="l00208"></a>00208 phish_result_t <a class="code" href="phish_8h.html#a17">phish_getReportingURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">char</span> **result);
<a name="l00209"></a>00209 
<a name="l00213"></a>00213 phish_result_t <a class="code" href="phish_8h.html#a18">phish_getSafeListFirst</a>(phish_safe_list_entry_t **entry);
<a name="l00214"></a>00214 
<a name="l00219"></a>00219 phish_result_t <a class="code" href="phish_8h.html#a19">phish_getSafeListNext</a>(phish_safe_list_entry_t *entry,
<a name="l00220"></a>00220                                      phish_safe_list_entry_t **next);
<a name="l00221"></a>00221 
<a name="l00226"></a>00226 phish_result_t <a class="code" href="phish_8h.html#a20">phish_getSafeListData</a>(phish_safe_list_entry_t *entry,
<a name="l00227"></a>00227                                      <span class="keyword">const</span> <span class="keywordtype">char</span> **url);
<a name="l00228"></a>00228 
<a name="l00232"></a>00232 phish_result_t <a class="code" href="phish_8h.html#a21">phish_addToCurrentSafeList</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00233"></a>00233 
<a name="l00237"></a>00237 phish_result_t <a class="code" href="phish_8h.html#a22">phish_newSafeList</a>(phish_safe_list_t **list);
<a name="l00238"></a>00238 
<a name="l00243"></a>00243 phish_result_t <a class="code" href="phish_8h.html#a23">phish_addToSafeList</a>(phish_safe_list_t *list, <span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00244"></a>00244 
<a name="l00248"></a>00248 phish_result_t <a class="code" href="phish_8h.html#a24">phish_setSafeList</a>(phish_safe_list_t *list);
<a name="l00249"></a>00249 
<a name="l00252"></a>00252 phish_result_t <a class="code" href="phish_8h.html#a25">phish_saveSafeList</a>();
<a name="l00253"></a>00253 
<a name="l00256"></a>00256 phish_result_t <a class="code" href="phish_8h.html#a26">phish_saveSettings</a>();
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 
<a name="l00262"></a>00262 phish_result_t <a class="code" href="phish_8h.html#a27">phish_runningMode</a>(phish_mode_t *result);
<a name="l00263"></a>00263 
<a name="l00267"></a>00267 phish_result_t <a class="code" href="phish_8h.html#a28">phish_siteQueryURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00268"></a>00268 
<a name="l00272"></a>00272 phish_result_t <a class="code" href="phish_8h.html#a29">phish_countryQueryURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00273"></a>00273 
<a name="l00277"></a>00277 phish_result_t <a class="code" href="phish_8h.html#a30">phish_reportSiteURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00278"></a>00278 
<a name="l00282"></a>00282 phish_result_t <a class="code" href="phish_8h.html#a31">phish_remoteXMLURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00283"></a>00283 
<a name="l00287"></a>00287 phish_result_t <a class="code" href="phish_8h.html#a32">phish_localXMLFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00288"></a>00288 
<a name="l00292"></a>00292 phish_result_t <a class="code" href="phish_8h.html#a33">phish_safeListFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> **result);
<a name="l00293"></a>00293 
<a name="l00297"></a>00297 phish_result_t <a class="code" href="phish_8h.html#a34">phish_setRunningMode</a>(phish_mode_t mode);
<a name="l00298"></a>00298 
<a name="l00302"></a>00302 phish_result_t <a class="code" href="phish_8h.html#a35">phish_setSiteQueryURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00303"></a>00303 
<a name="l00307"></a>00307 phish_result_t <a class="code" href="phish_8h.html#a36">phish_setCountryQueryURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00308"></a>00308 
<a name="l00312"></a>00312 phish_result_t <a class="code" href="phish_8h.html#a37">phish_setReportSiteURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00313"></a>00313 
<a name="l00317"></a>00317 phish_result_t <a class="code" href="phish_8h.html#a38">phish_setRemoteXMLURL</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *url);
<a name="l00318"></a>00318 
<a name="l00322"></a>00322 phish_result_t <a class="code" href="phish_8h.html#a39">phish_setLocalXMLFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l00323"></a>00323 
<a name="l00327"></a>00327 phish_result_t <a class="code" href="phish_8h.html#a40">phish_setSafeListFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00331"></a>00331 <span class="preprocessor"></span>}
<a name="l00332"></a>00332 <span class="preprocessor">#endif</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span>
<a name="l00334"></a>00334 <span class="preprocessor">#endif </span><span class="comment">/* __PHISH_H */</span>
<a name="l00335"></a>00335 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/phish_8h.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: phish.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>phish.h File Reference</h1>
<p>
<a href="phish_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html">phish_url_data_t</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a0">phish_result_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef phish_safelist_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a1">phish_safe_list_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef phish_safelist_entry_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a41">phish_mode_t</a> { <a class="el" href="phish_8h.html#a41a3">PHISH_ONLINE_MODE</a>, 
<a class="el" href="phish_8h.html#a41a4">PHISH_OFFLINE_MODE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a42">phish_risk_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="phish_8h.html#a42a5">PHISH_RISK_UNKNOWN</a>, 
<a class="el" href="phish_8h.html#a42a6">PHISH_RISK_NONE</a>, 
<a class="el" href="phish_8h.html#a42a7">PHISH_RISK_LOW</a>, 
<a class="el" href="phish_8h.html#a42a8">PHISH_RISK_MEDIUM</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="phish_8h.html#a42a9">PHISH_RISK_HIGH</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a10">phish_init</a> (const char *user_agent, const char *client_version)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a11">phish_shutdown</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a12">phish_checkURL</a> (const char *url, <a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *results)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a13">phish_checkCountry</a> (const char *url, <a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *results)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a14">phish_deleteURLData</a> (<a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *url_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a15">phish_checkSafeList</a> (const char *url, int *reply)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a16">phish_downloadDBAsXML</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a17">phish_getReportingURL</a> (const char *url, char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a18">phish_getSafeListFirst</a> (<a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> **entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a19">phish_getSafeListNext</a> (<a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> *entry, <a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> **next)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a20">phish_getSafeListData</a> (<a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> *entry, const char **url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a21">phish_addToCurrentSafeList</a> (const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a22">phish_newSafeList</a> (<a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> **list)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a23">phish_addToSafeList</a> (<a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> *list, const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a24">phish_setSafeList</a> (<a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> *list)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a25">phish_saveSafeList</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a26">phish_saveSettings</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a27">phish_runningMode</a> (<a class="el" href="phish_8h.html#a41">phish_mode_t</a> *result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a28">phish_siteQueryURL</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a29">phish_countryQueryURL</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a30">phish_reportSiteURL</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a31">phish_remoteXMLURL</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a32">phish_localXMLFile</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a33">phish_safeListFile</a> (const char **result)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a34">phish_setRunningMode</a> (<a class="el" href="phish_8h.html#a41">phish_mode_t</a> mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a35">phish_setSiteQueryURL</a> (const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a36">phish_setCountryQueryURL</a> (const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a37">phish_setReportSiteURL</a> (const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a38">phish_setRemoteXMLURL</a> (const char *url)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a39">phish_setLocalXMLFile</a> (const char *path)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="phish_8h.html#a40">phish_setSafeListFile</a> (const char *path)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0"></a><!-- doxytag: member="phish.h::phish_result_t" ref="a0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int <a class="el" href="phish_8h.html#a0">phish_result_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All library functions return this type, which indicates whether the function succeeded or the type of error that occurred.    </td>
  </tr>
</table>
<a class="anchor" name="a1"></a><!-- doxytag: member="phish.h::phish_safe_list_t" ref="a1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct phish_safelist_t <a class="el" href="phish_8h.html#a1">phish_safe_list_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The safe list     </td>
  </tr>
</table>
<a class="anchor" name="a2"></a><!-- doxytag: member="phish.h::phish_safe_list_entry_t" ref="a2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct phish_safelist_entry_t <a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An entry in the safe list     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a41"></a><!-- doxytag: member="phish.h::phish_mode_t" ref="a41" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="phish_8h.html#a41">phish_mode_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Possible running modes for checking URLs. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a41a3"></a><!-- doxytag: member="PHISH_ONLINE_MODE" ref="a41a3" args="" -->PHISH_ONLINE_MODE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="a41a4"></a><!-- doxytag: member="PHISH_OFFLINE_MODE" ref="a41a4" args="" -->PHISH_OFFLINE_MODE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a42"></a><!-- doxytag: member="phish.h::phish_risk_t" ref="a42" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="phish_8h.html#a42">phish_risk_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Risk level indication. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a42a5"></a><!-- doxytag: member="PHISH_RISK_UNKNOWN" ref="a42a5" args="" -->PHISH_RISK_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42a6"></a><!-- doxytag: member="PHISH_RISK_NONE" ref="a42a6" args="" -->PHISH_RISK_NONE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42a7"></a><!-- doxytag: member="PHISH_RISK_LOW" ref="a42a7" args="" -->PHISH_RISK_LOW</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42a8"></a><!-- doxytag: member="PHISH_RISK_MEDIUM" ref="a42a8" args="" -->PHISH_RISK_MEDIUM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42a9"></a><!-- doxytag: member="PHISH_RISK_HIGH" ref="a42a9" args="" -->PHISH_RISK_HIGH</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a10"></a><!-- doxytag: member="phish.h::phish_init" ref="a10" args="(const char *user_agent, const char *client_version)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_agent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>client_version</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise the library. This function must be called before any other library function can be called. Functions will return PHISH_ERR_NOT_INITIALISED if called without having the library initialised. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_agent</em>&nbsp;</td><td>user agent string of client (browser) used to identify itself </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>client_version</em>&nbsp;</td><td>version string of client (e.g. anti-phishing toolbar version</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11"></a><!-- doxytag: member="phish.h::phish_shutdown" ref="a11" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves settings and shuts the library down. This function should be called when you're finished using the library.    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member="phish.h::phish_checkURL" ref="a12" args="(const char *url, phish_url_data_t *results)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_checkURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>results</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks a URL. The checking resource (i.e. server or local XML file) is determined according to the settings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>complete URL to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>pointer to results structure which will be filled with results of checking the URL</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member="phish.h::phish_checkCountry" ref="a13" args="(const char *url, phish_url_data_t *results)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_checkCountry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>results</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks only the country of a site. Useful for checking a site's country in offline mode, where the other URL data is obtained from the local XML file which was previsouly downloaded. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>complete URL to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>pointer to results structure whose country field will be filled with the country of the given URL</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member="phish.h::phish_deleteURLData" ref="a14" args="(phish_url_data_t *url_data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_deleteURLData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structphish__url__data__t.html">phish_url_data_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url_data</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates memory associated with URL data structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url_data</em>&nbsp;</td><td>pointer to URL data structure to free.</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member="phish.h::phish_checkSafeList" ref="a15" args="(const char *url, int *reply)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_checkSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>reply</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if a URL is in the safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>complete URL to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>pointer to integer which will be assigned 1 if the URL is in the safe list, 0 otherwise</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16"></a><!-- doxytag: member="phish.h::phish_downloadDBAsXML" ref="a16" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_downloadDBAsXML           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Download the sites database as an XML file from the server. If the database hasn't been modified since the last download, no download will happen. <dl compact><dt><b>Returns:</b></dt><dd>PHISH_SUCCESS if the database was updated and the XML file was downloaded and saved successfully, PHISH_XML_NOT_MODIFIED if the database hasn't been modified.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17"></a><!-- doxytag: member="phish.h::phish_getReportingURL" ref="a17" args="(const char *url, char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_getReportingURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a URL of a site to report, return a URL that the client should go to which contains the data required to submit a site report. Use this when you want to report a site by pointing browser to returned URL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>URL of site to report </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>pointer to string which will be allocated and filled with URL to point client to in order to submit the report for this site</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18"></a><!-- doxytag: member="phish.h::phish_getSafeListFirst" ref="a18" args="(phish_safe_list_entry_t **entry)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_getSafeListFirst           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>entry</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the first entry in the safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>will be assigned with pointer to first entry in safe list</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member="phish.h::phish_getSafeListNext" ref="a19" args="(phish_safe_list_entry_t *entry, phish_safe_list_entry_t **next)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_getSafeListNext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>next</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the next entry in the safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>entry before the entry that will be returned </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next</em>&nbsp;</td><td>will be assigned with pointer to entry after entry given above</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member="phish.h::phish_getSafeListData" ref="a20" args="(phish_safe_list_entry_t *entry, const char **url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_getSafeListData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a2">phish_safe_list_entry_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char **&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the URL associated with a safe list entry. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>entry whose URL is requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>will be assigned with URL of safe list entry</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21"></a><!-- doxytag: member="phish.h::phish_addToCurrentSafeList" ref="a21" args="(const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_addToCurrentSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a URL to the currently used safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>URL to add</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22"></a><!-- doxytag: member="phish.h::phish_newSafeList" ref="a22" args="(phish_safe_list_t **list)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_newSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>list</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new, empty safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>will be assigned with newly created safe list</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23"></a><!-- doxytag: member="phish.h::phish_addToSafeList" ref="a23" args="(phish_safe_list_t *list, const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_addToSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>url</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a URL to a safe list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>safe list to add URL to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>URL to add</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member="phish.h::phish_setSafeList" ref="a24" args="(phish_safe_list_t *list)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a1">phish_safe_list_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>list</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the safe list to a new one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>new safe list to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25"></a><!-- doxytag: member="phish.h::phish_saveSafeList" ref="a25" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_saveSafeList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the safe list to the safe list file.    </td>
  </tr>
</table>
<a class="anchor" name="a26"></a><!-- doxytag: member="phish.h::phish_saveSettings" ref="a26" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_saveSettings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the settings to the settings file.    </td>
  </tr>
</table>
<a class="anchor" name="a27"></a><!-- doxytag: member="phish.h::phish_runningMode" ref="a27" args="(phish_mode_t *result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_runningMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a41">phish_mode_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the running mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current running mode</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28"></a><!-- doxytag: member="phish.h::phish_siteQueryURL" ref="a28" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_siteQueryURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the URL used for site queries on the server. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current site query URL</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29"></a><!-- doxytag: member="phish.h::phish_countryQueryURL" ref="a29" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_countryQueryURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the URL used for country queries on the server. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current country query URL</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30"></a><!-- doxytag: member="phish.h::phish_reportSiteURL" ref="a30" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_reportSiteURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the URL used for reporting sites on the server. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current site reporting URL</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31"></a><!-- doxytag: member="phish.h::phish_remoteXMLURL" ref="a31" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_remoteXMLURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the URL to the XML file to download on the server <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current URL of the XML file</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32"></a><!-- doxytag: member="phish.h::phish_localXMLFile" ref="a32" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_localXMLFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the name of the local XML file. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current name of the local XML file</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33"></a><!-- doxytag: member="phish.h::phish_safeListFile" ref="a33" args="(const char **result)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_safeListFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>result</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the name of the safe list file. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>will be assigned with current name of the safe list file</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34"></a><!-- doxytag: member="phish.h::phish_setRunningMode" ref="a34" args="(phish_mode_t mode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setRunningMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a41">phish_mode_t</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the running mode. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>new mode to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35"></a><!-- doxytag: member="phish.h::phish_setSiteQueryURL" ref="a35" args="(const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setSiteQueryURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the site queries URL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>new URL to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36"></a><!-- doxytag: member="phish.h::phish_setCountryQueryURL" ref="a36" args="(const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setCountryQueryURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the country queries URL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>new URL to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37"></a><!-- doxytag: member="phish.h::phish_setReportSiteURL" ref="a37" args="(const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setReportSiteURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the site reporting URL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>new URL to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38"></a><!-- doxytag: member="phish.h::phish_setRemoteXMLURL" ref="a38" args="(const char *url)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setRemoteXMLURL           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>url</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the remote XML file URL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>new URL to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39"></a><!-- doxytag: member="phish.h::phish_setLocalXMLFile" ref="a39" args="(const char *path)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setLocalXMLFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>path</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the local XML file name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>new file name to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a40"></a><!-- doxytag: member="phish.h::phish_setSafeListFile" ref="a40" args="(const char *path)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a0">phish_result_t</a> phish_setSafeListFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>path</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the safe list file name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>new file name to use</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/structphish__url__data__t.html #1:2

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libphish: phish_url_data_t Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>phish_url_data_t Struct Reference</h1><!-- doxytag: class="phish_url_data_t" --><code>#include &lt;<a class="el" href="phish_8h-source.html">phish.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="phish_8h.html#a42">phish_risk_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o0">risk_level</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o1">server</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o2">ip</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o3">path</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o4">domain</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o5">country</a> [3]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o6">comments_length</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o7">comments</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o8">user_scheme</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphish__url__data__t.html#o9">suspicious_host</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Results structure returned by the URL checking functions with data about the URL given.
<p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="o0"></a><!-- doxytag: member="phish_url_data_t::risk_level" ref="o0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="phish_8h.html#a42">phish_risk_t</a> <a class="el" href="structphish__url__data__t.html#o0">phish_url_data_t::risk_level</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Risk level of URL     </td>
  </tr>
</table>
<a class="anchor" name="o1"></a><!-- doxytag: member="phish_url_data_t::server" ref="o1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o1">phish_url_data_t::server</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether the server part of the URL was found to be in the database     </td>
  </tr>
</table>
<a class="anchor" name="o2"></a><!-- doxytag: member="phish_url_data_t::ip" ref="o2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o2">phish_url_data_t::ip</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether the IP address of the server was found to be in the database     </td>
  </tr>
</table>
<a class="anchor" name="o3"></a><!-- doxytag: member="phish_url_data_t::path" ref="o3" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o3">phish_url_data_t::path</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether the path part of the URL was found to be in the database     </td>
  </tr>
</table>
<a class="anchor" name="o4"></a><!-- doxytag: member="phish_url_data_t::domain" ref="o4" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o4">phish_url_data_t::domain</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether the domain of the URL was found to be in the database     </td>
  </tr>
</table>
<a class="anchor" name="o5"></a><!-- doxytag: member="phish_url_data_t::country" ref="o5" args="[3]" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char <a class="el" href="structphish__url__data__t.html#o5">phish_url_data_t::country</a>[3]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Two level country code of country where site is probably located, or "--" if the country is unknown    </td>
  </tr>
</table>
<a class="anchor" name="o6"></a><!-- doxytag: member="phish_url_data_t::comments_length" ref="o6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t <a class="el" href="structphish__url__data__t.html#o6">phish_url_data_t::comments_length</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Length of comments about URL, 0 if no comments     </td>
  </tr>
</table>
<a class="anchor" name="o7"></a><!-- doxytag: member="phish_url_data_t::comments" ref="o7" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* <a class="el" href="structphish__url__data__t.html#o7">phish_url_data_t::comments</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comments about URL, NULL if no comments     </td>
  </tr>
</table>
<a class="anchor" name="o8"></a><!-- doxytag: member="phish_url_data_t::user_scheme" ref="o8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o8">phish_url_data_t::user_scheme</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether URL scheme contains a username, i.e. protocol://user...     </td>
  </tr>
</table>
<a class="anchor" name="o9"></a><!-- doxytag: member="phish_url_data_t::suspicious_host" ref="o9" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="structphish__url__data__t.html#o9">phish_url_data_t::suspicious_host</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Whether the server part of the URL contains characters which are not normally part of a server name (e.g. non-latin characters in international domain names)    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="phish_8h-source.html">phish.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 30 22:31:55 2006 for libphish by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
--- trunk/client/libphish/doc/tree.html #1:2

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=iso-8859-1" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Language" content="en" />
    <link rel="stylesheet" href="doxygen.css">
    <title>TreeView</title>
    <style type="text/css">
    <!--
    .directory { font-size: 10pt; font-weight: bold; }
    .directory h3 { margin: 0px; margin-top: 1em; font-size: 11pt; }
    .directory p { margin: 0px; white-space: nowrap; }
    .directory div { display: none; margin: 0px; }
    .directory img { vertical-align: middle; }
    -->
    </style>
    <script type="text/javascript">
    <!-- // Hide script from old browsers
    
    function toggleFolder(id, imageNode) 
    {
      var folder = document.getElementById(id);
      var l = imageNode.src.length;
      if (imageNode.src.substring(l-20,l)=="ftv2folderclosed.png" || 
          imageNode.src.substring(l-18,l)=="ftv2folderopen.png")
      {
        imageNode = imageNode.previousSibling;
        l = imageNode.src.length;
      }
      if (folder == null) 
      {
      } 
      else if (folder.style.display == "block") 
      {
        if (imageNode != null) 
        {
          imageNode.nextSibling.src = "ftv2folderclosed.png";
          if (imageNode.src.substring(l-13,l) == "ftv2mnode.png")
          {
            imageNode.src = "ftv2pnode.png";
          }
          else if (imageNode.src.substring(l-17,l) == "ftv2mlastnode.png")
          {
            imageNode.src = "ftv2plastnode.png";
          }
        }
        folder.style.display = "none";
      } 
      else 
      {
        if (imageNode != null) 
        {
          imageNode.nextSibling.src = "ftv2folderopen.png";
          if (imageNode.src.substring(l-13,l) == "ftv2pnode.png")
          {
            imageNode.src = "ftv2mnode.png";
          }
          else if (imageNode.src.substring(l-17,l) == "ftv2plastnode.png")
          {
            imageNode.src = "ftv2mlastnode.png";
          }
        }
        folder.style.display = "block";
      }
    }

    // End script hiding -->        
    </script>
  </head>

  <body>
    <div class="directory">
      <h3>libphish</h3>
      <div style="display: block;">
        <p><img src="ftv2pnode.png" alt="o" width=16 height=22 onclick="toggleFolder('folder1', this)"/><img src="ftv2folderclosed.png" alt="+" width=24 height=22 onclick="toggleFolder('folder1', this)"/><a class="el" href="files.html" target="basefrm">File List</a></p>
        <div id="folder1">
          <p><img src="ftv2vertline.png" alt="|" width=16 height=22 /><img src="ftv2lastnode.png" alt="\" width=16 height=22 /><img src="ftv2doc.png" alt="*" width=24 height=22 /><a class="el" href="phish_8h.html" target="basefrm">phish.h</a></p>
        </div>
        <p><img src="ftv2pnode.png" alt="o" width=16 height=22 onclick="toggleFolder('folder2', this)"/><img src="ftv2folderclosed.png" alt="+" width=24 height=22 onclick="toggleFolder('folder2', this)"/><a class="el" href="annotated.html" target="basefrm">Data Structures</a></p>
        <div id="folder2">
          <p><img src="ftv2vertline.png" alt="|" width=16 height=22 /><img src="ftv2lastnode.png" alt="\" width=16 height=22 /><img src="ftv2doc.png" alt="*" width=24 height=22 /><a class="el" href="structphish__url__data__t.html" target="basefrm">phish_url_data_t</a></p>
        </div>
        <p><img src="ftv2node.png" alt="o" width=16 height=22 /><img src="ftv2doc.png" alt="*" width=24 height=22 /><a class="el" href="functions.html" target="basefrm">Data Fields</a></p>
        <p><img src="ftv2lastnode.png" alt="\" width=16 height=22 /><img src="ftv2doc.png" alt="*" width=24 height=22 /><a class="el" href="globals.html" target="basefrm">Globals</a></p>
      </div>
    </div>
  </body>
</html>
--- trunk/client/libphish/libphish-config.in #1:2

#!/bin/sh

prefix="@prefix@"
exec_prefix="@exec_prefix@"
exec_prefix_set=no

usage()
{
    cat <<EOF
Usage: libphish-config [OPTIONS]
Options:
    [--prefix=[DIR]]
    [--exec-prefix=[DIR]]
    [--version]
    [--libs]
    [--cflags]
EOF
    exit $1
}

if test $# -eq 0 ; then
    usage 1 1>&2
fi

while test $# -gt 0 ; do
    case $1 in
        -*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'`
        ;;
        *) optarg=
        ;;
    esac
    
    case $1 in
        --prefix=*)
            prefix="$optarg"
            if test $exec_prefix_set = no ; then
                exec_prefix="$optarg"
            fi
            ;;
        --prefix)
            echo_prefix=yes
            ;;
        --exec-prefix=*)
            exec_prefix=$optarg
            exec_prefix_set=yes
            ;;
        --version)
            echo @VERSION@
            exit 0
            ;;
        --cflags)
            echo_cflags=yes
            ;;
        --libs)
            echo_libs=yes
            ;;
    esac
    shift
done

if test "$echo_prefix" = "yes" ; then
    echo $prefix
fi

if test "$echo_exec_prefix" = "yes" ; then
    echo $exec_prefix
fi

if test "$echo_cflags" = "yes" ; then
    echo -I at includedir@
fi

if test "$echo_libs" = "yes" ; then
    echo -L at libdir@ -lphish
fi

--- trunk/client/libphish/libphish.kdevelop #1:2

<?xml version = '1.0'?>
<kdevelop>
  <general>
    <author>Meni Livne</author>
    <email>livne at kde.org</email>
    <version>0.1.0</version>
    <projectmanagement>KDevAutoProject</projectmanagement>
    <primarylanguage>C</primarylanguage>
    <ignoreparts/>
    <projectdirectory>.</projectdirectory>
    <absoluteprojectpath>false</absoluteprojectpath>
    <description></description>
    <versioncontrol/>
  </general>
  <kdevautoproject>
    <general>
      <activetarget>src/libphish.la</activetarget>
      <useconfiguration>debug</useconfiguration>
    </general>
    <run>
      <mainprogram>src/libphish</mainprogram>
      <directoryradio>executable</directoryradio>
      <runarguments>
        <testregexmatch/>
        <testregexsplit/>
        <testregexjoin/>
        <testnet/>
      </runarguments>
      <customdirectory>/</customdirectory>
      <programargs/>
      <terminal>false</terminal>
      <autocompile>true</autocompile>
      <envvars/>
    </run>
    <configurations>
      <optimized>
        <builddir>optimized</builddir>
        <ccompiler>GccOptions</ccompiler>
        <cxxcompiler>GppOptions</cxxcompiler>
        <f77compiler>G77Options</f77compiler>
        <cflags>-O2 -g0</cflags>
      </optimized>
      <debug>
        <configargs>--enable-debug=full</configargs>
        <builddir>debug</builddir>
        <ccompiler>kdevgccoptions</ccompiler>
        <cxxcompiler>kdevgppoptions</cxxcompiler>
        <f77compiler>kdevpgf77options</f77compiler>
        <cflags>-O0 -g3 -Wall -pedantic -pthread</cflags>
        <envvars/>
        <topsourcedir></topsourcedir>
        <cppflags></cppflags>
        <ldflags>-pthread</ldflags>
        <ccompilerbinary></ccompilerbinary>
        <cxxcompilerbinary></cxxcompilerbinary>
        <f77compilerbinary></f77compilerbinary>
        <cxxflags>-Wall -ansi -pedantic</cxxflags>
        <f77flags></f77flags>
      </debug>
      <default>
        <envvars/>
        <configargs></configargs>
        <builddir></builddir>
        <topsourcedir></topsourcedir>
        <cppflags></cppflags>
        <ldflags>-pthread</ldflags>
        <ccompiler>kdevgccoptions</ccompiler>
        <cxxcompiler>kdevgppoptions</cxxcompiler>
        <f77compiler>kdevpgf77options</f77compiler>
        <ccompilerbinary></ccompilerbinary>
        <cxxcompilerbinary></cxxcompilerbinary>
        <f77compilerbinary></f77compilerbinary>
        <cflags>-pthread</cflags>
        <cxxflags></cxxflags>
        <f77flags></f77flags>
      </default>
    </configurations>
    <make>
      <envvars>
        <envvar value="1" name="WANT_AUTOCONF_2_5" />
        <envvar value="1" name="WANT_AUTOMAKE_1_6" />
      </envvars>
      <abortonerror>true</abortonerror>
      <numberofjobs>1</numberofjobs>
      <dontact>false</dontact>
      <makebin/>
      <prio>0</prio>
    </make>
  </kdevautoproject>
  <kdevdebugger>
    <general>
      <dbgshell>libtool</dbgshell>
      <programargs></programargs>
      <gdbpath></gdbpath>
      <configGdbScript></configGdbScript>
      <runShellScript></runShellScript>
      <runGdbScript></runGdbScript>
      <breakonloadinglibs>true</breakonloadinglibs>
      <separatetty>false</separatetty>
      <floatingtoolbar>false</floatingtoolbar>
    </general>
    <display>
      <staticmembers>false</staticmembers>
      <demanglenames>true</demanglenames>
      <outputradix>10</outputradix>
    </display>
  </kdevdebugger>
  <kdevdoctreeview>
    <ignoretocs>
      <toc>ada</toc>
      <toc>ada_bugs_gcc</toc>
      <toc>bash</toc>
      <toc>bash_bugs</toc>
      <toc>clanlib</toc>
      <toc>fortran_bugs_gcc</toc>
      <toc>gnome1</toc>
      <toc>gnustep</toc>
      <toc>gtk</toc>
      <toc>gtk_bugs</toc>
      <toc>haskell</toc>
      <toc>haskell_bugs_ghc</toc>
      <toc>java_bugs_gcc</toc>
      <toc>java_bugs_sun</toc>
      <toc>kde2book</toc>
      <toc>libstdc++</toc>
      <toc>opengl</toc>
      <toc>pascal_bugs_fp</toc>
      <toc>php</toc>
      <toc>php_bugs</toc>
      <toc>perl</toc>
      <toc>perl_bugs</toc>
      <toc>python</toc>
      <toc>python_bugs</toc>
      <toc>qt-kdev3</toc>
      <toc>ruby</toc>
      <toc>ruby_bugs</toc>
      <toc>sdl</toc>
      <toc>stl</toc>
      <toc>sw</toc>
      <toc>w3c-dom-level2-html</toc>
      <toc>w3c-svg</toc>
      <toc>w3c-uaag10</toc>
      <toc>wxwidgets_bugs</toc>
    </ignoretocs>
    <ignoreqt_xml>
      <toc>Guide to the Qt Translation Tools</toc>
      <toc>Qt Assistant Manual</toc>
      <toc>Qt Designer Manual</toc>
      <toc>Qt Reference Documentation</toc>
      <toc>qmake User Guide</toc>
    </ignoreqt_xml>
    <ignoredoxygen>
      <toc>KDE Libraries (Doxygen)</toc>
    </ignoredoxygen>
  </kdevdoctreeview>
  <kdevfilecreate>
    <filetypes/>
    <useglobaltypes>
      <type ext="c" />
      <type ext="h" />
    </useglobaltypes>
  </kdevfilecreate>
  <kdevcppsupport>
    <references/>
    <codecompletion>
      <includeGlobalFunctions>true</includeGlobalFunctions>
      <includeTypes>true</includeTypes>
      <includeEnums>true</includeEnums>
      <includeTypedefs>false</includeTypedefs>
      <automaticCodeCompletion>true</automaticCodeCompletion>
      <automaticArgumentsHint>true</automaticArgumentsHint>
      <automaticHeaderCompletion>true</automaticHeaderCompletion>
      <codeCompletionDelay>250</codeCompletionDelay>
      <argumentsHintDelay>400</argumentsHintDelay>
      <headerCompletionDelay>250</headerCompletionDelay>
    </codecompletion>
    <qt>
      <used>false</used>
      <version>3</version>
      <root>/usr/lib/qt</root>
    </qt>
    <creategettersetter>
      <prefixGet></prefixGet>
      <prefixSet>set</prefixSet>
      <prefixVariable>m_,_</prefixVariable>
      <parameterName>theValue</parameterName>
      <inlineGet>true</inlineGet>
      <inlineSet>true</inlineSet>
    </creategettersetter>
  </kdevcppsupport>
  <kdevfileview>
    <groups>
      <hidenonprojectfiles>false</hidenonprojectfiles>
      <hidenonlocation>false</hidenonlocation>
    </groups>
    <tree>
      <hidepatterns>*.o,*.lo,CVS</hidepatterns>
      <hidenonprojectfiles>false</hidenonprojectfiles>
    </tree>
  </kdevfileview>
  <cppsupportpart>
    <filetemplates>
      <interfacesuffix>.h</interfacesuffix>
      <implementationsuffix>.cpp</implementationsuffix>
    </filetemplates>
  </cppsupportpart>
  <kdevdocumentation>
    <projectdoc>
      <docsystem></docsystem>
      <docurl></docurl>
      <usermanualurl></usermanualurl>
    </projectdoc>
  </kdevdocumentation>
  <ctagspart>
    <customArguments/>
    <customTagfilePath/>
  </ctagspart>
  <dist>
    <custom>false</custom>
    <bzip>false</bzip>
    <archname/>
    <appname>libphish</appname>
    <version>0.1.0</version>
    <release>1</release>
    <vendor/>
    <licence/>
    <summary/>
    <group/>
    <packager/>
    <description/>
    <changelog/>
    <devpackage>false</devpackage>
    <docspackage>false</docspackage>
    <appicon>false</appicon>
    <arch>2</arch>
    <genHTML>false</genHTML>
    <useRPM>false</useRPM>
    <ftpkde>false</ftpkde>
    <appskde>false</appskde>
    <url/>
  </dist>
</kdevelop>
--- trunk/client/libphish/src/Makefile.am #1:2


# set the include path found by configure
INCLUDES= $(all_includes)

# the library search path.

include_HEADERS = phish.h

noinst_HEADERS = phish_settings.h phish_local_xml.h phish_opdb_server.h \
                 phish_safelist.h phish_util_ll.h phish_util_net.h \
                 phish_util_url.h


lib_LTLIBRARIES = libphish.la
libphish_la_SOURCES = phish.c phish_settings.c phish_local_xml.c \
	phish_opdb_server.c phish_safelist.c phish_util_ll.c phish_util_net.c phish_util_url.c

libphish_la_LDFLAGS = -version-info 1:0:1

--- trunk/client/libphish/src/phish.c #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>


#ifdef WIN32
#include <direct.h>
#include <winsock2.h>
#else
#include <unistd.h>
#include <pwd.h>
#endif

#include <sys/stat.h>

#include "phish.h"
#include "phish_settings.h"
#include "phish_opdb_server.h"
#include "phish_local_xml.h"
#include "phish_safelist.h"
#include "phish_util_net.h"

/* name of directory used to store phish-related files: settings, the safe
   list file and the downloaded XML file */
#define PHISH_DIR ".phish"

/* name of settings file */
#define PHISH_SETTINGS_FILE "phishrc"

static char *phish_dir_path; /* full path to phish directory */

static char *settings_path = NULL; /* full path to settings file */
static char *safelist_path = NULL; /* full path to safe list file */
static char *local_xml_path = NULL; /* full path to local XML file */

static char *client_ua = NULL; /* client identification string */
static char *full_ua = NULL; /* full user agent used to send to server */

static phish_settings_t settings; /* global settings */

static phish_util_url_t query_url; /* parsed URL for site queries */
static phish_util_url_t country_url; /* parsed URL for country queries */
static phish_util_url_t reporting_url; /* parsed URL for reporting sites */
static phish_util_url_t xml_url; /* parsed URL for XML file on server */

static phish_safelist_t *safelist; /* global safe list */

/* This is incremented each time phish_init() is called, and decremented each
   time phish_shutdown() is called. This is needed for browsers with support
   for multiple tabs and/or windows, each of which containing a toolbar which
   uses this library, for knowing when to actually shut the library down. */
static unsigned int refcount = 0;


static void cleanup()
{
  phish_util_deleteURL(&xml_url);
  phish_util_deleteURL(&reporting_url);
  phish_util_deleteURL(&country_url);
  phish_util_deleteURL(&query_url);
  
  free(full_ua);
  free(client_ua);
  free(local_xml_path);
  free(safelist_path);
  free(settings_path);
  
  phish_settings_free(&settings);
}

phish_result_t phish_init(const char *user_agent,
                          const char *client_version)
{
  char *home_dir;
  
#ifdef WIN32
  WSADATA wsaData;
  home_dir = getenv("APPDATA");
#else
  struct passwd *pw = getpwuid(getuid());
  home_dir = pw->pw_dir;
#endif
  
  if (refcount > 0)
  {
    refcount++;
    return PHISH_SUCCESS;
  }
  
  /* initialise URL structures */
  phish_util_initURL(&query_url);
  phish_util_initURL(&country_url);
  phish_util_initURL(&reporting_url);
  phish_util_initURL(&xml_url);
  
  /* find out phish directory path */
  phish_dir_path = malloc(strlen(home_dir) + 1 + strlen(PHISH_DIR) + 1);
  
  if (phish_dir_path == NULL)
  {
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(phish_dir_path, "%s/%s", home_dir, PHISH_DIR);
  
  /* find out settings file path */
  settings_path = malloc(strlen(phish_dir_path) + 1 +
                         strlen(PHISH_SETTINGS_FILE) + 1);
  if (settings_path == NULL)
  {
    free(phish_dir_path);
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(settings_path, "%s/%s", phish_dir_path, PHISH_SETTINGS_FILE);
  
  /* create phish directory if it doesn't yet exist under user's home dir */
#ifndef WIN32
  mkdir(phish_dir_path, 0700);
#else
  mkdir(phish_dir_path);
#endif
  
  /* load settings */
  phish_settings_init(&settings);
  phish_settings_load(&settings, settings_path);
  
  /* find out safe list file path */
  safelist_path = malloc(strlen(phish_dir_path) + 1 +
                         strlen(phish_settings_safeListFile(&settings)) + 1);
  if (safelist_path == NULL)
  {
    cleanup();
    free(phish_dir_path);
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(safelist_path, "%s/%s", phish_dir_path,
          phish_settings_safeListFile(&settings));
  
  /* find out local XML file path */
  local_xml_path = malloc(strlen(phish_dir_path) + 1 +
                          strlen(phish_settings_localXMLFile(&settings)) + 1);
  if (local_xml_path == NULL)
  {
    cleanup();
    free(phish_dir_path);
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(local_xml_path, "%s/%s", phish_dir_path,
          phish_settings_localXMLFile(&settings));
  
  free(phish_dir_path);
  
  /* parse URL of query script on server */
  if (phish_util_strToURL(phish_settings_siteQueryURL(&settings),
                                                 &query_url) != PHISH_SUCCESS)
  {
    cleanup();
    return PHISH_ERR_SETTINGS;
  }
  
  if (query_url.port == -1)
    query_url.port = 80;
  
  /* parse URL of country query script on server */
  if (phish_util_strToURL(phish_settings_countryQueryURL(&settings),
                                               &country_url) != PHISH_SUCCESS)
  {
    cleanup();
    return PHISH_ERR_SETTINGS;
  }
  
  if (country_url.port == -1)
    country_url.port = 80;
  
  /* parse URL to report sites on server */
  if (phish_util_strToURL(phish_settings_reportSiteURL(&settings),
                                             &reporting_url) != PHISH_SUCCESS)
  {
    cleanup();
    return PHISH_ERR_SETTINGS;
  }
  
  if (reporting_url.port == -1)
    reporting_url.port = 80;
  
  /* parse URL of XML file to download */
  if (phish_util_strToURL(phish_settings_remoteXMLURL(&settings),
                                                   &xml_url) != PHISH_SUCCESS)
  {
    cleanup();
    return PHISH_ERR_SETTINGS;
  }
  
  if (xml_url.port == -1)
    xml_url.port = 80;
  
  client_ua = malloc(strlen(client_version) + 2 + strlen(PHISH_LIB_NAME) + 1 +
                     strlen(PHISH_LIB_VERSION) + 1);
  if (client_ua == NULL)
  {
    cleanup();
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(client_ua, "%s; %s/%s", client_version, PHISH_LIB_NAME,
          PHISH_LIB_VERSION);
  
  full_ua = malloc(strlen(user_agent) + 2 + strlen(client_ua) + 1 + 1);
  if (full_ua == NULL)
  {
    cleanup();
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(full_ua, "%s (%s)", user_agent, client_ua);
  
  /* open safe list */
  phish_safelist_open(safelist_path, &safelist);
  
#ifdef WIN32
  WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
#endif
  
  refcount++;
  return PHISH_SUCCESS;
}

phish_result_t phish_shutdown()
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  else if (refcount > 1)
  {
    refcount--;
    return PHISH_SUCCESS;
  }
  
  phish_safelist_write(safelist_path, safelist);
  phish_safelist_close(safelist);
  
  phish_settings_write(&settings, settings_path);
  
  cleanup();

#ifdef WIN32
  WSACleanup();
#endif

  refcount--;
  return PHISH_SUCCESS;
}

static void initURLData(phish_url_data_t *url_data)
{
  url_data->risk_level = PHISH_RISK_UNKNOWN;
  url_data->server = -1;
  url_data->ip = -1;
  url_data->path = -1;
  url_data->domain = -1;
  url_data->comments_length = 0;
  url_data->comments = NULL;
  url_data->user_scheme = -1;
  url_data->suspicious_host = -1;
  strcpy(url_data->country, "--");
}

static phish_risk_t calculateRisk(phish_url_data_t *results)
{
  int rating = 1;
  
  if (results->server == -1)
  {
    if (results->ip == 1 && results->path == 1)
      rating = 7;
    else if (results->ip == 1)
      rating = 5;
  }
  else if (results->domain != 1)
  {
    if (results->ip == 1 && results->server == 1 && results->path == 1)
      rating = 9;
    else if (results->ip == 1 && (results->server == 1 || results->path == 1))
      rating = 7;
    else if (results->server == 1 && results->path == 1)
      rating = 8;
    else if (results->server == 1)
      rating = 6;
    else if (results->ip == 1)
      rating = 5;
  }
  else
  {
    if (results->ip == 1 && results->server == 1 && results->path == 1)
      rating = 9;
    else if (results->ip == 1 && results->server == 1)
      rating = 7;
    else if (results->server == 1 && results->path == 1)
      rating = 8;
    else if (results->server == 1 || (results->ip == 1 && results->path == 1))
      rating = 6;
    else if (results->ip == 1)
      rating = 4;
    else if (results->path == 1)
      rating = 5;
    else
      rating = 3;
  }
  
  if (results->user_scheme == 1)
    rating++;
  if (results->suspicious_host == 1)
    rating++;
  
  if (rating > 10)
    rating = 10;
  
  if (rating == 1)
    return PHISH_RISK_LOW;
  if (rating == 2 || rating == 3)
    return PHISH_RISK_MEDIUM;
  else
    return PHISH_RISK_HIGH;
}

phish_result_t phish_checkURL(const char *url, phish_url_data_t *results)
{
  char *ip;
  phish_util_url_t p_url;
  phish_result_t r;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;

  phish_util_initURL(&p_url);
  
  r = phish_util_strToURL(url, &p_url);
  if (r != PHISH_SUCCESS)
    return r;
  
  /* get IP of host of URL given */
  r = phish_util_hostToIP(p_url.host, &ip);
  if (r != PHISH_SUCCESS) /* the URL does not have a valid IP address */
  {
    phish_util_deleteURL(&p_url);
    return r;
  }
  
  /* initialise results */
  initURLData(results);
  
  switch(phish_settings_runningMode(&settings))
  {
    case PHISH_ONLINE_MODE:
      r = phish_opdbserver_checkURL(&query_url, &p_url, ip, full_ua,
                                    results);
      break;
    case PHISH_OFFLINE_MODE:
      r = phish_localxml_checkURL(local_xml_path, &p_url, ip, results);
      break;
    default:
      break;
  }
  
  phish_util_checkURLScheme(&p_url, results);
  
  phish_util_deleteURL(&p_url);
  free(ip);
  
  if (r == PHISH_SUCCESS)
    results->risk_level = calculateRisk(results);
  
  return r;
}

phish_result_t phish_checkCountry(const char *url, phish_url_data_t *results)
{
  char *ip;
  phish_util_url_t p_url;
  phish_result_t r;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;

  phish_util_initURL(&p_url);
  
  r = phish_util_strToURL(url, &p_url);
  if (r != PHISH_SUCCESS)
    return r;
  
  /* get IP of host of URL given */
  r = phish_util_hostToIP(p_url.host, &ip);
  if (r != PHISH_SUCCESS) /* the URL does not have a valid IP address */
  {
    phish_util_deleteURL(&p_url);
    return r;
  }
  
  /* initialise results */
  initURLData(results);
  
  r = phish_opdbserver_checkCountry(&country_url, ip, full_ua, results);
  
  phish_util_deleteURL(&p_url);
  free(ip);
  
  return r;
}

phish_result_t phish_deleteURLData(phish_url_data_t *url_data)
{
  free(url_data->comments);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_checkSafeList(const char *url, int *reply)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;

  *reply = phish_safelist_checkURL(url, safelist);

  return PHISH_SUCCESS;
}

phish_result_t phish_downloadDBAsXML()
{
  char *new_etag;
  phish_result_t r;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  r = phish_opdbserver_downloadDBAsXML(&xml_url, full_ua,
                                       local_xml_path,
                                       phish_settings_remoteXMLETag(&settings),
                                       &new_etag);

  if (r == PHISH_SUCCESS)
  {
    phish_settings_setRemoteXMLETag(&settings, new_etag);
    free(new_etag);
  }

  return r;
}

phish_result_t phish_getReportingURL(const char *url, char **result)
{
  phish_result_t r;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  r = phish_opdbserver_getReportingURL(&reporting_url, client_ua,
                                       url, result);
  
  return r;
}

phish_result_t phish_getSafeListFirst(phish_safe_list_entry_t **entry)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *entry = (phish_safe_list_entry_t *)phish_safelist_first(safelist);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_getSafeListNext(phish_safe_list_entry_t *entry,
                                     phish_safe_list_entry_t **next)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *next = (phish_safe_list_entry_t *)
            phish_safelist_next((phish_safelist_entry_t *)entry);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_getSafeListData(phish_safe_list_entry_t *entry,
                                     const char **url)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *url = phish_safelist_entryData((phish_safelist_entry_t *)entry);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_addToCurrentSafeList(const char *url)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  return phish_safelist_add(url, safelist);
}

phish_result_t phish_addToSafeList(phish_safe_list_t *list, const char *url)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;

  return phish_safelist_add(url, (phish_safelist_t *)list);
}

phish_result_t phish_newSafeList(phish_safe_list_t **list)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;

  return phish_safeList_new((phish_safelist_t **)list);
}

phish_result_t phish_setSafeList(phish_safe_list_t *list)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  if (safelist != (phish_safelist_t *)list)
  {
    phish_safelist_close(safelist);
    safelist = (phish_safelist_t *)list;
  }
  
  return PHISH_SUCCESS;
}

phish_result_t phish_saveSafeList()
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  phish_safelist_write(safelist_path, safelist);

  return PHISH_SUCCESS;
}

phish_result_t phish_saveSettings()
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  phish_settings_write(&settings, settings_path);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_runningMode(phish_mode_t *result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_runningMode(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_siteQueryURL(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_siteQueryURL(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_countryQueryURL(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_countryQueryURL(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_reportSiteURL(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_reportSiteURL(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_remoteXMLURL(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_remoteXMLURL(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_localXMLFile(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_localXMLFile(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_safeListFile(const char **result)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  *result = phish_settings_safeListFile(&settings);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setRunningMode(phish_mode_t mode)
{
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  phish_settings_setRunningMode(&settings, mode);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setSiteQueryURL(const char *url)
{
  phish_util_url_t new_url;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  /* parse new URL */
  phish_util_initURL(&new_url);
  if (phish_util_strToURL(url, &new_url) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SETTINGS;
  }
  
  if (new_url.port == -1)
    new_url.port = 80;
  
  phish_settings_setSiteQueryURL(&settings, url);
  
  phish_util_deleteURL(&query_url);
  query_url = new_url;
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setCountryQueryURL(const char *url)
{
  phish_util_url_t new_url;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  /* parse new URL */
  phish_util_initURL(&new_url);
  if (phish_util_strToURL(url, &new_url) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SETTINGS;
  }
  
  if (new_url.port == -1)
    new_url.port = 80;
  
  phish_settings_setCountryQueryURL(&settings, url);
  
  phish_util_deleteURL(&country_url);
  country_url = new_url;
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setReportSiteURL(const char *url)
{
  phish_util_url_t new_url;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  /* parse new URL */
  phish_util_initURL(&new_url);
  if (phish_util_strToURL(url, &new_url) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SETTINGS;
  }
  
  if (new_url.port == -1)
    new_url.port = 80;
  
  phish_settings_setReportSiteURL(&settings, url);
  
  phish_util_deleteURL(&reporting_url);
  reporting_url = new_url;
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setRemoteXMLURL(const char *url)
{
  phish_util_url_t new_url;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  /* parse new URL */
  phish_util_initURL(&new_url);
  if (phish_util_strToURL(url, &new_url) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SETTINGS;
  }
  
  if (new_url.port == -1)
    new_url.port = 80;
  
  phish_settings_setRemoteXMLURL(&settings, url);
  
  phish_util_deleteURL(&xml_url);
  xml_url = new_url;
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setLocalXMLFile(const char *path)
{
  char *new_path;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  new_path = malloc(strlen(phish_dir_path) + 1 + strlen(path) + 1);
  if (new_path == NULL)
  {
    return PHISH_ERR_MEMORY;
  }
  
  phish_settings_setLocalXMLFile(&settings, path);
  
  free(local_xml_path);
  local_xml_path = new_path;
  sprintf(local_xml_path, "%s/%s", phish_dir_path, path);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_setSafeListFile(const char *path)
{
  char *new_path;
  
  if (refcount == 0)
    return PHISH_ERR_NOT_INITIALISED;
  
  new_path = malloc(strlen(phish_dir_path) + 1 + strlen(path) + 1);
  if (new_path == NULL)
  {
    return PHISH_ERR_MEMORY;
  }
  
  phish_settings_setSafeListFile(&settings, path);
  
  /* write and close old safe list */
  phish_safelist_write(safelist_path, safelist);
  phish_safelist_close(safelist);
  
  free(safelist_path);
  safelist_path = new_path;
  sprintf(safelist_path, "%s/%s", phish_dir_path, path);
  
  /* open new safe list */
  phish_safelist_open(safelist_path, &safelist);
  
  return PHISH_SUCCESS;
}

--- trunk/client/libphish/src/phish.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *   Copyright (C) 2005 Boaz Anin <boazanin at gmail.com>                     *
 *   Copyright (C) 2005 Shahar Karin <shaharka at post.tau.ac.il>             *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __PHISH_H
#define __PHISH_H


#ifdef __cplusplus
extern "C" {
#endif


#define PHISH_LIB_NAME "libphish"
#define PHISH_LIB_VERSION "0.1.0"


#include <sys/types.h>

/** Operation was successful */
#define PHISH_SUCCESS 0
/** Library hasn't been initialised */
#define PHISH_ERR_NOT_INITIALISED 1
/** Memory allocation error */
#define PHISH_ERR_MEMORY 2
/** Error in settings */
#define PHISH_ERR_SETTINGS 3

/** A malformed URL was given as parameter */
#define PHISH_ERR_MALFORMED_URL 11

/** Error initiating TCP connection */
#define PHISH_ERR_TCP_CONNECT 21
/** Error reading from socket */
#define PHISH_ERR_SOCK_READ 22
/** Error writing to socket */
#define PHISH_ERR_SOCK_WRITE 23
/** Error resolving a hostname */
#define PHISH_ERR_RESOLVE 24
/** An unexpected HTTP header format was encountered when reading an HTTP
 *  reply from a server */
#define PHISH_ERR_HTTP_BAD_HEADER 25
/** Unexpected HTTP status code received in reply from HTTP server */
#define PHISH_ERR_HTTP_BAD_STATUS 26

/** Error opening or reading from file */
#define PHISH_ERR_FILE 31
/** Error writing to file */
#define PHISH_ERR_FILE_WRITE 32

/** Error reading from XML file */
#define PHISH_XML_READ_ERROR 41
/** Error parsing XML file */
#define PHISH_XML_PARSE_ERROR 42

/** Unexpected reply from OPDB server */
#define PHISH_ERR_OPDB_BAD_REPLY 51

/** Sites XML file on server wasn't modified */
#define PHISH_XML_NOT_MODIFIED 61


#define PHISH_URL_LENGTH_LIMIT 4192


/** All library functions return this type, which indicates whether the
 *  function succeeded or the type of error that occurred.
 */
typedef int phish_result_t;

/** Possible running modes for checking URLs. */
typedef enum { PHISH_ONLINE_MODE, PHISH_OFFLINE_MODE } phish_mode_t;

/** Risk level indication. */
typedef enum { PHISH_RISK_UNKNOWN, PHISH_RISK_NONE,
               PHISH_RISK_LOW, PHISH_RISK_MEDIUM,
               PHISH_RISK_HIGH } phish_risk_t;

/** Results structure returned by the URL checking functions with data about
 *  the URL given.
 */
typedef struct
{
  /** Risk level of URL */
  phish_risk_t risk_level;

  /** Whether the server part of the URL was found to be in the database */
  int server;

  /** Whether the IP address of the server was found to be in the database */
  int ip;

  /** Whether the path part of the URL was found to be in the database */
  int path;

  /** Whether the domain of the URL was found to be in the database */
  int domain;

  /** Two level country code of country where site is probably located, or "--"
   *  if the country is unknown
   */
  char country[3];

  /** Length of comments about URL, 0 if no comments */
  size_t comments_length;

  /** Comments about URL, NULL if no comments */
  char *comments;

  /** Whether URL scheme contains a username, i.e. protocol://user at host... */
  int user_scheme;

  /** Whether the server part of the URL contains characters which are not
   *  normally part of a server name (e.g. non-latin characters in
   *  international domain names)
   */
  int suspicious_host;
  
} phish_url_data_t;


/** The safe list */
typedef struct phish_safelist_t phish_safe_list_t;

/** An entry in the safe list */
typedef struct phish_safelist_entry_t phish_safe_list_entry_t;


/** Initialise the library. This function must be called before any other
 *  library function can be called. Functions will return
 *  PHISH_ERR_NOT_INITIALISED if called without having the library initialised.
 *  @param user_agent user agent string of client (browser) used to identify
 *                    itself
 *  @param client_version version string of client (e.g. anti-phishing
 *                        toolbar version
 */
phish_result_t phish_init(const char *user_agent,
                          const char *client_version);

/** Saves settings and shuts the library down. This function should be called
 *  when you're finished using the library.
 */
phish_result_t phish_shutdown();

/** Checks a URL. The checking resource (i.e. server or local XML file) is
 *  determined according to the settings.
 *  @param url complete URL to check
 *  @param results pointer to results structure which will be filled with
 *                 results of checking the URL
 */
phish_result_t phish_checkURL(const char *url, phish_url_data_t *results);

/** Checks only the country of a site. Useful for checking a site's country
 *  in offline mode, where the other URL data is obtained from the local
 *  XML file which was previsouly downloaded.
 *  @param url complete URL to check
 *  @param results pointer to results structure whose country field will be
 *                 filled with the country of the given URL
 */
phish_result_t phish_checkCountry(const char *url, phish_url_data_t *results);

/** Deallocates memory associated with URL data structure.
 *  @param url_data pointer to URL data structure to free.
 */
phish_result_t phish_deleteURLData(phish_url_data_t *url_data);

/** Checks if a URL is in the safe list.
 *  @param url complete URL to check
 *  @param reply pointer to integer which will be assigned 1 if the URL is in
 *               the safe list, 0 otherwise
 */
phish_result_t phish_checkSafeList(const char *url, int *reply);

/** Download the sites database as an XML file from the server. If the
 *  database hasn't been modified since the last download, no download will
 *  happen.
 *  @return PHISH_SUCCESS if the database was updated and the XML file was
 *          downloaded and saved successfully, PHISH_XML_NOT_MODIFIED if the
 *          database hasn't been modified.
 */
phish_result_t phish_downloadDBAsXML();

/** Given a URL of a site to report, return a URL that the client should go
 *  to which contains the data required to submit a site report. Use this when
 *  you want to report a site by pointing browser to returned URL.
 *  @param url URL of site to report
 *  @param result pointer to string which will be allocated and filled with
 *                URL to point client to in order to submit the report for
 *                this site
 */
phish_result_t phish_getReportingURL(const char *url, char **result);

/** Returns the first entry in the safe list.
 *  @param entry will be assigned with pointer to first entry in safe list
 */
phish_result_t phish_getSafeListFirst(phish_safe_list_entry_t **entry);

/** Returns the next entry in the safe list.
 *  @param entry entry before the entry that will be returned
 *  @param next will be assigned with pointer to entry after entry given above
 */
phish_result_t phish_getSafeListNext(phish_safe_list_entry_t *entry,
                                     phish_safe_list_entry_t **next);

/** Returns the URL associated with a safe list entry.
 *  @param entry entry whose URL is requested
 *  @param url will be assigned with URL of safe list entry
 */
phish_result_t phish_getSafeListData(phish_safe_list_entry_t *entry,
                                     const char **url);

/** Adds a URL to the currently used safe list.
 *  @param url URL to add
 */
phish_result_t phish_addToCurrentSafeList(const char *url);

/** Creates a new, empty safe list.
 *  @param list will be assigned with newly created safe list
 */
phish_result_t phish_newSafeList(phish_safe_list_t **list);

/** Adds a URL to a safe list.
 *  @param list safe list to add URL to
 *  @param url URL to add
 */
phish_result_t phish_addToSafeList(phish_safe_list_t *list, const char *url);

/** Sets the safe list to a new one.
 *  @param list new safe list to use
 */
phish_result_t phish_setSafeList(phish_safe_list_t *list);

/** Saves the safe list to the safe list file.
 */
phish_result_t phish_saveSafeList();

/** Saves the settings to the settings file.
 */
phish_result_t phish_saveSettings();


/** Returns the running mode.
 *  @param result will be assigned with current running mode
 */
phish_result_t phish_runningMode(phish_mode_t *result);

/** Returns the URL used for site queries on the server.
 *  @param result will be assigned with current site query URL
 */
phish_result_t phish_siteQueryURL(const char **result);

/** Returns the URL used for country queries on the server.
 *  @param result will be assigned with current country query URL
 */
phish_result_t phish_countryQueryURL(const char **result);

/** Returns the URL used for reporting sites on the server.
 *  @param result will be assigned with current site reporting URL
 */
phish_result_t phish_reportSiteURL(const char **result);

/** Returns the URL to the XML file to download on the server
 *  @param result will be assigned with current URL of the XML file
 */
phish_result_t phish_remoteXMLURL(const char **result);

/** Returns the name of the local XML file.
 *  @param result will be assigned with current name of the local XML file
 */
phish_result_t phish_localXMLFile(const char **result);

/** Returns the name of the safe list file.
 *  @param result will be assigned with current name of the safe list file
 */
phish_result_t phish_safeListFile(const char **result);

/** Sets the running mode.
 *  @param mode new mode to use
 */
phish_result_t phish_setRunningMode(phish_mode_t mode);

/** Sets the site queries URL.
 *  @param url new URL to use
 */
phish_result_t phish_setSiteQueryURL(const char *url);

/** Sets the country queries URL.
 *  @param url new URL to use
 */
phish_result_t phish_setCountryQueryURL(const char *url);

/** Sets the site reporting URL.
 *  @param url new URL to use
 */
phish_result_t phish_setReportSiteURL(const char *url);

/** Sets the remote XML file URL.
 *  @param url new URL to use
 */
phish_result_t phish_setRemoteXMLURL(const char *url);

/** Sets the local XML file name.
 *  @param path new file name to use
 */
phish_result_t phish_setLocalXMLFile(const char *path);

/** Sets the safe list file name.
 *  @param path new file name to use
 */
phish_result_t phish_setSafeListFile(const char *path);


#ifdef __cplusplus
}
#endif

#endif /* __PHISH_H */

--- trunk/client/libphish/src/phish_local_xml.c #1:2

#include <stdio.h>
#include <string.h>
#include <expat.h>

#include "phish_local_xml.h"
#include "phish.h"
#include "phish_util_ll.h"

#define BUF_SIZE 8192

static const char *protocol;
static const char *server;
static const char *path;
static char ip_addr[16];

/* used to determine whether copy the comments to url_data structure */
static int in_comments = 0;
static int change_comments = 0; /* whether or not to change the comments */
                                /* currently in the results object */


static void XMLCALL
startElem(phish_url_data_t *url_data, const char *el, const char **attr)
{
  int i;
  const char *element_server = NULL;
  const char *element_path = NULL;
  const char *element_ip = NULL;
  
  if (strcmp(el, "comments") == 0)
    in_comments = 1;

  /* set the element_[server|path|ip] strings.             */
  /* note that if the name of the attribute is at attr[i], */
  /* its value is at attr[i+1].                            */
  for (i = 0; attr[i]; i += 2) 
  {
    if (strcmp(attr[i], "protocol") == 0)
      continue;

    if ( (strcmp(attr[i], "server") == 0) )
    {
      element_server = attr[i+1];
      continue;
    }

    if ( (strcmp(attr[i], "path") == 0) )
    {
      element_path = attr[i+1];
      continue;
    }

    if ( (strcmp(attr[i], "ip") == 0) )
    {
      element_ip = attr[i+1];
      continue;
    }
  }

  /* check if server matches */
  if (element_server && strcmp(element_server, server) == 0)
  {
    url_data->server = 1;
  
    /* check if path matches too */
    if (element_path && strcmp(element_path, path) == 0)
    { 
      url_data->path = 1;
      change_comments = 1;
    }

    /* we don't want to change the comments if the current comments are */
    /* more specific (relate to server+path match).                     */
    if (url_data->path == 0)
      change_comments = 1;
  }

  /* check if ip matches */
  if (element_ip && strcmp(element_ip, ip_addr) == 0) 
  { 
    url_data->ip = 1;
  }
}

static void XMLCALL
endElem(phish_url_data_t *url_data, const char *el)
{
  if (strcmp(el, "comments") == 0)
    in_comments = 0;
  
  change_comments = 0; /* we're moving to the next element */
}

static void XMLCALL 
charHandler(phish_url_data_t *url_data, const XML_Char *s, int len)
{
  if (in_comments && change_comments)
  {
    char *newcomm; 
    int prevlen = url_data->comments_length;
    
    len += prevlen;
    
    newcomm = malloc(len+1);

    /* first copy the comment to continue parsing */
    strncpy(newcomm, url_data->comments, prevlen);
    /* copy the rest of the comment */
    strncpy(newcomm+prevlen, s, len-prevlen);
    newcomm[len] = '\0';

    free(url_data->comments); /* free old comments */
    url_data->comments = newcomm; /* set new comments */
    url_data->comments_length = len;
  }
}


phish_result_t phish_localxml_checkURL(const char *xml_file,
                                       phish_util_url_t *url,
                                       const char *ip,
                                       phish_url_data_t *results)
{
  char buf[BUF_SIZE];
  FILE *input_file;
  
  /* set up the parser and element handlers */
  XML_Parser p = XML_ParserCreate(NULL);
  if (!p)
    return PHISH_ERR_MEMORY;
  
  XML_SetElementHandler(p, (XML_StartElementHandler)startElem,
                        (XML_EndElementHandler)endElem);
  XML_SetCharacterDataHandler(p, (XML_CharacterDataHandler)charHandler);
  XML_SetUserData(p, results); /* handlers will fill the 'results' objects */
  
  protocol = url->protocol;
  server = url->host;
  path = url->path;
  strcpy(ip_addr, ip);
  
  input_file = fopen(xml_file, "r");
  if (!input_file)
    return PHISH_XML_READ_ERROR;

  /* one or more of these values will be to 1 if a match is found */
  results->server = 0;
  results->ip = 0;
  results->path = 0;
  
  /* search inside local XML file */
  while (1) 
  {
    int done;
    int len;

    len = fread(buf, 1, BUF_SIZE, input_file);
    if (ferror(input_file)) 
    {
      fclose(input_file);
      return PHISH_XML_READ_ERROR;
    }
    
    /* parse the content as long as there's no error and EOF isn't reached */
    done = feof(input_file);
    if (XML_Parse(p, buf, len, done) == XML_STATUS_ERROR)
    {
      fclose(input_file);
      return PHISH_XML_PARSE_ERROR;
    }

    if (done)
      break;
  }
  fclose(input_file);

  return PHISH_SUCCESS;
}

--- trunk/client/libphish/src/phish_local_xml.h #1:2

#ifndef __PHISH_LOCAL_XML_H
#define __PHISH_LOCAL_XML_H


#include "phish.h"
#include "phish_util_url.h"

/** Queries the local XML file about a URL.
 *  @param xml_file location of the local XML file
 *  @param url URL to check
 *  @param ip IP address of URL
 *  @param results pointer to results structure which will be filled with
 *                 results of checking the URL
 */
phish_result_t phish_localxml_checkURL(const char *xml_file,
                                       phish_util_url_t *url,
                                       const char *ip,
                                       phish_url_data_t *results);


#endif /* __PHISH_LOCAL_XML_H */

--- trunk/client/libphish/src/phish_opdb_server.c #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifdef WIN32
#define close closesocket
#include <winsock2.h>
#else
#include <sys/socket.h>
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>


#include "phish_opdb_server.h"
#include "phish_util_net.h"
#include "phish_util_url.h"


#ifdef WIN32
#define ssize_t int
#endif

#define BUF_SIZE 1024


phish_result_t phish_opdbserver_checkURL(phish_util_url_t *query_url,
                                         phish_util_url_t *url,
                                         const char *ip,
                                         const char *user_agent,
                                         phish_url_data_t *results)
{
#ifdef WIN32
  SOCKET sock;
#else
  int sock;
#endif
  char buf[BUF_SIZE];
  char *full_query;
  phish_result_t r;
  phish_util_http_headers_t headers;
  
  full_query = malloc(strlen(query_url->path) + 3 + strlen(url->protocol) + 3 +
                      strlen(ip) + 3 + strlen(url->host) + 3 +
                      strlen(url->path) + 1);
  if (full_query == NULL)
  {
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(full_query, "%s?m=%s&i=%s&s=%s&p=%s", query_url->path,
          url->protocol, ip, url->host, url->path);
  
  /* create socket */
  sock = socket(PF_INET, SOCK_STREAM, 0);
  if (sock == -1)
  {
    return PHISH_ERR_TCP_CONNECT;
  }
  
  /* connect to server */
  r = phish_util_tcpConnect(sock, query_url->host, query_url->port);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  /* send HTTP get request */
  r = phish_util_httpGet(sock, full_query, "1.0", query_url->host, user_agent,
                         NULL, NULL, 0);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  free(full_query);
  
  /* parse headers of reply from HTTP server */
  r = phish_util_parseHTTPReply(sock, &headers);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  if (headers.status_code != HTTP_STATUS_OK)
  {
    return PHISH_ERR_HTTP_BAD_STATUS;
  }

  free(headers.etag);
  
  if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_READ;
  }
  
  /* read results of site query from server */
  while (strcmp(buf, "") != 0)
  {
    char *field, *content;
    int i = 0;
    
    /* extract field name and field content from reply line */
    while (buf[i] != '\0' && buf[i] != ':')
      i++;
    
    if (buf[i] == '\0')
      return PHISH_ERR_OPDB_BAD_REPLY;
    
    field = malloc(i + 1);
    if (field == NULL)
      return PHISH_ERR_MEMORY;
    
    strncpy(field, buf, i);
    field[i++] = '\0';
    
    while (buf[i] != '\0' && buf[i] == ' ')
      i++;
    
    if (buf[i] == '\0')
    {
      free(field);
      return PHISH_ERR_OPDB_BAD_REPLY;
    }
    
    content = malloc(strlen(buf + i) + 1);
    if (content == NULL)
    {
      free(field);
      return PHISH_ERR_MEMORY;
    }
    
    strncpy(content, buf + i, strlen(buf + i));
    content[strlen(buf + i)] = '\0';
    
    if (strcmp(field, "IP") == 0)
    {
      results->ip = (strcmp(content, "y") == 0) ? 1 : 0;
    }
    else if (strcmp(field, "Server") == 0)
    {
      results->server = (strcmp(content, "y") == 0) ? 1 : 0;
    }
    else if (strcmp(field, "Path") == 0)
    {
      results->path = (strcmp(content, "y") == 0) ? 1 : 0;
    }
    else if (strcmp(field, "Country") == 0)
    {
      strncpy(results->country, content, 2);
      results->country[2] = '\0';
    }
    else if (strcmp(field, "Comments-Length") == 0)
    {
      results->comments_length = atoi(content);
    }
    
    free(field);
    free(content);
    
    if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_READ;
    }
  }
  
  /* read comments */
  if (results->comments_length > 0)
  {
    char *pos;
    size_t length_remain = results->comments_length;
    results->comments = malloc(results->comments_length + 1);
    
    if (results->comments == NULL)
      return PHISH_ERR_MEMORY;
    
    pos = results->comments;
    
    if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
      return PHISH_ERR_SOCK_READ;
    
    while (length_remain > 0 && (strcmp(buf, "") != 0))
    {
      length_remain -= strlen(buf);
      strcpy(pos, buf);
      pos += strlen(buf);
      
      if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
      {
        return PHISH_ERR_SOCK_READ;
      }
    }
  }
  
  close(sock);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_opdbserver_checkCountry(phish_util_url_t *country_url,
                                             const char *ip,
                                             const char *user_agent,
                                             phish_url_data_t *results)
{
#ifdef WIN32
  SOCKET sock;
#else
  int sock;
#endif
  char buf[BUF_SIZE];
  char *full_query;
  phish_result_t r;
  phish_util_http_headers_t headers;
  
  full_query = malloc(strlen(country_url->path) + 3 + strlen(ip) + 1);
  if (full_query == NULL)
  {
    return PHISH_ERR_MEMORY;
  }
  
  sprintf(full_query, "%s?i=%s", country_url->path, ip);
  
  /* create socket */
  sock = socket(PF_INET, SOCK_STREAM, 0);
  if (sock == -1)
  {
    return PHISH_ERR_TCP_CONNECT;
  }
  
  /* connect to server */
  r = phish_util_tcpConnect(sock, country_url->host, country_url->port);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  /* send HTTP get request */
  r = phish_util_httpGet(sock, full_query, "1.0", country_url->host,
                         user_agent, NULL, NULL, 0);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  free(full_query);
  
  /* parse headers of reply from HTTP server */
  r = phish_util_parseHTTPReply(sock, &headers);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  if (headers.status_code != HTTP_STATUS_OK)
  {
    return PHISH_ERR_HTTP_BAD_STATUS;
  }

  free(headers.etag);
  
  if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_READ;
  }
  
  /* read results of site query from server */
  while (strcmp(buf, "") != 0)
  {
    char *field, *content;
    int i = 0;
    
    /* extract field name and field content from reply line */
    while (buf[i] != '\0' && buf[i] != ':')
      i++;
    
    if (buf[i] == '\0')
      return PHISH_ERR_OPDB_BAD_REPLY;
    
    field = malloc(i + 1);
    if (field == NULL)
      return PHISH_ERR_MEMORY;
    
    strncpy(field, buf, i);
    field[i++] = '\0';
    
    while (buf[i] != '\0' && buf[i] == ' ')
      i++;
    
    if (buf[i] == '\0')
    {
      free(field);
      return PHISH_ERR_OPDB_BAD_REPLY;
    }
    
    content = malloc(strlen(buf + i) + 1);
    if (content == NULL)
    {
      free(field);
      return PHISH_ERR_MEMORY;
    }
    
    strncpy(content, buf + i, strlen(buf + i));
    content[strlen(buf + i)] = '\0';
    
    if (strcmp(field, "Country") == 0)
    {
      strncpy(results->country, content, 2);
      results->country[2] = '\0';
    }
    
    free(field);
    free(content);
    
    if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_READ;
    }
  }
  
  close(sock);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_opdbserver_downloadDBAsXML(phish_util_url_t *download_url,
                                                const char *user_agent,
                                                const char *local_file,
                                                const char *etag,
                                                char **new_etag)
{
#ifdef WIN32
  SOCKET sock;
#else
  int sock;
#endif
  ssize_t bytes_read;
  char buf[BUF_SIZE];
  struct stat sb;
  phish_result_t r;
  phish_util_http_headers_t headers;
  FILE *local_xml;
  
  /* if the local XML file doesn't exist, it will be downloaded regardless of
     the etag */
  if (stat(local_file, &sb) == -1 || (sb.st_mode & S_IFREG) == 0)
    etag = NULL;
  
  /* create socket */
  sock = socket(PF_INET, SOCK_STREAM, 0);
  if (sock == -1)
  {
    return PHISH_ERR_TCP_CONNECT;
  }
  
  /* connect to server */
  r = phish_util_tcpConnect(sock, download_url->host, download_url->port);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  r = phish_util_httpGet(sock, download_url->path, "1.0", download_url->host,
                         user_agent, NULL, etag, 0);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  r = phish_util_parseHTTPReply(sock, &headers);
  if (r != PHISH_SUCCESS)
  {
    return r;
  }
  
  if (headers.status_code == HTTP_STATUS_NOT_MODIFIED)
  {
    /* file wasn't modified, so don't download */
    free(headers.etag);
    close(sock);
    return PHISH_XML_NOT_MODIFIED;
  }
  else if (headers.status_code != HTTP_STATUS_OK)
  {
    free(headers.etag);
    close(sock);
    return PHISH_ERR_HTTP_BAD_STATUS;
  }
  
  /* set new ETag received */
  *new_etag = malloc(strlen(headers.etag) + 1);
  if (*new_etag == NULL)
  {
    free(headers.etag);
    close(sock);
    return PHISH_ERR_MEMORY;
  }
  strcpy(*new_etag, headers.etag);
  free(headers.etag);
  
  /* download file */
  local_xml = fopen(local_file, "w");
  if (local_xml == NULL)
  {
    close(sock);
    return PHISH_ERR_FILE;
  }
  
  while ((bytes_read = recv(sock, buf, BUF_SIZE, 0)) > 0)
  {
    fwrite(buf, bytes_read, 1, local_xml);
  }
  
  if (bytes_read < 0)
  {
    fclose(local_xml);
    close(sock);
    return PHISH_ERR_SOCK_READ;
  }
  
  fclose(local_xml);
  close(sock);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_opdbserver_getReportingURL(phish_util_url_t *reporting_url,
                                                const char *client_ua,
                                                const char *url,
                                                char **result)
{
  *result = malloc(strlen(reporting_url->protocol) + 3 +
                   strlen(reporting_url->host) +
                   strlen(reporting_url->path) + 5 + strlen(url) + 8 +
                   strlen(client_ua) + 1);
  
  if (*result == NULL)
    return PHISH_ERR_MEMORY;
  
  sprintf(*result, "%s://%s%s?url=%s&client=%s", reporting_url->protocol,
                                                  reporting_url->host,
                                                  reporting_url->path,
                                                  url, client_ua);
  
  return PHISH_SUCCESS;
}

--- trunk/client/libphish/src/phish_opdb_server.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/


#ifndef __PHISH_OPDB_SERVER_H
#define __PHISH_OPDB_SERVER_H

#include "phish.h"
#include "phish_util_url.h"

/** Queries the server about a URL.
 *  @param query_url URL of query script on server
 *  @param url complete URL to check
 *  @param ip ip address of URL
 *  @param user_agent user agent to send to server, or NULL if not to send
 *  @param results pointer to results structure which will be filled with
 *                 results of checking the URL
 */
phish_result_t phish_opdbserver_checkURL(phish_util_url_t *query_url,
                                         phish_util_url_t *url,
                                         const char *ip,
                                         const char *user_agent,
                                         phish_url_data_t *results);

/** Queries the server about the country of an IP address.
 *  @param country_url URL of country query script on server
 *  @param ip ip address of URL
 *  @param user_agent user agent to send to server, or NULL if not to send
 *  @param results pointer to results structure which whose country field will
 *                 be filled with the country corresponding to the given IP
 *                 address
 */
phish_result_t phish_opdbserver_checkCountry(phish_util_url_t *country_url,
                                             const char *ip,
                                             const char *user_agent,
                                             phish_url_data_t *results);

/** Download the sites database as an XML file from the server. If the
 *  database hasn't been modified since the last download, no download will
 *  happen.
 *  @param download_url URL of XML file to download
 *  @param user_agent user agent to send to server, or NULL if not to send
 *  @param local_file path to file on disk to download to
 *  @param etag pointer to null-terminated string representing ETag of last
 *              version downloaded.
 *  @param new_etag pointer to pointer to string which will be allocated and
 *                  filled with ETag of new file if file was modified on server
 *  @return PHISH_SUCCESS if the database was updated and the XML file was
 *          downloaded and saved successfully, PHISH_XML_NOT_MODIFIED if the
 *          database hasn't been modified.
 */
phish_result_t phish_opdbserver_downloadDBAsXML(phish_util_url_t *download_url,
                                                const char *user_agent,
                                                const char *local_file,
                                                const char *etag,
                                                char **new_etag);

/** Given a URL of a site to report, return a URL that the client should go
 *  to which contains the data required to submit a site report.
 *  @param reporting_url URL of reporting script on server
 *  @param client_ua User agent string of client (e.g. anti-phishing toolbar)
 *                   that will be sent in the query to the server
 *  @param url URL of site to report
 *  @param result pointer to string which will be allocated and filled with
 *                URL to point client to in order to submit the report for
 *                this site
 */
phish_result_t phish_opdbserver_getReportingURL(phish_util_url_t *reporting_url,
                                                const char *client_ua,
                                                const char *url,
                                                char **result);


#endif /* __PHISH_OPDB_SERVER_H */

--- trunk/client/libphish/src/phish_safelist.c #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *   Copyright (C) 2005 Boaz Anin <boazanin at gmail.com>                     *
 *   Copyright (C) 2005 Shahar Karin <shaharka at post.tau.ac.il>             *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "phish_safelist.h"


phish_result_t phish_safeList_new(phish_safelist_t **list)
{
  *list = phish_util_newList();

  if (*list == NULL)
    return PHISH_ERR_MEMORY;
  else
    return PHISH_SUCCESS;
}

phish_result_t phish_safelist_open(const char *path,
                                  phish_safelist_t **list)
{
  FILE *safelist_file;
  char *url;

  *list = phish_util_newList();
  if (*list == NULL)
    return PHISH_ERR_MEMORY;
  
  safelist_file = fopen(path, "r");
  if (safelist_file == NULL)
    return PHISH_ERR_FILE;
  
  while (!feof(safelist_file))
  {
    url = malloc(PHISH_URL_LENGTH_LIMIT);
    if (url == NULL)
    {
      fclose(safelist_file);
      return PHISH_ERR_MEMORY;
    }
    
    if (fgets(url, PHISH_URL_LENGTH_LIMIT, safelist_file) == NULL)
    {
      free(url);
      
      if (feof(safelist_file))
        break;
      else
      {
        fclose(safelist_file);
        return PHISH_ERR_FILE;
      }
    }
    else
    {
      char *nl = strchr(url, '\n');
      if (nl != NULL)
        *nl = '\0'; /* remove newline character */
      
      phish_util_addToList(*list, url);
    }
  }
  
  fclose(safelist_file);
  
  return PHISH_SUCCESS;
}

void phish_safelist_close(phish_safelist_t *list)
{
  phish_util_deepDeleteList(list);
}

phish_result_t phish_safelist_write(const char *path,
                                   phish_safelist_t *list)
{
  FILE *safelist_file;
  char *url;
  phish_safelist_entry_t *entry;
  
  if (list == NULL)
    return PHISH_SUCCESS;
  
  safelist_file = fopen(path, "w");
  if (safelist_file == NULL)
    return PHISH_ERR_FILE;
  
  entry = phish_util_listHead(list);
  while (entry != NULL)
  {
    url = phish_util_listData(entry);
    fprintf(safelist_file, "%s\n", url);

    entry = phish_util_listNext(entry);
  }
  
  fclose(safelist_file);
  return PHISH_SUCCESS;
}

int phish_safelist_checkURL(const char *url, phish_safelist_t *list)
{
  phish_safelist_entry_t *entry;
  
  if (list == NULL)
    return 0;
  
  entry = phish_util_listHead(list);
  while (entry != NULL)
  {
    char *current_url = phish_util_listData(entry);
    int current_url_len = strlen(current_url);
    
    if (current_url_len > 0 && strlen(url) >= current_url_len)
      if (strncmp(current_url, url, current_url_len) == 0)
        return 1;
    
    entry = phish_util_listNext(entry);
  }
  
  return 0;
}

phish_result_t phish_safelist_add(const char *url, phish_safelist_t *list)
{
  char *url_copy;

  /* avoid adding a URL already covered by safe list */
  if (phish_safelist_checkURL(url, list) == 1)
    return PHISH_SUCCESS;

  url_copy = strdup(url);
  if (url_copy == NULL)
    return PHISH_ERR_MEMORY;
  
  phish_util_addToList(list, url_copy);
  return PHISH_SUCCESS;
}

phish_safelist_entry_t *phish_safelist_first(phish_safelist_t *list)
{
  return phish_util_listHead(list);
}

phish_safelist_entry_t *phish_safelist_next(phish_safelist_entry_t *entry)
{
  return phish_util_listNext(entry);
}

const char *phish_safelist_entryData(phish_safelist_entry_t *entry)
{
  return phish_util_listData(entry);
}

--- trunk/client/libphish/src/phish_safelist.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *   Copyright (C) 2005 Boaz Anin <boazanin at gmail.com>                     *
 *   Copyright (C) 2005 Shahar Karin <shaharka at post.tau.ac.il>             *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __PHISH_SAFELIST_H
#define __PHISH_SAFELIST_H

#include "phish.h"
#include "phish_util_ll.h"


typedef phish_util_LinkedList phish_safelist_t;
typedef phish_util_ListElem phish_safelist_entry_t;

/** Creates a new, empty safe list.
 *  @param list pointer to pointer to safe list handle which will be assigned
 *              with address of newly created safe list.
 */
phish_result_t phish_safeList_new(phish_safelist_t **list);

/** Open a safe list file and loads the list of URLs in it.
 *  @param path location of safe list file
 *  @param list pointer to pointer to safe list handle which will be assigned
 *              with address of opened safe list for use with other functions
 */
phish_result_t phish_safelist_open(const char *path,
                                   phish_safelist_t **list);

/** Close a safe list.
 *  @param list pointer to safe list to close
 */
void phish_safelist_close(phish_safelist_t *list);

/** Writes the list of URLs from a safe list back into a file.
 *  @param path location of file to write safe list to
 *  @param list safe list to write to file
 */
phish_result_t phish_safelist_write(const char *path,
                                    phish_safelist_t *list);

/** Checks whether a URL is in safe list.
 *  @param url URL to check
 *  @param list safe list to use for checking
 *  @return 1 if URL is in safe list, 0 otherwise
 */
int phish_safelist_checkURL(const char *url, phish_safelist_t *list);

/** Adds a URL to a safe list.
 *  @param url URL to add
 *  @param list safe list to add URL to
 */
phish_result_t phish_safelist_add(const char *url, phish_safelist_t *list);

/** Returns the first entry in a safe list.
 *  @param list safe list
 */
phish_safelist_entry_t *phish_safelist_first(phish_safelist_t *list);

/** Returns the next entry after the given entry in a safe list.
 *  @param entry entry before the returned element
 */
phish_safelist_entry_t *phish_safelist_next(phish_safelist_entry_t *entry);

/** Returns the URL contained in a safe list entry. */
const char *phish_safelist_entryData(phish_safelist_entry_t *entry);


#endif /* __PHISH_SAFELIST_H */

--- trunk/client/libphish/src/phish_settings.c #1:2

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "phish.h"
#include "phish_settings.h"

#define BUF_SIZE 1024

#define MODE_FIELD              "Mode"
#define ONLINE_MODE_VALUE       "Online"
#define OFFLINE_MODE_VALUE      "Offline"
#define SITE_QUERY_URL_FIELD    "SiteQuery"
#define COUNTRY_QUERY_URL_FIELD "CountryQuery"
#define REPORT_SITE_URL_FIELD   "SiteReport"
#define REMOTE_XML_URL_FIELD    "RemoteXMLURL"
#define REMOTE_XML_ETAG_FIELD   "RemoteXMLETag"
#define LOCAL_XML_FILE_FIELD    "SitesXMLFile"
#define SAFE_LIST_FILE_FIELD    "SafeListFile"

#define DEFAULT_MODE              PHISH_OFFLINE_MODE
#define DEFAULT_SITE_QUERY_URL    "http://opdb.berlios.de/cgi-bin/query.pl"
#define DEFAULT_COUNTRY_QUERY_URL "http://opdb.berlios.de/cgi-bin/country.pl"
#define DEFAULT_REPORT_SITE_URL   "http://opdb.berlios.de/cgi-bin/report.pl"
#define DEFAULT_REMOTE_XML_URL    "http://opdb.berlios.de/opdbsites.xml"
#define DEFAULT_LOCAL_XML_FILE    "opdbsites.xml"
#define DEFAULT_SAFE_LIST_FILE    "safesites"


void phish_settings_init(phish_settings_t *settings)
{
  settings->mode = -1;
  settings->site_query_url = NULL;
  settings->country_query_url = NULL;
  settings->report_site_url = NULL;
  settings->remote_xml_url = NULL;
  settings->remote_xml_etag = NULL;
  settings->local_xml_file = NULL;
  settings->safe_list_file = NULL;
}

void phish_settings_free(phish_settings_t *settings)
{
  free(settings->site_query_url);
  free(settings->country_query_url);
  free(settings->report_site_url);
  free(settings->remote_xml_url);
  free(settings->remote_xml_etag);
  free(settings->local_xml_file);
  free(settings->safe_list_file);
}

phish_mode_t phish_settings_runningMode(phish_settings_t *settings)
{
  if (settings->mode == -1)
    return DEFAULT_MODE;
  else
    return settings->mode;
}

const char *phish_settings_siteQueryURL(phish_settings_t *settings)
{
  if (settings->site_query_url == NULL)
    return DEFAULT_SITE_QUERY_URL;
  else
    return settings->site_query_url;
}

const char *phish_settings_countryQueryURL(phish_settings_t *settings)
{
  if (settings->country_query_url == NULL)
    return DEFAULT_COUNTRY_QUERY_URL;
  else
    return settings->country_query_url;
}

const char *phish_settings_reportSiteURL(phish_settings_t *settings)
{
  if (settings->report_site_url == NULL)
    return DEFAULT_REPORT_SITE_URL;
  else
    return settings->report_site_url;
}

const char *phish_settings_remoteXMLURL(phish_settings_t *settings)
{
  if (settings->remote_xml_url == NULL)
    return DEFAULT_REMOTE_XML_URL;
  else
    return settings->remote_xml_url;
}

const char *phish_settings_remoteXMLETag(phish_settings_t *settings)
{
  return settings->remote_xml_etag;
}

const char *phish_settings_localXMLFile(phish_settings_t *settings)
{
  if (settings->local_xml_file == NULL)
    return DEFAULT_LOCAL_XML_FILE;
  else
    return settings->local_xml_file;
}

const char *phish_settings_safeListFile(phish_settings_t *settings)
{
  if (settings->safe_list_file == NULL)
    return DEFAULT_SAFE_LIST_FILE;
  else
    return settings->safe_list_file;
}

void phish_settings_setRunningMode(phish_settings_t *settings,
                                   phish_mode_t mode)
{
  settings->mode = mode;
}

static void setSetting(char **setting, const char *value)
{
  free(*setting);
  *setting = malloc(strlen(value) + 1);
  strcpy(*setting, value);
}

void phish_settings_setSiteQueryURL(phish_settings_t *settings,
                                    const char *url)
{
  setSetting(&settings->site_query_url, url);
}

void phish_settings_setCountryQueryURL(phish_settings_t *settings,
                                       const char *url)
{
  setSetting(&settings->country_query_url, url);
}

void phish_settings_setReportSiteURL(phish_settings_t *settings,
                                     const char *url)
{
  setSetting(&settings->report_site_url, url);
}

void phish_settings_setRemoteXMLURL(phish_settings_t *settings,
                                    const char *url)
{
  setSetting(&settings->remote_xml_url, url);
}

void phish_settings_setRemoteXMLETag(phish_settings_t *settings,
                                     const char *etag)
{
  setSetting(&settings->remote_xml_etag, etag);
}

void phish_settings_setLocalXMLFile(phish_settings_t *settings,
                                    const char *path)
{
  setSetting(&settings->local_xml_file, path);
}

void phish_settings_setSafeListFile(phish_settings_t *settings,
                                    const char *path)
{
  setSetting(&settings->safe_list_file, path);
}

static void readSettingsEntry(phish_settings_t *settings,
                              const char *line)
{
  int pos = 0;
  int eq_pos = -1;

  while (line[pos] != '\n' && line[pos] != '\0')
  {
    /* find index of '=' separator */
    if (line[pos] == '=')
    {
      eq_pos = pos;
      break;
    }
    
    pos++;
  }
  
  if (eq_pos == -1)
    return;

  if (strncmp(line, MODE_FIELD, eq_pos - 1) == 0)
  {
    if (strcmp(line + eq_pos + 1, ONLINE_MODE_VALUE) == 0)
      phish_settings_setRunningMode(settings, PHISH_ONLINE_MODE);
    else if (strcmp(line + eq_pos + 1, OFFLINE_MODE_VALUE) == 0)
      phish_settings_setRunningMode(settings, PHISH_OFFLINE_MODE);
  }
  else if (strncmp(line, SITE_QUERY_URL_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setSiteQueryURL(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, COUNTRY_QUERY_URL_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setCountryQueryURL(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, REPORT_SITE_URL_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setReportSiteURL(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, REMOTE_XML_URL_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setRemoteXMLURL(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, REMOTE_XML_ETAG_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setRemoteXMLETag(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, LOCAL_XML_FILE_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setLocalXMLFile(settings, line + eq_pos + 1);
  }
  else if (strncmp(line, SAFE_LIST_FILE_FIELD, eq_pos - 1) == 0)
  {
    phish_settings_setSafeListFile(settings, line + eq_pos + 1);
  }
}

phish_result_t phish_settings_load(phish_settings_t *settings,
                                   const char *settings_file_name)
{
  FILE *settings_file;
  char buf[BUF_SIZE];

  settings_file = fopen(settings_file_name, "r");
  if (settings_file != NULL)
  {
    while (fgets(buf, BUF_SIZE, settings_file) != NULL)
    {
      char *nl = strchr(buf, '\n');
      if (nl != NULL)
        *nl = '\0'; /* remove newline character */
      
      readSettingsEntry(settings, buf);
    }

    fclose(settings_file);
  }

  return PHISH_SUCCESS;
}


static void writeSettingsEntry(FILE *settings_file,
                               const char *field, const char *value)
{
  if (value != NULL)
    fprintf(settings_file, "%s=%s\n", field, value);
}

phish_result_t phish_settings_write(phish_settings_t *settings,
                                    const char *settings_file_name)
{

  FILE *settings_file;
  
  if ((settings_file = fopen(settings_file_name, "w")) == NULL)
  {
    return PHISH_ERR_FILE_WRITE;
  }
  
  switch(settings->mode)
  {
    case PHISH_ONLINE_MODE:
      writeSettingsEntry(settings_file, MODE_FIELD, ONLINE_MODE_VALUE);
      break;
    case PHISH_OFFLINE_MODE:
      writeSettingsEntry(settings_file, MODE_FIELD, OFFLINE_MODE_VALUE);
      break;
    default:
      break;
  }

  writeSettingsEntry(settings_file, SITE_QUERY_URL_FIELD,
                           settings->site_query_url);
  
  writeSettingsEntry(settings_file, COUNTRY_QUERY_URL_FIELD,
                           settings->country_query_url);
  
  writeSettingsEntry(settings_file, REPORT_SITE_URL_FIELD,
                           settings->report_site_url);
  
  writeSettingsEntry(settings_file, REMOTE_XML_URL_FIELD,
                           settings->remote_xml_url);
  
  writeSettingsEntry(settings_file, REMOTE_XML_ETAG_FIELD,
                           settings->remote_xml_etag);
  
  writeSettingsEntry(settings_file, LOCAL_XML_FILE_FIELD,
                           settings->local_xml_file);
  
  writeSettingsEntry(settings_file, SAFE_LIST_FILE_FIELD,
                           settings->safe_list_file);

  fclose(settings_file);
  
  return PHISH_SUCCESS;
}

--- trunk/client/libphish/src/phish_settings.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __PHISH_SETTINGS_H
#define __PHISH_SETTINGS_H


/** Settings the library uses */
typedef struct
{
  /** Running mode */
  phish_mode_t mode;

  /** URL used for site queries on server */
  char *site_query_url;

  /** URL used for country queries on server */
  char *country_query_url;

  /** URL used for reporting sites on server */
  char *report_site_url;

  /** URL of XML file to download on server */
  char *remote_xml_url;

  /** ETag of remote XML file */
  char *remote_xml_etag;

  /** Filename of local XML file */
  char *local_xml_file;

  /** Filename of safe list file */
  char *safe_list_file;
} phish_settings_t;


/** Initialises the settings to their defaults.
 *  @param settings settings structure to initialise
 */
void phish_settings_init(phish_settings_t *settings);

/** Frees memory associated with settings structure.
 *  @param settings settings strcuture to free
 */
void phish_settings_free(phish_settings_t *settings);

/** Load settings from a file.
 *  @param settings settings structure to load settings into
 *  @param settings_file_name name of setting file to load
 */
phish_result_t phish_settings_load(phish_settings_t *settings,
                                   const char *settings_file_name);

/** Saves settings to a file.
 *  @param settings settings structure to save
 *  @param settings_file_name name of setting file to save settings into
 */
phish_result_t phish_settings_write(phish_settings_t *settings,
                                    const char *settings_file_name);

/** Returns the running mode.
 *  @param settings settings structure to return setting from
 */
phish_mode_t phish_settings_runningMode(phish_settings_t *settings);

/** Returns the URL used for site queries on the server.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_siteQueryURL(phish_settings_t *settings);

/** Returns the URL used for country queries on the server.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_countryQueryURL(phish_settings_t *settings);

/** Returns the URL used for reporting sites on the server.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_reportSiteURL(phish_settings_t *settings);

/** Returns the URL to the XML file to download on the server
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_remoteXMLURL(phish_settings_t *settings);

/** Returns the name of the local XML file.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_localXMLFile(phish_settings_t *settings);

/** Returns the name of the safe list file.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_safeListFile(phish_settings_t *settings);

/** Returns the ETag of the XML file on the server.
 *  @param settings settings structure to return setting from
 */
const char *phish_settings_remoteXMLETag(phish_settings_t *settings);

/** Sets the running mode.
 *  @param settings settings structure to set setting in
 *  @param mode new mode to use
 */
void phish_settings_setRunningMode(phish_settings_t *settings,
                                   phish_mode_t mode);

/** Sets the site queries URL.
 *  @param settings settings structure to set setting in
 *  @param url new URL to use
 */
void phish_settings_setSiteQueryURL(phish_settings_t *settings,
                                    const char *url);

/** Sets the country queries URL.
 *  @param settings settings structure to set setting in
 *  @param url new URL to use
 */
void phish_settings_setCountryQueryURL(phish_settings_t *settings,
                                       const char *url);

/** Sets the site reporting URL.
 *  @param settings settings structure to set setting in
 *  @param url new URL to use
 */
void phish_settings_setReportSiteURL(phish_settings_t *settings,
                                     const char *url);

/** Sets the remote XML file URL.
 *  @param settings settings structure to set setting in
 *  @param url new URL to use
 */
void phish_settings_setRemoteXMLURL(phish_settings_t *settings,
                                    const char *url);

/** Sets the local XML file name.
 *  @param settings settings structure to set setting in
 *  @param path new file name to use
 */
void phish_settings_setLocalXMLFile(phish_settings_t *settings,
                                    const char *path);

/** Sets the safe list file name.
 *  @param settings settings structure to set setting in
 *  @param path new file name to use
 */
void phish_settings_setSafeListFile(phish_settings_t *settings,
                                    const char *path);

/** Sets the ETag of the XML file on the server.
 *  @param settings settings structure to set setting in
 *  @param etag new etag
 */
void phish_settings_setRemoteXMLETag(phish_settings_t *settings,
                                     const char *etag);


#endif /* __PHISH_SETTINGS_H */

--- trunk/client/libphish/src/phish_util_ll.c #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *   Copyright (C) 2005 Boaz Anin <boazanin at gmail.com>                     *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "phish_util_ll.h"


phish_util_ListElem *phish_util_newListElem()
{
  phish_util_ListElem *result = malloc(sizeof(phish_util_ListElem));
  
  if (result == NULL)
    return NULL;

  phish_util_setListData(result, NULL);
  phish_util_setListNext(result, NULL);

  return result;
}

void *phish_util_listData(phish_util_ListElem *l)
{
  if (l == NULL)
    return NULL;
  else
    return l->data;
}

void phish_util_setListData(phish_util_ListElem *l, void *d)
{
  if (l == NULL)
    return;
  else
    l->data = d;
}

phish_util_ListElem *phish_util_listNext(phish_util_ListElem *l)
{
  if (l == NULL)
    return NULL;
  else
    return l->next;
}

void phish_util_setListNext(phish_util_ListElem *l, phish_util_ListElem *n)
{
  if (l == NULL)
    return;
  else
    l->next = n;
}

phish_util_LinkedList *phish_util_newList()
{
  phish_util_LinkedList *newl;

  newl = malloc(sizeof(phish_util_LinkedList));

  if (newl == NULL)
    return NULL;

  newl->head = NULL;
  newl->tail = NULL;
  newl->length = 0;

  return newl;
}

void phish_util_addToList(phish_util_LinkedList *list, void *newdata)
{
  phish_util_ListElem *elem = phish_util_newListElem();

  if (list == NULL || elem == NULL)
    return;

  phish_util_setListData(elem, newdata);

  if (list->head == NULL)              /* if the list is empty */
  {
    list->head = elem;              /* add it to the beginning of the list */
    list->tail = elem;
  }
  else
  {
    phish_util_setListNext(list->tail, elem);/* add it at the end of the list */
    list->tail = elem;
  }

  list->length++;
}


/* A recursive function used only by deleteList, which deallocates all the
 * list elements.
 */
static void recursiveDeleteElements(phish_util_ListElem *elem)
{
  if (elem == NULL)
    return;
  else
    recursiveDeleteElements(phish_util_listNext(elem));

  free(elem);
}

void phish_util_deleteList(phish_util_LinkedList *list)
{
  if (list->head != NULL)
    recursiveDeleteElements(list->head);

  free(list);
}

phish_util_ListElem *phish_util_listHead(phish_util_LinkedList *list)
{
  if (list == NULL)
    return NULL;
  else
    return list->head;
}

void phish_util_deepDeleteList(phish_util_LinkedList *list)
{
  phish_util_ListElem *l;
  void *vp;

  for (l = phish_util_listHead(list) ; l != NULL ; l = phish_util_listNext(l))
  {
    vp = phish_util_listData(l); /* deallocate objects pointed to by      */
    free(vp);                    /* the data of each of the list elements */
  }

  phish_util_deleteList(list);   /* then, delete the list itself */
}

unsigned int phish_util_listLength(const phish_util_LinkedList *list)
{
  if (list == NULL)
    return 0;
  else
    return list->length;
}

--- trunk/client/libphish/src/phish_util_ll.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *   Copyright (C) 2005 Boaz Anin <boazanin at gmail.com>                     *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifndef __PHISH_UTIL_LL_H
#define __PHISH_UTIL_LL_H


/** A list element */
typedef struct phish_util_ListElem
{
  /** pointer to actual data stored in list element */
  void *data;
  
  /** pointer to next list element */
  struct phish_util_ListElem *next;
} phish_util_ListElem;

/** Creates a new list element, with NULL data.
 *  @return pointer to new list element, NULL if error occurred
 */
phish_util_ListElem *phish_util_newListElem();

/** Returns the data contained in a list element.
 *  @param l list element
 */
void *phish_util_listData(phish_util_ListElem *l);

/** Sets the list element to hold new data.
 *  @param l list element to set
 *  @param d new data
 */
void phish_util_setListData(phish_util_ListElem *l, void *d);

/** Return the next element after the given element in a linked list.
 *  @param l list element
 */
phish_util_ListElem *phish_util_listNext(phish_util_ListElem *l);

/** Sets the list element to point to a new next element.
 *  @param l list element
 *  @param n element to set as next element
*/
void phish_util_setListNext(phish_util_ListElem *l, phish_util_ListElem *n);


/** A linked list structure. */
typedef struct
{
  /** pointer to the first element in the list */
  phish_util_ListElem *head;
  
  /** pointer to the last element in the list */
  phish_util_ListElem *tail;
  
  /** number of elements currently in the list */
  unsigned int length;
} phish_util_LinkedList;


/** Defines a new list with no elements.
 *  @return pointer to new list, NULL if error occurred
 */
phish_util_LinkedList *phish_util_newList();

/** Adds a new item to a given list.
 *  @param list linked list to add new element to
 *  @param newdata new data of element to be added to list
 */
void phish_util_addToList(phish_util_LinkedList *list, void *newdata);

/** Returns the list element at the head of the given list.
 *  @param list linked list
 */
phish_util_ListElem *phish_util_listHead(phish_util_LinkedList *list);

/** Deletes a list, only by deallocating the memory its elements use,
 *  without their pointed data
 *  @param list linked list to delete
 */
void phish_util_deleteList(phish_util_LinkedList *list);

/** Deletes a list and its pointed data.
 *  @param list linked list to delete
 */
void phish_util_deepDeleteList(phish_util_LinkedList *list);

/** Returns the length of a given linked list.
 *  @param list linked list
 */
unsigned int phish_util_listLength(const phish_util_LinkedList *list);


#endif /* __PHISH_UTIL_LL_H */

--- trunk/client/libphish/src/phish_util_net.c #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#ifdef WIN32
#include <winsock2.h>
#define snprintf _snprintf
#define ssize_t int
#else
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#endif

#include "phish.h"
#include "phish_util_net.h"


#define BUF_SIZE 1024


typedef struct
{
  struct hostent *ent;
  char *buf;
} phish_util_hostent_t;


static void freeHostent(phish_util_hostent_t *h)
{
#ifndef WIN32
  free(h->ent);
#endif

  free(h->buf);
  free(h);
}

static phish_util_hostent_t *phish_getHostByName(const char *name)
{
#ifndef WIN32
  int result, err;

#endif

  phish_util_hostent_t *h = malloc(sizeof(phish_util_hostent_t));
  if (h == NULL)
  {
    return NULL;
  }
  
  h->ent = NULL;
  h->buf = NULL;
  
#ifdef WIN32

  h->ent = gethostbyname(name);
  
  if (h->ent == NULL)
  {
    freeHostent(h);
    return NULL;
  }
  
  return h;
  
#else

  h->ent = malloc(sizeof(struct hostent));
  if (h->ent == NULL)
  {
    freeHostent(h);
    return NULL;
  }
  
  h->buf = malloc(BUF_SIZE);
  if (h->buf == NULL)
  {
    freeHostent(h);
    return NULL;
  }
  
  result = gethostbyname_r(name, h->ent, h->buf, BUF_SIZE, &h->ent, &err);
  if (result != 0 || h->ent == NULL)
  {
    freeHostent(h);
    return NULL;
  }
  
  return h;
  
#endif
}

phish_result_t phish_util_hostToIP(const char *host, char **ip)
{
  phish_result_t r = PHISH_SUCCESS;
  phish_util_hostent_t *h;
  
  h = phish_getHostByName(host);
  if (h == NULL || h->ent == NULL)
  {
    return PHISH_ERR_RESOLVE;
  }
  
  *ip = strdup(inet_ntoa(*(struct in_addr*)h->ent->h_addr));
  if (*ip == NULL)
  {
    r = PHISH_ERR_MEMORY;
  }
  
  freeHostent(h);
  
  return r;
}

phish_result_t phish_util_tcpConnect(int sock, const char *server, int port)
{
  struct sockaddr_in server_addr;
  phish_util_hostent_t *server_host;
  
  server_host = phish_getHostByName(server);
  if (server_host == NULL)
  {
    return PHISH_ERR_RESOLVE;
  }
  
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(port);
  memcpy(&server_addr.sin_addr, server_host->ent->h_addr_list[0],
          server_host->ent->h_length);
  memset(server_addr.sin_zero, 0, 8);
  
  freeHostent(server_host);
  
  /* connect to server */
  if (connect(sock, (struct sockaddr *)&server_addr,
              sizeof(server_addr)) == -1)
  {
    return PHISH_ERR_TCP_CONNECT;
  }

  return PHISH_SUCCESS;
}

phish_result_t phish_util_sockReadLine(int sock, char *line,
                                       size_t line_length)
{
  char last_char_read;
  char *pos = line;
  size_t length_remain = line_length;
  ssize_t bytes_read;  
  do
  {
    bytes_read = recv(sock, pos, 1, 0);
    last_char_read = *pos;
    pos++;
    length_remain--;
  } while (bytes_read > 0 && length_remain > 1 && last_char_read != '\r' &&
           last_char_read != '\n');
  
  if (bytes_read == -1)
    return PHISH_ERR_SOCK_READ;
  
  *pos = '\0';
  if (last_char_read == '\r')
  {
    /* remove trailing carriage return and read new line character */
    char dummy;
    
    *(--pos) = '\0';
    bytes_read = recv(sock, &dummy, 1, 0);
    
    if (bytes_read == -1)
      return PHISH_ERR_SOCK_READ;
  }
  
  return PHISH_SUCCESS;
}

static phish_result_t sockWrite(int sock, const char *line)
{
  ssize_t bytes_written = 1;
  char *pos = (char *)line;
  size_t length_remain = strlen(line);
  
  while (bytes_written > 0 && length_remain > 0)
  {
    bytes_written = send(sock, line, length_remain, 0);
    pos += bytes_written;
    length_remain -= bytes_written;
  }
  
  if (bytes_written == -1)
    return PHISH_ERR_SOCK_WRITE;
  
  return PHISH_SUCCESS;
}

phish_result_t phish_util_sockWriteLine(int sock, const char *line)
{
  const char *crlf = "\r\n";
  
  if (sockWrite(sock, line) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_WRITE;
  }
  
  if (sockWrite(sock, crlf) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_WRITE;
  }
  
  return PHISH_SUCCESS;
}

static phish_result_t phish_util_sendHttpGetHeader(int sock, const char *field,
                                                   const char *content)
{
  int line_len;
  char *line;
  
  line_len = strlen(field) + 2 + strlen(content) + 1;
  line = malloc(line_len);
  if (line == NULL)
    return PHISH_ERR_MEMORY;


  snprintf(line, line_len, "%s: %s", field, content);
  
  if (phish_util_sockWriteLine(sock, line) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_WRITE;
  }
  
  free(line);
  
  return PHISH_SUCCESS;
}

phish_result_t phish_util_httpGet(int sock, const char *path,
                                  const char *version, const char *host,
                                  const char *user_agent,
                                  const char *referrer,
                                  const char *if_none_match, int keep_alive)
{
  char *line;
  size_t line_len;
  
  /* send GET line */
  line_len = 4 + strlen(path) + 6 + strlen(version) + 1;
  line = malloc(line_len);
  if (line == NULL)
    return PHISH_ERR_MEMORY;
  
  snprintf(line, line_len, "GET %s HTTP/%s", path, version);
  if (phish_util_sockWriteLine(sock, line) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_WRITE;
  }
  
  free(line);
  
  if (host != NULL)
  {
    if (phish_util_sendHttpGetHeader(sock, "Host", host) != PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  
  if (user_agent != NULL)
  {
    if (phish_util_sendHttpGetHeader(sock, "User-Agent", user_agent) !=
                                                              PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  
  if (referrer != NULL)
  {
    if (phish_util_sendHttpGetHeader(sock, "Referer", referrer) !=
                                                              PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  
  if (if_none_match != NULL)
  {
    if (phish_util_sendHttpGetHeader(sock, "If-None-Match", if_none_match) !=
                                                                PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  
  if (keep_alive)
  {
    if (phish_util_sendHttpGetHeader(sock, "Connection", "Keep-Alive") !=
        PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  else
  {
    if (phish_util_sendHttpGetHeader(sock, "Connection", "close") !=
        PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_WRITE;
    }
  }
  
  if (phish_util_sockWriteLine(sock, "") != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_WRITE;
  }

  return PHISH_SUCCESS;
}

phish_result_t phish_util_parseHTTPReply(int sock,
                                         phish_util_http_headers_t *result)
{
  char buf[BUF_SIZE];
  int dummy;
  int i = 0;
  
  /* initialise result structure */
  result->status_code = -1;
  result->content_length = -1;
  result->etag = NULL;
  
  /* read status line, e.g. "200 OK" */
  if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_READ;
  }
  
  if (sscanf(buf, "HTTP/%d.%d %d", &dummy, &dummy, &result->status_code) != 3)
    return PHISH_ERR_HTTP_BAD_HEADER;
  
  if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
  {
    return PHISH_ERR_SOCK_READ;
  }
  
  /* read rest of headers in reply */
  while (strcmp(buf, "") != 0)
  {
    char *field, *content;
    
    i = 0;
    
    /* extract field name and field content from reply line */
    while (buf[i] != '\0' && buf[i] != ':')
      i++;
    
    if (buf[i] == '\0')
      return PHISH_ERR_HTTP_BAD_HEADER;
    
    field = malloc(i + 1);
    if (field == NULL)
      return PHISH_ERR_MEMORY;
    
    strncpy(field, buf, i);
    field[i++] = '\0';
    
    while (buf[i] != '\0' && buf[i] == ' ')
      i++;
    
    if (buf[i] == '\0')
    {
      free(field);
      return PHISH_ERR_HTTP_BAD_HEADER;
    }
    
    content = malloc(strlen(buf + i) + 1);
    if (content == NULL)
    {
      free(field);
      return PHISH_ERR_MEMORY;
    }
    
    strncpy(content, buf + i, strlen(buf + i));
    content[strlen(buf + i)] = '\0';
    
    if (strcmp(field, "Content-Length") == 0)
    {
      result->content_length = atoi(content);
    }
    else if (strcmp(field, "ETag") == 0)
    {
      result->etag = malloc(strlen(content) + 1);
      if (!result->etag)
      {
        return PHISH_ERR_MEMORY;
      }
      strcpy(result->etag, content);
    }

    free(field);
    free(content);
    
    if (phish_util_sockReadLine(sock, buf, BUF_SIZE) != PHISH_SUCCESS)
    {
      return PHISH_ERR_SOCK_READ;
    }
  } while (strcmp(buf, "") != 0);
  
  return PHISH_SUCCESS;
}

--- trunk/client/libphish/src/phish_util_net.h #1:2

/***************************************************************************
 *   Copyright (C) 2005 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/


#ifndef __PHISH_UTIL_NET_H
#define __PHISH_UTIL_NET_H


#include <stdlib.h>

#include "phish.h"


#define HTTP_STATUS_OK           200
#define HTTP_STATUS_NOT_MODIFIED 304


/** Headers returned from HTTP reply */
typedef struct
{
  /** Status code, e.g. 200 for O.K */
  int status_code;

  /** Length of content */
  size_t content_length;

  /** ETag field */
  char *etag;
} phish_util_http_headers_t;


/** Resolves a hostname to its IP address.
 *  @param host hostname to look up
 *  @param ip pointer to string which will be allocated and assigned with
 *            corresponding IP address
 */
phish_result_t phish_util_hostToIP(const char *host, char **ip);

/** Initiates a TCP connection to a server.
 *  @param sock socket to connect on
 *  @param server server to connect to
 *  @param port port on server to connect to
 */
phish_result_t phish_util_tcpConnect(int sock, const char *server, int port);

/** Read a line from a connected socket up to a new line character.
 *  @param sock socket to read from
 *  @param line buffer to fill with data read. Carriage return and new line
 *              will be read but won't be added to buffer
 *  @param line_length size of line argument
 */
phish_result_t phish_util_sockReadLine(int sock, char *line,
                                       size_t line_length);

/** Writes a line to a connected socket, including a carriage return and line
 *  feed at end.
 *  @param sock socket to write to
 *  @param line null-terminated string to write.
 */
phish_result_t phish_util_sockWriteLine(int sock, const char *line);

/** Sends an HTTP GET request to a socket connected to an HTTP server.
 *  @param sock socket connected to HTTP server to send request to
 *  @param path path requested
 *  @param version version string of HTTP request (e.g. "1.1")
 *  @param host "Host" field of request, NULL if not to send such a field
 *  @param user_agent User Agent field of request, NULL if not to send such
 *                    a field
 *  @param referrer Referrer field of request, NULL of not to send such a field
 *  @param if_none_match "If-None-Match" field of request, NULL of not to send
 *                       such a field
 *  @param keep-alive 1 if to keep connection to server alive after request, 0
 *                    if to close connection after request
 */
phish_result_t phish_util_httpGet(int sock, const char *path,
                                  const char *version, const char *host,
                                  const char *user_agent,
                                  const char *referrer,
                                  const char *if_none_match, int keep_alive);

/** Reads headers of HTTP reply from a socket connected to an HTTP server and
 *  parses them.
 *  @param sock socket connected to HTTP server to read reply from
 *  @param result pointer to phish_util_http_headers_t structure which will
 *                be filled results of reply read
 */
phish_result_t phish_util_parseHTTPReply(int sock,
                                         phish_util_http_headers_t *result);


#endif /* __PHISH_UTIL_NET_H */

--- trunk/client/libphish/src/phish_util_url.c #1:2

/***************************************************************************
 *   Copyright (C) 2006 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef WIN32
#include <ctype.h>
#endif

#include "phish.h"
#include "phish_util_url.h"

static int isNum(const char *str)
{
  while (*str != '\0')
  {
    if (!isdigit(*str))
      return 0;

    str++;
  }

  return 1;
}

static phish_result_t parseURL(const char *str, phish_util_url_t *url)
{
  int state = 0;
  unsigned int i = 0;
  unsigned int begin = 0;
  int user_read = 0;
  char *tmp = NULL; /* either user name or host, before we know which one */
  char *port = NULL;
  char c;

  while ((c = str[i]) != '\0')
  {
    switch(state)
    {
      case -2:
        /* memory allocation error occured */
        free(port);
        phish_util_deleteURL(url);
        return PHISH_ERR_MEMORY;

      case -1:
        /* error in format of URL */
        free(port);
        phish_util_deleteURL(url);
        return PHISH_ERR_MALFORMED_URL;

      case 0:
        /* reading protocol - only alphabetic characters are allowed */
        if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))
        {
          if (c == ':' && str[i + 1] == '/' && str[i + 2] == '/')
          {
            url->protocol = malloc(i + 1);
            if (url->protocol == NULL)
            {
              state = -2;
            }
            else
            {
              if (i == begin)
              {
                /* must contain at least one character */
                state = -1;
              }
              else
              {
                strncpy(url->protocol, str, i);
                url->protocol[i] = '\0';
                i += 2;
                begin = i + 1;
                state = 1; /* move to reading user name or host */
              }
            }
          }
          else
          {
            state = -1;
          }
        }
        break;

      case 1:
        /* reading user name or host */
        if (c == '@')
        {
          if (user_read)
          {
            state = -1; /* @ character illegal in host */
          }
          else
          {
            url->user = malloc(i - begin + 1);
            if (url->user == NULL)
            {
              state = -2;
            }
            else
            {
              if (i == begin)
              {
                /* must contain at least one character */
                state = -1;
              }
              else
              {
                strncpy(url->user, str + begin, i - begin);
                url->user[i - begin] = '\0';
                begin = i + 1;
                user_read = 1; /* remain at same state and read host */
              }
            }
          }
        }
        else if (c == ':')
        {
          tmp = malloc(i - begin + 1);
          if (tmp == NULL)
          {
            state = -2;
          }
          else
          {
            if (i == begin)
            {
              /* must contain at least one character */
              free(tmp);
              state = -1;
            }
            else
            {
              strncpy(tmp, str + begin, i - begin);
              tmp[i - begin] = '\0';
              begin = i + 1;
              state = 2; /* move to reading password or port */
            }
          }
        }
        else if (c == '/')
        {
          url->host = malloc(i - begin + 1);
          if (url->host == NULL)
          {
            state = -2;
          }
          else
          {
            if (i == begin)
            {
              /* must contain at least one character */
              state = -1;
            }
            else
            {
              strncpy(url->host, str + begin, i - begin);
              url->host[i - begin] = '\0';
              begin = i;
              state = 3; /* move to reading path */
            }
          }
        }
        break;

      case 2:
        /* reading password or port */
        if (c == '@')
        {
          url->user = tmp;
          user_read = 1;

          url->password = malloc(i - begin + 1);
          if (url->password == NULL)
          {
            state = -2;
          }
          else
          {
            if (i == begin)
            {
              /* must contain at least one character */
              state = -1;
            }
            else
            {
              strncpy(url->password, str + begin, i - begin);
              url->password[i - begin] = '\0';
              begin = i + 1;
              state = 1; /* move to reading host */
            }
          }
        }
        else if (c == '/')
        {
          url->host = tmp;

          port = malloc(i - begin + 1);
          if (port == NULL)
          {
            state = -2;
          }
          else
          {
            if (i == begin)
            {
              /* must contain at least one character */
              state = -1;
            }
            else
            {
              strncpy(port, str + begin, i - begin);
              port[i - begin] = '\0';
              if (!isNum(port))
              {
                /* port string must evaluate to a number */
                state = -1;
              }
              else
              {
                url->port = atoi(port);
                begin = i;
                state = 3; /* move to reading path */
              }
            }
          }
        }
        break;
        
      case 3:
        /* reading path */
        if (c == '#')
        {
          url->path = malloc(i - begin + 1);
          if (url->path == NULL)
          {
            state = -2;
          }
          else
          {
            if (i == begin)
            {
              /* must contain at least one character */
              state = -1;
            }
            else
            {
              strncpy(url->path, str + begin, i - begin);
              url->path[i - begin] = '\0';
              begin = i + 1;
              state = 4; /* move to reading anchor */
            }
          }
        }
        break;

      case 4:
        /* reading anchor  - read characters until end of string */
        break;
    }

    if (state >= 0)
      i++;
  }

  free(port);

  if (state == 0)
  {
    /* URL can't contain only protocol */
    phish_util_deleteURL(url);
    return PHISH_ERR_MALFORMED_URL;
  }
  else if (state == 1)
  {
    /* URL ended in host */
    url->host = malloc(i - begin + 1);
    if (url->host == NULL)
    {
      phish_util_deleteURL(url);
      return PHISH_ERR_MEMORY;
    }
    else
    {
      if (i == begin)
      {
        /* must contain at least one character */
        phish_util_deleteURL(url);
        return PHISH_ERR_MALFORMED_URL;
      }
      else
      {
        strncpy(url->host, str + begin, i - begin);
        url->host[i - begin] = '\0';
      }
    }
  }
  else if (state == 2)
  {
    /* URL ended in port */
    url->host = tmp;

    port = malloc(i - begin + 1);
    if (port == NULL)
    {
      phish_util_deleteURL(url);
      return PHISH_ERR_MEMORY;
    }
    else
    {
      if (i == begin)
      {
        /* must contain at least one character */
        free(port);
        phish_util_deleteURL(url);
        return PHISH_ERR_MALFORMED_URL;
      }
      else
      {
        strncpy(port, str + begin, i - begin);
        port[i - begin] = '\0';
        if (!isNum(port))
        {
          /* port string must evaluate to a number */
          free(port);
          phish_util_deleteURL(url);
          return PHISH_ERR_MALFORMED_URL;
        }
        else
        {
          url->port = atoi(port);
          free(port);
        }
      }
    }
  }
  else if (state == 3)
  {
    /* URL ended in path */
    url->path = malloc(i - begin + 1);
    if (url->path == NULL)
    {
      phish_util_deleteURL(url);
      return PHISH_ERR_MEMORY;
    }
    else
    {
      if (i == begin)
      {
        /* must contain at least one character */
        phish_util_deleteURL(url);
        return PHISH_ERR_MALFORMED_URL;
      }
      else
      {
        strncpy(url->path, str + begin, i - begin);
        url->path[i - begin] = '\0';
      }
    }
  }
  else if (state == 4)
  {
    /* URL ended in anchor */
    url->anchor = malloc(i - begin + 1);
    if (url->anchor == NULL)
    {
      phish_util_deleteURL(url);
      return PHISH_ERR_MEMORY;
    }
    else
    {
      strncpy(url->anchor, str + begin, i - begin);
      url->anchor[i - begin] = '\0';
    }
  }

  return PHISH_SUCCESS;
}

phish_result_t phish_util_strToURL(const char *str, phish_util_url_t *url)
{
  phish_result_t r;

  r = parseURL(str, url);
  if (r != PHISH_SUCCESS)
    return r;

  if (url->path == NULL)
  {
    url->path = malloc(2);
    if (url->path == NULL)
    {
      phish_util_deleteURL(url);
      return PHISH_ERR_MEMORY;
    }
    
    url->path[0] = '/';
    url->path[1] = '\0';
  }

  return PHISH_SUCCESS;
}

void phish_util_checkURLScheme(phish_util_url_t *url,
                               phish_url_data_t *results)
{
  int i;

  if (url->user != NULL)
    results->user_scheme = 1;
  else
    results->user_scheme = 0;

  results->suspicious_host = 0;
  for (i = 0 ; i < strlen(url->host) ; i++)
  {
    char c = url->host[i];

    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
          c == '.' || c == '-' || isdigit(c)))
    {
      results->suspicious_host = 1;
      break;
    }
  }
}

void phish_util_initURL(phish_util_url_t *url)
{
  url->protocol = NULL;
  url->user = NULL;
  url->password = NULL;
  url->host = NULL;
  url->port = -1;
  url->path = NULL;
  url->anchor = NULL;
}

void phish_util_deleteURL(phish_util_url_t *url)
{
  free(url->protocol);
  free(url->user);
  free(url->password);
  free(url->host);
  free(url->path);
  free(url->anchor);
}

--- trunk/client/libphish/src/phish_util_url.h #1:2

/***************************************************************************
 *   Copyright (C) 2006 Meni Livne <livne at kde.org>                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/


#ifndef __PHISH_UTIL_URL_H
#define __PHISH_UTIL_URL_H


#include "phish.h"


/** Structure used to represent a URL. */
typedef struct
{
  /** Protocol part of URL */
  char *protocol;

  /** Username part of URL, NULL if none */
  char *user;

  /** Password part of URL, NULL if none */
  char *password;

  /** Host part of URL */
  char *host;

  /** Port part of URL, -1 if none */
  int port;

  /** Path part of URL */
  char *path;

  /** Anchor part of URL (after the '#', like used in the <a name> tag */
  char *anchor;

} phish_util_url_t;


/** Parses a URL.
 *  @param str string representing URL to parse
 *  @param url will be filled with results of parsing URL
 */
phish_result_t phish_util_strToURL(const char *str, phish_util_url_t *url);

/** Checks the URL scheme, i.e. whether it contains a username and whether
 *  the server part contains suspicious characters
 *  @param url URL to check
 *  @param results pointer to phish_url_data_t structure whose relevant
 *                 fields will be filled with results
 */
void phish_util_checkURLScheme(phish_util_url_t *url,
                               phish_url_data_t *results);

/** Initialise a URL structure.
 *  @param url pointer to URL structure to initialise
 */
void phish_util_initURL(phish_util_url_t *url);

/** Frees memory allocated in URL structure
 *  @param url pointer to URL structure to free
 */
void phish_util_deleteURL(phish_util_url_t *url);


#endif /* __PHISH_UTIL_URL_H */



From livne at kde.org  Tue Apr 11 19:45:55 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 19:45:55 +0200
Subject: [opdb-commits] r4 - tags
Message-ID: <200604111745.k3BHjtDM007728@sheep.berlios.de>

SVN commit 4 by meni:

Place for libphish tags.


 A             tags/libphish (directory)  




From livne at kde.org  Tue Apr 11 19:48:29 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 19:48:29 +0200
Subject: [opdb-commits] r5 - tags/libphish
Message-ID: <200604111748.k3BHmTZQ009067@sheep.berlios.de>

SVN commit 5 by meni:

Preparing to tag version 0.1.0.


 A             tags/libphish/0.1.0 (directory)  




From livne at kde.org  Tue Apr 11 19:50:31 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 19:50:31 +0200
Subject: [opdb-commits] r6 - tags/libphish/0.1.0
Message-ID: <200604111750.k3BHoVXY009771@sheep.berlios.de>

SVN commit 6 by meni:

Tagging libphish 0.1.0.


 A             tags/libphish/0.1.0/libphish (directory)   trunk/client/libphish#5




From livne at kde.org  Tue Apr 11 21:12:26 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:12:26 +0200
Subject: [opdb-commits] r7 - tags
Message-ID: <200604111912.k3BJCQt2008379@sheep.berlios.de>

SVN commit 7 by meni:

Place for FirePhish tags.


 A             tags/firephish (directory)  




From livne at kde.org  Tue Apr 11 21:13:11 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:13:11 +0200
Subject: [opdb-commits] r8 - tags
Message-ID: <200604111913.k3BJDBDl008564@sheep.berlios.de>

SVN commit 8 by meni:

Place for Karpion tags.


 A             tags/karpion (directory)  




From livne at kde.org  Tue Apr 11 21:13:45 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:13:45 +0200
Subject: [opdb-commits] r9 - tags/firephish
Message-ID: <200604111913.k3BJDjLr008697@sheep.berlios.de>

SVN commit 9 by meni:

Preparing to tag version 0.1.0.


 A             tags/firephish/0.1.0 (directory)  




From livne at kde.org  Tue Apr 11 21:14:40 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:14:40 +0200
Subject: [opdb-commits] r10 - tags/firephish/0.1.0
Message-ID: <200604111914.k3BJEeoR008893@sheep.berlios.de>

SVN commit 10 by meni:

Tagging FirePhish 0.1.0.


 A             tags/firephish/0.1.0/firephish (directory)   trunk/client/firephish#9




From livne at kde.org  Tue Apr 11 21:15:16 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:15:16 +0200
Subject: [opdb-commits] r11 - tags/karpion
Message-ID: <200604111915.k3BJFGud009167@sheep.berlios.de>

SVN commit 11 by meni:

Preparing to tag version 0.1.0.


 A             tags/karpion/0.1.0 (directory)  




From livne at kde.org  Tue Apr 11 21:16:26 2006
From: livne at kde.org (Meni Livne)
Date: Tue, 11 Apr 2006 21:16:26 +0200
Subject: [opdb-commits] r12 - tags/karpion/0.1.0
Message-ID: <200604111916.k3BJGQE5009992@sheep.berlios.de>

SVN commit 12 by meni:

Tagging Karpion 0.1.0.


 A             tags/karpion/0.1.0/karpion (directory)   trunk/client/karpion#11




From livne at kde.org  Wed Apr 12 15:19:26 2006
From: livne at kde.org (Meni Livne)
Date: Wed, 12 Apr 2006 15:19:26 +0200
Subject: [opdb-commits] r13 - in trunk/client: karpion libphish
Message-ID: <200604121319.k3CDJQ6i020739@sheep.berlios.de>

SVN commit 13 by meni:

Added .spec files to generate RPM packages for libphish and karpion,
courtesy of Diego Iastrubni <elcuco at kde.org>.


 A             karpion/karpion.spec  
 A             libphish/libphish.spec  


--- trunk/client/karpion/karpion.spec #12:13

Name: karpion
Summary: Anti-Phishing toolbar for Konqueror
Version: 0.1.0
Release: 1cuco
License: GPL 2
Group: Network
URL: http://www.kde-apps.org/content/show.php?content=29398
Packager: Diego Iastrubni <elcuco at kde.org>
Requires: libphish
Source0: %{name}-%{version}.tar.bz2

Buildroot: %{_tmppath}/%{name}-%{version}-%{release}-root

%description
Konqueror Anti-Phishing Toolbar (a.k.a. Karpion) is an addon for the Konqueror
browser which utilises the Open Phishing Database to provide the user with
information and tools that help protect against phishing.

Note that Konqueror Anti-Phishing Toolbar requires libphish, a cross-platform
library to interact with the Open Phishing Database. Libphish can be obtained
at the Open Phishing Database website: http://opdb.berlios.de/
 

%prep 
%setup
#cd mtaskbar
. /etc/opt/kde3/common_options
update_admin --no-unsermake

#----------------------------
%build 
#cd mtaskbar
. /etc/opt/kde3/common_options
%configure --prefix=/opt/kde3

# this fails to compile, why?
#./configure $configkde
make 

#----------------------------
%install 
rm -fr %{buildroot}
#cd mtaskbar
. /etc/opt/kde3/common_options
%makeinstall libdir=/opt/kde3/lib


#----------------------------
%clean 
rm -fr %{buildroot}


#----------------------------
%post 
#post install script

#----------------------------
%preun 
#pre uninstall script

#----------------------------
%postun 
#post uninstall script

#----------------------------
%files 
%defattr(-,root,root) 
/

%changelog 
* Wed Apr 12 2006 Diego Iastrubni <elcuco at kde.org>
- First version
--- trunk/client/libphish/libphish.spec #12:13

Name: libphish
Summary: A cross-platform library to interact with the Open Phishing Database
Version: 0.1.0
Release: 1cuco
License: GPL V2
Group: Network
URL: http://opdb.berlios.de/
Packager: Diego Iastrubni <elcuco at kde.org>
Requires: expat
Source0: %{name}-%{version}.tar.bz2

Buildroot: %{_tmppath}/%{name}-%{version}-%{release}-root

%description
Libphish is a cross-platform library to interact with the Open Phishing
Database. It provides a consistent API which browsers and other programs can
use to verify the safety and risk level of URLs.

Libphish is part of the Open Phishing Database project, an effort to create
and maintain and open database of phishing sites, in addition to providing
extensions to browsers that utilise the database. Libphish is used by the
FirePhish anti-phishing toolbar for Firefox and the Konqueror Anti-Phishing 
Toolbar.

Note that libphish requires the expat XML parsing library. 


%prep 
%setup

#----------------------------
%build 
%configure
make 

#----------------------------
%install 
rm -fr %{buildroot}
%makeinstall 


#----------------------------
%clean 
rm -fr %{buildroot}


#----------------------------
%post 
#post install script

#----------------------------
%preun 
#pre uninstall script

#----------------------------
%postun 
#post uninstall script

#----------------------------
%files 
%defattr(-,root,root) 
/

%changelog 
* Wed Apr 12 2006 Diego Iastrubni <elcuco at kde.org>
- First version


